/'-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------'/

/'----------------------------------------------------------------------
Parser.bi Specification
-----------------------------------------------------------------------'/

-->begin

#ifndef COCO_PARSER_H__
#define COCO_PARSER_H__

#ifndef NIL
#define NIL 0
#endif

-->headerdef

#include once "Scanner.bi"

-->namespace_open

''errors taken from parser.bi to solve tab->errors dependency
type errors_

public:
	dim count as integer  '' number of errors detected

end type '' Errors

declare function errors_create() as errors_ ptr
declare sub errors_destroy(byref errors as errors_ ptr)
declare sub errors_synerr(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval n as integer)
declare sub errors_error(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval s as wchar_t ptr) 
declare sub errors_warning_line(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval s as wchar_t ptr)
declare sub errors_warning(byval errors as errors_ ptr, byval s as wchar_t ptr)
declare sub errors_exception(byval errors as errors_ ptr, byval s as wchar_t ptr) 

type parser_

-->constantsheader
	dim dummytoken as token_ ptr
	dim errdist as integer
	dim minerrdist as integer


	dim scanner as scanner_ ptr
	dim errors as errors_ ptr

	dim t as token_ ptr			'' last recognized token
	dim la as token_ ptr			'' lookahead token

-->declarations  

end type ''end parser

declare function parser_create(byval scanner as scanner_ ptr) as parser_ ptr
declare sub parser_destroy(byref parser as parser_ ptr)
declare sub parser_synerr(byval parser as parser_ ptr, byval n as integer)
declare sub parser_semerr(byval parser as parser_ ptr, byval msg as wchar_t ptr)
declare sub parser_get(byval parser as parser_ ptr)
declare sub parser_expect(byval parser as parser_ ptr, byval n as integer) 
declare function parser_startof(byval parser as parser_ ptr, byval s as integer) as byte
declare sub parser_expectweak(byval parser as parser_ ptr, byval n as integer, byval follow as integer)
declare function parser_weakseparator(byval parser as parser_ ptr, byval n as integer, _
                                      byval syfol as integer, byval repfol as integer) as byte


-->productionsheader
declare sub parser_parse(byval parser as parser_ ptr)

-->namespace_close

#endif '' ifndef COCO_PARSER_H__

-->implementation

/'----------------------------------------------------------------------
Parser.bas Specification
-----------------------------------------------------------------------'/

-->begin

#include once "crt/wchar.bi"
#include once "parser.bi"
#include once "scanner.bi"

-->namespace_open

sub parser_synerr(byval parser as parser_ ptr, byval n as integer)
	
  if (parser->errdist >= parser->minerrdist) then
    errors_synerr(parser->errors,parser->la->line, parser->la->col, n)
	end if
  parser->errdist = 0

end sub

sub parser_semerr(byval parser as parser_ ptr, byval msg as wchar_t ptr)
	
  if (parser->errdist >= parser->minerrdist) then
    errors_error(parser->errors,parser->t->line, parser->t->col, msg)
  end if
	parser->errdist = 0

end sub

sub parser_get(byval parser as parser_ ptr)
	
  while (1)
		parser->t = parser->la
		parser->la = scanner_scan(parser->scanner)
		if (parser->la->kind <= parser->maxt) then
       parser->errdist += 1
       exit while
    end if
-->pragmas
		if (parser->dummytoken <> parser->t) then
			parser->dummytoken->kind = parser->t->kind
			parser->dummytoken->pos = parser->t->pos
			parser->dummytoken->col = parser->t->col
			parser->dummytoken->line = parser->t->line
			parser->dummytoken->next = NIL
			coco_string_destroy(parser->dummytoken->val)
			parser->dummytoken->val = coco_string_create(parser->t->val)
			parser->t = parser->dummytoken
		end if
		parser->la = parser->t
	wend

end sub

sub parser_expect(byval parser as parser_ ptr, byval n as integer) 
	
  if (parser->la->kind = n) then
    parser_get(parser)
  else 
    parser_synerr(parser,n)
  end if

end sub

sub parser_expectweak(byval parser as parser_ ptr, byval n as integer, byval follow as integer)
	
  if (parser->la->kind = n) then
    parser_get(parser)
	else 
		parser_synerr(parser,n)
		while (parser_startof(parser,follow) = 0)
      parser_get(parser)
    wend
	end if

end sub


function parser_weakseparator(byval parser as parser_ ptr, byval n as integer, _
                              byval syfol as integer, byval repfol as integer) as byte
	
  if (parser->la->kind = n) then
    parser_get(parser)
    return 1
	elseif (parser_startof(parser,repfol)) then
    return 0
	else
		parser_synerr(parser,n)
		while (parser_startof(parser,syfol) = 0 orelse parser_startof(parser,repfol) orelse parser_startof(parser,0))
			parser_get(parser)
		wend
		return parser_startof(parser,syfol)
	end if

end function

-->productions

sub parser_parse(byval parser as parser_ ptr)
	
  parser->t = NIL
	parser->dummytoken = token_create()
  parser->la = parser->dummytoken
	parser->la->val = coco_string_create(@wstr("Dummy Token"))
	parser_get(parser)
-->parseroot
end sub

function parser_create(byval scanner as scanner_ ptr) as parser_ ptr
	
  dim parser as parser_ ptr    
  parser = callocate(1,sizeof(parser_))

-->constants
	parser->dummytoken = NIL
	parser->la = NIL
  parser->t = NIL
	parser->minerrdist = 2
	parser->errdist = parser->minerrdist
	parser->scanner = scanner
	parser->errors = errors_create()
  return parser
  
end function

function parser_startof(byval parser as parser_ ptr, byval s as integer) as byte
	
  const T as ubyte = 1
	const x as ubyte = 0

-->initialization

  return set(s,parser->la->kind)

end function

sub parser_destroy(byref parser as parser_ ptr)
  
  if (parser = NIL) then
    return
  end if
  
  errors_destroy(parser->errors)

  if (parser->errors <> NIL) then
    deallocate(parser->errors)
    parser->errors = NIL
  end if
  
  deallocate(parser)
  parser = NIL

end sub

function errors_create() as errors_ ptr
	
  dim errors as errors_ ptr
  errors = callocate(1,sizeof(errors_))
  errors->count = 0
  return errors

end function

sub errors_destroy(byref errors as errors_ ptr)
	
  if (errors = NIL) then
    return
  end if
  deallocate(errors)
  errors = NIL

end sub

sub errors_synerr(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval n as integer)
	
  dim s as wchar_t ptr
	select case as const (n) 
-->errors
  case else		
			dim format_(0 to 20) as wchar_t			
      coco_swprintf(@format_(0), 20, @wstr(!"error %d"), n)
			s = coco_string_create(@format_(0))
	end select
	wprintf(@wstr(!"-- line %d col %d: %ls\n"), line_, col, s)
	coco_string_destroy(s)
	errors->count+=1

end sub

sub errors_error(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval s as wchar_t ptr) 
	
  wprintf(@wstr(!"-- line %d col %d: %ls\n"), line_, col, s)
	errors->count += 1

end sub

sub errors_warning_line(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval s as wchar_t ptr)
	
  wprintf(@wstr(!"-- line %d col %d: %ls\n"), line_, col, s)

end sub

sub errors_warning(byval errors as errors_ ptr, byval s as wchar_t ptr)
	
  wprintf(@wstr(!"%ls\n"), s)

end sub

sub errors_exception(byval errors as errors_ ptr, byval s as wchar_t ptr) 
	
  wprintf(@wstr(!"%ls"), s) 
	exit_(1)

end sub

-->namespace_close
