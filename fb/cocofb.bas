/'-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------'/
#define DEBUG1
#ifdef DEBUG
  #define DWPRINTFUN wprintf(@wstr(!"START { %ls\n"),@wstr(__FUNCTION__))
  #define DWPRINTFUNE wprintf(@wstr(!"}END %ls\n"),@wstr(__FUNCTION__)):
  #define dsleep sleep
#else
  #define DWPRINTFUN
  #define DWPRINTFUNE
  #define dsleep
#endif

#ifndef COCO_POSITION_H__
#define COCO_POSITION_H__

#ifndef NIL
#define NIL 0
#endif

type position_  '' position of source code stretch (e.g. semantic action, resolver expressions)

public:
  dim beg as integer      '' start relative to the beginning of the file
  dim end as integer      '' end of stretch
  dim col_ as integer      '' column number of start position
  dim line as integer     '' line number of beginnnig of source code srtetch

end type

declare function position_create(byval beg as integer, byval end_ as integer, _
                                 byval col_ as integer, byval line_ as integer) as position_ ptr
                                 
declare sub position_destroy(byref position as position_ ptr)

#endif '' ifndef COCO_POSITION_H__

function position_create(byval beg as integer, byval end_ as integer, byval col_ as integer, byval line_ as integer) as position_ ptr
  
  dim position as position_ ptr
  position = callocate(1,sizeof(position_))
  position->beg = beg
  position->end = end_
  position->col_ = col_
  position->line = line_
  return position
  
end function

sub position_destroy(byref position as position_ ptr)

  if (position = NIL) then
    return
  end if
  deallocate(position)
  position = NIL

end sub

'declarations of coco_string_ put here due to dependencies
#include once "crt/limits.bi"
#include once "crt/stdio.bi"
#include once "crt/stdlib.bi"
#include once "crt/string.bi"
#include once "crt/wchar.bi"

'' io.h and fcntl are used to ensure binary read from streams on windows
#include once "crt/io.bi"
#include once "crt/fcntl.bi"


'' assume every other 
#define coco_swprintf _snwprintf

#define COCO_WCHAR_MAX 65535
#define MIN_BUFFER_LENGTH 1024
#define MAX_BUFFER_LENGTH (64*MIN_BUFFER_LENGTH)
#define HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR ":"

'' string handling, wide character
declare function coco_string_create(byval value as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_i(byval value as wchar_t ptr, byval startindex as integer) as wchar_t ptr
declare function coco_string_create_il(byval value as wchar_t ptr, byval startindex as integer, byval length as integer) as wchar_t ptr
declare function coco_string_create_upper(byval data_ as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_lower(byval data_ as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_lower_il(byval data_ as wchar_t ptr, byval startindex as integer, byval datalen as integer) as wchar_t ptr
declare function coco_string_create_appendws(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_appendwc(byval target as wchar_t ptr, byval appendix as wchar_t) as wchar_t ptr
declare sub coco_string_destroy(byref data_ as wchar_t ptr)
declare function coco_string_length(byval data_ as wchar_t ptr) as integer
declare function coco_string_endswith(byval data_ as wchar_t ptr, byval end_ as wchar_t ptr) as byte
declare function coco_string_indexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
declare function coco_string_lastindexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
declare sub coco_string_merge(byref target as wchar_t ptr, byval appendix as wchar_t ptr)
declare function coco_string_equal(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as byte
declare function coco_string_compareto(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as integer
declare function coco_string_hash(byval data_ as wchar_t ptr) as integer

'' string handling, ascii character
declare function coco_string_create_zstr(byval value as zstring ptr) as wchar_t ptr
declare function coco_string_create_char(byval value as wchar_t ptr) as zstring ptr
declare sub coco_string_destroy_zstr(byref data_ as zstring ptr)



#ifndef COCO_BITARRAY_H__
#define COCO_BITARRAY_H__

type  bitarray_

public:
  dim count as integer
  dim data as ubyte ptr

end type

declare function bitarray_create(byval length as integer, byval defaultvalue as byte) as bitarray_ ptr
declare function bitarray_create_copy(byval copy as bitarray_ ptr) as bitarray_ ptr
declare sub bitarray_destroy(byref bitarray as bitarray_ ptr)
declare function bitarray_getcount(byval bitarray as bitarray_ ptr) as integer
declare function bitarray_get(byval bitarray as bitarray_ ptr, byval index as integer) as byte
declare sub bitarray_set(byval bitarray as bitarray_ ptr,byval index as integer, byval value as byte)
declare sub bitarray_setall(byval bitarray as bitarray_ ptr, byval value as byte)
declare function bitarray_equal(byval bitarray as bitarray_ ptr, byval right_ as bitarray_ ptr) as byte
declare function bitarray_itemat(byval bitarray as bitarray_ ptr, byval index as integer) as byte
declare function bitarray_assign(byval bitarray as bitarray_ ptr, byval right_ as bitarray_ ptr) as bitarray_ ptr

declare sub bitarray_not(byval bitarray as bitarray_ ptr)
declare sub bitarray_and(byval bitarray as bitarray_ ptr, byval value as bitarray_ ptr)
declare sub bitarray_or(byval bitarray as bitarray_ ptr, byval value as bitarray_ ptr)
declare sub bitarray_xor(byval bitarray as bitarray_ ptr, byval value as bitarray_ ptr)

declare function bitarray_clone(byval bitarray as bitarray_ ptr) as bitarray_ ptr

#endif '' ifndef COCO_BITARRAY_H__

#include once "crt/string.bi"
#include once "crt/stdio.bi"


function bitarray_create(byval length as integer, byval defaultvalue as byte) as bitarray_ ptr

  dim bitarray as bitarray_ ptr
  
  if (length < 0) then
    return NIL
  end if
  
  bitarray = callocate(1,sizeof(bitarray_))
  bitarray->count = length
  bitarray->data = callocate((length+7) shr 3,sizeof(ubyte))
  if (defaultvalue) then
    memset(bitarray->data, &hFF, (length+7) shr 3)
  else
    memset(bitarray->data, 0, (length+7) shr 3)
  end if
  return bitarray
  
end function

'bitarray_create_copy will return NIL when copy equals NIL
function bitarray_create_copy(byval copy as bitarray_ ptr) as bitarray_ ptr

  if (copy = NIL) then
    return NIL
  end if
  
  dim bitarray as bitarray_ ptr
  bitarray = callocate(1,sizeof(bitarray_))
  bitarray->count  = copy->count
  bitarray->data = callocate((copy->count+7) shr 3,sizeof(ubyte))
  memcpy(bitarray->data, copy->data, (copy->count+7) shr 3)
  return bitarray
  
end function

sub bitarray_destroy(byref bitarray as bitarray_ ptr)

  if (bitarray = NIL) then
    return
  end if

  if (bitarray->data = NIL) then
    deallocate(bitarray)
    bitarray = NIL
    return
  end if
  
  deallocate(bitarray->data)
  bitarray->data = NIL
  deallocate(bitarray)
  bitarray = NIL

end sub

'returns -1 when bitarray equals NIL
function bitarray_getcount(byval bitarray as bitarray_ ptr) as integer

  if (bitarray = NIL) then
    return -1
  end if

  return bitarray->count

end function

'returns -1 if bitarray is NIL
function bitarray_get(byval bitarray as bitarray_ ptr, byval index as integer) as byte

  if (bitarray = NIL) then
    return -1
  end if

  if ((bitarray->data[(index shr 3)] and (1 shl (index and 7))) <> 0) then
    return 1
  else
    return 0
  end if

end function

sub bitarray_set(byval bitarray as bitarray_ ptr,byval index as integer, byval value as byte)

  if (bitarray = NIL) then
    return
  end if

  if (value) then
    bitarray->data[(index shr 3)] or= (1 shl (index and 7))
  else
    dim mask as ubyte = &hFF
    mask xor= (1 shl (index and 7))
    bitarray->data[(index shr 3)] and= mask
  end if

end sub

sub bitarray_setall(byval bitarray as bitarray_ ptr, byval value as byte)

  if (bitarray = NIL) then
    return
  end if

  if (value) then
    memset(bitarray->data, &hFF, (bitarray->count+7) shr 3)
  else
    memset(bitarray->data, 0, (bitarray->count+7) shr 3)
  end if

end sub


sub bitarray_not(byval bitarray as bitarray_ ptr)

  if (bitarray = NIL) then
    return
  end if

  for i as integer = 0 to ((bitarray->count+7) shr 3)
    bitarray->data[i] xor= &hff
  next i

end sub

sub bitarray_and(byval bitarray as bitarray_ ptr, byval value as bitarray_ ptr)

  if (bitarray = NIL) then
    return
  end if

  var i = 0l
  while ( i < ((bitarray->count+7) shr 3) andalso i < ((value->count+7) shr 3)) 
    bitarray->data[i] = (bitarray->data[i] and value->data[i])
    i += 1
  wend

end sub

sub bitarray_or(byval bitarray as bitarray_ ptr, byval value as bitarray_ ptr)

  if (bitarray = NIL) then
    return
  end if

  var i = 0l
  while ( i < ((bitarray->count+7) shr 3) andalso i < ((value->count+7) shr 3)) 
    bitarray->data[i] = (bitarray->data[i] or value->data[i])
    i += 1
  wend

end sub

sub bitarray_xor(byval bitarray as bitarray_ ptr, byval value as bitarray_ ptr)

  if (bitarray = NIL) then
    return
  end if

  var i = 0l
  while ( i < ((bitarray->count+7) shr 3) andalso i < ((value->count+7) shr 3)) 
    bitarray->data[i] = (bitarray->data[i] or value->data[i])
    i += 1
  wend

end sub

'returns NIL if bitarray equals NIL. Allocates a new bitarray and copies
'content of bitarray to the new bitarray otherwise.
function bitarray_clone(byval bitarray as bitarray_ ptr) as bitarray_ ptr

  if (bitarray = NIL) then
    return NIL
  end if

  dim newbitarray as bitarray_ ptr = bitarray_create(bitarray->count,0)
  newbitarray->count = bitarray->count
  memcpy(newbitarray->data, bitarray->data, (bitarray->count+7) shr 3)
  return newbitarray

end function

function bitarray_equal(byval bitarray as bitarray_ ptr, byval right_ as bitarray_ ptr) as byte

  if (bitarray = NIL) then
    if (right_ = NIL) then
      return 1
    else
      return 0
    end if
  end if
  
  if (right_ = NIL) then
    if (bitarray = NIL) then
      return 1
    else
      return 0
    end if
  end if
  
 
  if (bitarray->count <> right_->count) then
    return 0
  end if

  for i as integer = 0 to bitarray->count
    if ((bitarray->data[(i shr 3)] and  (1 shl (i and 7))) <> (right_->data[(i shr 3)] and (1 shl (i and 7)))) then
      return 0
    end if
  next i
  return 1

end function

'bitarray should be created before calling bitarray_assign.
'bitarray_assign fails when either bitarray or right_ equals NIL
function bitarray_assign(byval bitarray as bitarray_ ptr, byval right_ as bitarray_ ptr) as bitarray_ ptr

  if (bitarray = NIL) then
    return NIL
  end if
  
  if (right_ = NIL) then
    return NIL
  end if
  if ( right_ <> bitarray ) then         '' avoid self assignment
    if (bitarray->data <> NIL) then
      deallocate(bitarray->data)              '' prevents memory leak
    end if
    bitarray->count = right_->count
    bitarray->data = callocate((bitarray->count+7) shr 3,sizeof(ubyte))
    memcpy(bitarray->data, right_->data, (bitarray->count+7) shr 3)
  end if
  return bitarray
  
end function

function bitarray_itemat(byval bitarray as bitarray_ ptr, byval index as integer) as byte

  if (bitarray = NIL) then
    return -1
  end if
  
  return bitarray_get(bitarray,index)

end function

sub bitarray_dump(byval bitarray as bitarray_ ptr) 

  if (bitarray = NIL) then
    return
  end if

  var i = bitarray_getcount(bitarray)
  for j as integer = 0 to i - 1
    if (j mod 8 = 0 andalso j <> 0) then
      print
    end if
    print bitarray_itemat(bitarray,j);" ";
  next j

end sub

#ifndef COCO_ARRAYLIST_H__
#define COCO_ARRAYLIST_H__

type arraylist_

public:
  dim count as integer
  dim capacity as integer
  dim data as any ptr ptr

end type

#ifndef COCO_SETS_H__
#define COCO_SETS_H__

'#include "BitArray.bi"

declare function sets_first(byval s as bitarray_ ptr) as integer
declare function sets_elements(byval s as bitarray_ ptr) as integer
declare function sets_equals(byval a as bitarray_ ptr, byval b as bitarray_ ptr) as byte
declare function sets_includes(byval a as bitarray_ ptr, byval b as bitarray_ ptr) as byte
declare function sets_intersect(byval a as bitarray_ ptr, byval b as bitarray_ ptr) as byte '' a * b != {}
declare sub sets_subtract(byval a as bitarray_ ptr, byval b as bitarray_ ptr)

#endif '' ifndef COCO_SETS_H__

function sets_first(byval s as bitarray_ ptr) as integer

    dim max as integer = bitarray_getcount(s)
    for i as integer = 0 to max - 1
      if (bitarray_itemat(s,i)) then
        return i
      end if
    next i
    return -1

end function


function sets_elements(byval s as bitarray_ ptr) as integer

    dim max as integer = bitarray_getcount(s)
    dim n as integer = 0
    for i as integer = 0 to max - 1
      if (bitarray_itemat(s,i)) then
        n += 1
      end if
    next i
    return n

end function
  

function sets_equals(byval a as bitarray_ ptr, byval b as bitarray_ ptr) as byte

    dim max as integer = bitarray_getcount(a)
    for i as integer = 0 to max - 1
      if (bitarray_itemat(a,i) <> bitarray_itemat(b,i)) then
        return 0
      end if
    next i
    return 1

end function


function sets_includes(byval a as bitarray_ ptr, byval b as bitarray_ ptr) as byte  '' a > b ?
    
    dim max as integer = bitarray_getcount(a)
    for i as integer = 0 to max - 1
      if (bitarray_itemat(b,i) andalso bitarray_itemat(a,i) = 0) then
        return 0
      end if
    next i
    return 1

end function
  

function sets_intersect(byval a as bitarray_ ptr, byval b as bitarray_ ptr) as byte '' a * b != {}

    dim max as integer = bitarray_getcount(a)
    for i as integer = 0 to max - 1
      if (bitarray_itemat(a,i) andalso bitarray_itemat(b,i)) then
        return 1
      end if
    next i
    return 0

end function
  

sub sets_subtract(byval a as bitarray_ ptr, byval b as bitarray_ ptr) '' a = a - b
    
    dim c as bitarray_ ptr = bitarray_clone(b)
    bitarray_not(c)
    bitarray_and(a,c)
    bitarray_destroy(c)

end sub

declare function arraylist_create() as arraylist_ ptr
declare sub arraylist_destroy(byref arraylist as arraylist_ ptr)
declare sub arraylist_add(byval arraylist as arraylist_ ptr, byval value as any ptr)
declare sub arraylist_remove(byval arraylist as arraylist_ ptr, byval value as any ptr)
declare function arraylist_itemat(byval arraylist as arraylist_ ptr, byval index as integer) as any ptr

#endif '' ifndef COCO_ARRAYLIST_H__

#include "crt/stdio.bi"


#ifndef NIL
#define NIL 0
#endif

function arraylist_create() as arraylist_ ptr
  
  dim arraylist as arraylist_ ptr
  arraylist = callocate(1,sizeof(arraylist_))
  arraylist->count = 0
  arraylist->capacity = 10
  arraylist->data = callocate(arraylist->capacity,sizeof(any ptr))
  return arraylist
  
end function

sub arraylist_destroy(byref arraylist as arraylist_ ptr)
  
  if (arraylist = NIL) then
    return
  end if

  if (arraylist->data <> NIL) then
    deallocate(arraylist->data)
  end if

  arraylist->data = NIL
  deallocate(arraylist)
  arraylist = NIL

end sub


sub arraylist_add(byval arraylist as arraylist_ ptr, byval value as any ptr)
  
  if (arraylist = NIL) then
    return
  end if
  
  if (arraylist->count < arraylist->capacity) then
    arraylist->data[arraylist->count] = value
    arraylist->count += 1
  else 
    arraylist->capacity shl= 1
    dim newdata as any ptr ptr = callocate(arraylist->capacity,sizeof(any ptr))
    for i as integer = 0 to arraylist->count - 1
      newdata[i] = arraylist->data[i]'' copy
    next i
    newdata[arraylist->count] = value
    arraylist->count += 1
    deallocate(arraylist->data)
    arraylist->data = newdata
  end if

end sub

sub arraylist_remove(byval arraylist as arraylist_ ptr, byval value as any ptr)
  
  if (arraylist = NIL) then
    return
  end if

  for i as integer = 0 to arraylist->count - 1
    if (arraylist->data[i] = value) then
      for j as integer = i + 1 to arraylist->count - 1
        arraylist->data[j-1] = arraylist->data[j]
      next j
      arraylist->count -= 1
      exit for
    end if
  next i

end sub

function arraylist_itemat(byval arraylist as arraylist_ ptr, byval index as integer) as any ptr

  if (arraylist = NIL) then
    return NIL
  end if
  
  if (0 <= index andalso index < arraylist->count) then
    return arraylist->data[index]
  end if
  
  return NIL

end function

#ifndef COCO_CHARSET_H__
#define COCO_CHARSET_H__

#include once "crt/stdio.bi"

type range_

public:
    dim from as integer
    dim to as integer
    dim next as range_ ptr

end type

type charset_

public:
  dim head as range_ ptr

end type

declare function range_create(byval from_ as integer, byval to_ as integer) as range_ ptr
declare sub range_destroy(byref range as range_ ptr)
declare function charset_create() as charset_ ptr
declare sub charset_destroy(byref charset as charset_ ptr)
declare function charset_get(byval charset as charset_ ptr, byval i as integer) as byte
declare sub charset_set(byval charset as charset_ ptr, byval i as integer)
declare function charset_clone(byval charset as charset_ ptr) as charset_ ptr
declare function charset_equals(byval charset as charset_ ptr, byval s as charset_ ptr) as byte
declare function charset_elements(byval charset as charset_ ptr) as integer
declare function charset_first(byval charset as charset_ ptr) as integer
declare sub charset_or(byval charset as charset_ ptr,byval s as charset_ ptr)
declare sub charset_and(byval charset as charset_ ptr,byval s as charset_ ptr)
declare sub charset_subtract(byval charset as charset_ ptr,byval s as charset_ ptr)
declare function charset_includes(byval charset as charset_ ptr,byval s as charset_ ptr) as byte
declare function charset_intersects(byval charset as charset_ ptr,byval s as charset_ ptr) as byte
declare sub charset_clear(byval charset as charset_ ptr)
declare sub charset_fill(byval charset as charset_ ptr)

#endif '' ifndef COCO_CHARSET_H__

#include "crt/string.bi"
#include "crt/stdio.bi"
#include "crt/stdlib.bi"
#include "crt/wchar.bi"
'#include "CharSet.bi"

'#include "Scanner.bi"

function charset_create() as charset_ ptr
  
  dim charset as charset_ ptr
  charset = callocate(1,sizeof(charset_))
  return charset
  
end function

function charset_get(byval charset as charset_ ptr, byval i as integer) as byte
  
  dim p as range_ ptr
  p = charset->head
  while (p <> NIL)  
    if (i < p->from) then
      return 0
    elseif (i <= p->to) then
      return 1 '' p.from <= i <= p.to
    end if
    p = p->next
  wend
  return 0

end function

sub charset_set(byval charset as charset_ ptr, byval i as integer)
  
  dim cur as range_ ptr = charset->head
  dim prev as range_ ptr = NIL
  while (cur <> NIL andalso i >= cur->from-1)
    if (i <= cur->to + 1) then '' (cur.from-1) <= i <= (cur.to+1)
      if (i = cur->from - 1) then
        cur->from -= 1
      elseif (i = cur->to + 1) then
        cur->to += 1
        dim next_ as range_ ptr = cur->next
        if (next_ <> NIL andalso cur->to = next_->from - 1) then
          cur->to = next_->to
          cur->next = next_->next
          range_destroy(next_)
        end if
      end if
      return
    end if
    prev = cur
    cur = cur->next
  wend
  dim n as range_ ptr = range_create(i, i)
  n->next = cur
  if (prev = NIL) then
    charset->head = n
  else 
    prev->next = n
  end if

end sub

function charset_clone(byval charset as charset_ ptr) as charset_ ptr
  
  dim s as charset_ ptr = charset_create()
  dim prev as range_ ptr = NIL
  dim cur as range_ ptr = charset->head
  while (cur <> NIL) 
    dim r as range_ ptr = range_create(cur->from, cur->to)
    if (prev = NIL) then
      s->head = r
    else 
      prev->next = r
    end if    
    prev = r
    cur = cur->next
  wend
  return s

end function

function charset_equals(byval charset as charset_ ptr, byval s as charset_ ptr) as byte
  
  dim p as range_ ptr = charset->head
  dim q as range_ ptr = s->head
  while (p <> NIL andalso q <> NIL)
    if (p->from <> q->from orelse p->to <> q->to) then
      return 0
    end if
    p = p->next
    q = q->next
  wend
  return p = q

end function

function charset_elements(byval charset as charset_ ptr) as integer
  
  dim n as integer = 0
  
  dim p as range_ ptr = charset->head
  while (p <> NIL)
    n += p->to - p->from + 1
    p = p->next
  wend
  return n

end function

function charset_first(byval charset as charset_ ptr) as integer
  
  if (charset->head <> NIL) then
    return charset->head->from
  end if
  return -1

end function

sub charset_or(byval charset as charset_ ptr,byval s as charset_ ptr)
  
  dim p as range_ ptr = s->head
  while (p <> NIL)
    for i as integer = p->from to p->to
      charset_set(charset,i)
    next i
    p = p->next
  wend

end sub

sub charset_and(byval charset as charset_ ptr,byval s as charset_ ptr)
  
  dim x as charset_ ptr = charset_create()
  dim p as range_ ptr = charset->head
  while (p <> NIL)
    for i as integer = p->from to p->to
      if (charset_get(s,i)) then
        charset_set(x,i)
      end if
    next i
    dim del as range_ ptr = p
    p = p->next
    range_destroy(del)
  wend
  charset->head = x->head
  x->head = NIL
  charset_destroy(x)

end sub

sub charset_subtract(byval charset as charset_ ptr,byval s as charset_ ptr)
  
  dim x as charset_ ptr = charset_create()
  dim p as range_ ptr = charset->head
  while (p <> NIL) 
    for i as integer = p->from to p->to    
      if (charset_get(s,i) = 0) then
        charset_set(x,i)
      end if
    next i
    dim del as range_ ptr = p
    p = p->next
    range_destroy(del)
  wend
  charset->head = x->head
  x->head = NIL
  ''AGS cannot destroy x as charset has taken over it's content
  deallocate(x)''charset_destroy(x)

end sub

function charset_includes(byval charset as charset_ ptr,byval s as charset_ ptr) as byte
  
  dim p as range_ ptr = s->head
  while (p <> NIL)
    for i as integer = p->from to p->to
      if (charset_get(charset,i) = 0) then
        return 0
      end if
    next i
    p = p->next
  wend
  return 1

end function

function charset_intersects(byval charset as charset_ ptr,byval s as charset_ ptr) as byte
  
  dim p as range_ ptr = s->head
  while (p <> NIL)
    for i as integer = p->from to p->to
      if (charset_get(charset,i)) then
        return 1
      end if
    next i
    p = p->next
  wend
  return 0

end function

sub charset_clear(byval charset as charset_ ptr)
  
  while (charset->head <> NIL)
    dim del as range_ ptr = charset->head
    charset->head = charset->head->next
    range_destroy(del)
  wend

end sub

sub charset_fill(byval charset as charset_ ptr)
  
  charset_clear(charset)
  charset->head = range_create(0, COCO_WCHAR_MAX)

end sub

sub charset_destroy(byref charset as charset_ ptr)
  
  charset_clear(charset)
  deallocate(charset)
  charset = NIL

end sub

function range_create(byval from_ as integer, byval to_ as integer) as range_ ptr

  dim range as range_ ptr
  range = callocate(1,sizeof(range_))
  range->from = from_
  range->to = to_
  range->next = NIL
  return range
  
end function

sub range_destroy(byref range as range_ ptr)

  if (range = NIL) then
    return
  end if
  deallocate(range)
  range = NIL

end sub

#ifndef COCO_CHARCLASS_H__
#define COCO_CHARCLASS_H__

'#include "CharSet.bi"

type charclass_

public:
  dim n as integer          '' class number
  dim name as wchar_t ptr   '' class name
  dim set as charset_ ptr    '' set representing the class

end type

declare function charclass_create(byval name_ as wchar_t ptr,byval s as charset_ ptr) as charclass_ ptr
declare sub charclass_destroy(byref charclass as charclass_ ptr)

#endif '' ifndef COCO_CHARCLASS_H__

'#include "CharClass.bi"
'#include "Scanner.bi"

function charclass_create(byval name_ as wchar_t ptr, byval s as charset_ ptr) as charclass_ ptr

  dim charclass as charclass_ ptr
  charclass = callocate(1,sizeof(charclass_))
  charclass->name = coco_string_create(name_)
  charclass->set = s
  return charclass

end function

sub charclass_destroy(byref charclass as charclass_ ptr)
  
  if (charclass = NIL) then
    return
  end if
  coco_string_destroy(charclass->name)
  deallocate(charclass)
  charclass = NIL

end sub

#ifndef COCO_STRINGBUILDER_H__
#define COCO_STRINGBUILDER_H__

#include once "crt/stddef.bi"

type stringbuilder_

public:
  dim data as wchar_t ptr
  dim capacity as integer
  dim length as integer

end type

declare function stringbuilder_create(byval capacity as integer = 32) as stringbuilder_ ptr
declare function stringbuilder_create_wchar(byval value as wchar_t ptr) as stringbuilder_ ptr
declare sub stringbuilder_destroy(byref stringbuilder as stringbuilder_ ptr)
declare sub stringbuilder_appendwc(byval stringbuilder as stringbuilder_ ptr, byval value as wchar_t)
declare sub stringbuilder_appendws(byval stringbuilder as stringbuilder_ ptr, byval value as wchar_t ptr)
declare function stringbuilder_tostring(byval stringbuilder as stringbuilder_ ptr) as wchar_t ptr
declare function stringbuilder_getlength(byval stringbuilder as stringbuilder_ ptr) as integer
declare sub stringbuilder_init(byval stringbuilder as stringbuilder_ ptr,byval capacity as integer)


#endif '' ifndef COCO_STRINGBUILDER_H__

#include "crt/string.bi"
'#include "StringBuilder.bi"
''#include "Scanner.bi"

sub stringbuilder_init(byval stringbuilder as stringbuilder_ ptr,byval capacity as integer)
  
  if (stringbuilder = NIL) then
    return
  end if
  stringbuilder->length = 0
  stringbuilder->capacity = capacity
  stringbuilder->data = callocate(capacity+1,sizeof(wchar_t))
  stringbuilder->data[0] = 0

end sub


function stringbuilder_create(byval capacity as integer = 32 ) as stringbuilder_ ptr

  dim stringbuilder as stringbuilder_ ptr
  stringbuilder = callocate(1,sizeof(stringbuilder_))
  stringbuilder_init(stringbuilder,capacity)
  return stringbuilder

end function

function stringbuilder_create_wchar(byval val_ as wchar_t ptr) as stringbuilder_ ptr
  
  dim stringbuilder as stringbuilder_ ptr
  stringbuilder = callocate(1,sizeof(stringbuilder_))
  stringbuilder->length = wcslen(val_)
  stringbuilder->capacity = stringbuilder->length
  stringbuilder_init(stringbuilder,stringbuilder->capacity)
  wcscpy(stringbuilder->data, val_)
  return stringbuilder
  
end function

sub stringbuilder_destroy(byref stringbuilder as stringbuilder_ ptr)
  
  if (stringbuilder = NIL) then
    return
  end if
  if (stringbuilder->data <> NIL) then
    deallocate(stringbuilder->data)
    stringbuilder->data = NIL
    stringbuilder->length = 0
    stringbuilder->capacity = 0
  end if
  deallocate(stringbuilder)
  stringbuilder = NIL

end sub


function stringbuilder_getlength(byval stringbuilder as stringbuilder_ ptr) as integer

  if (stringbuilder = NIL) then
    return -1
  end if
  return stringbuilder->length

end function


sub stringbuilder_appendwc(byval stringbuilder as stringbuilder_ ptr, byval value as wchar_t)
  
  if (stringbuilder->length = stringbuilder->capacity) then
    var oldcap = stringbuilder->capacity
    stringbuilder->capacity shl= 1
    dim ndata as wchar_t ptr = callocate(stringbuilder->capacity+1,sizeof(wchar_t))
    memcpy(ndata, stringbuilder->data, oldcap * sizeof(wchar_t))
    deallocate(stringbuilder->data)
    stringbuilder->data = ndata
  end if
  
  stringbuilder->data[stringbuilder->length] = value
  stringbuilder->length += 1
  stringbuilder->data[stringbuilder->length] = asc(!"\0")

end sub

''AGS C++ code failed when more space is needed in stringbuilder (to acccomodate for 
''appending value). Fixed it by using same approach as stringbuilder_appendwc
sub stringbuilder_appendws(byval stringbuilder as stringbuilder_ ptr, byval value as wchar_t ptr)
  
  if (stringbuilder = NIL) then
    return
  end if

  if (stringbuilder->length = stringbuilder->capacity) then
    var oldcap = stringbuilder->capacity
    stringbuilder->capacity += wcslen(value)
    dim ndata as wchar_t ptr = callocate(stringbuilder->capacity+1,sizeof(wchar_t))
    memcpy(ndata, stringbuilder->data, oldcap * sizeof(wchar_t))
    deallocate(stringbuilder->data)
    stringbuilder->data = ndata
  end if
  
  wcscpy(stringbuilder->data + stringbuilder->length, value)
  stringbuilder->length += wcslen(value)
  stringbuilder->data[stringbuilder->length] = asc(!"\0")

end sub


function stringbuilder_tostring(byval stringbuilder as stringbuilder_ ptr) as wchar_t ptr
  
  if (stringbuilder = NIL) then
    return NIL
  end if
  
  return coco_string_create(stringbuilder->data)

end function

#ifndef COCO_HASHTABLE_H__
#define COCO_HASHTABLE_H__

#include once "crt/wchar.bi"

type dictionaryentry_

public:
  dim key as wchar_t ptr
  dim value as any ptr

end type

'type iterator_

'public:
'  dim hasnext as function(byval iterator as iterator_ ptr) as byte
'  dim next as function(byval iterator as iterator_ ptr) as dictionaryentry_ ptr
'  'dummy is needed to keep fbc from reporting an 
'  'error ('empty structure')
'  dim dummy as ubyte
'
'end type

type obj_

public:
  dim dictionary_entry as dictionaryentry_
  dim next as obj_ ptr

end type

type hashtable_

public:
  dim data as obj_ ptr ptr
  dim size as integer

end type

type forward_iter_ as iter_

declare function hashtable_create(byval size as integer = 128) as hashtable_ ptr
declare sub hashtable_destroy(byref hashtable as hashtable_ ptr)
declare sub hashtable_set(byval hashtable as hashtable_ ptr,byval key as wchar_t ptr,byval value as any ptr)
declare function hashtable_get(byval hashtable as hashtable_ ptr, byval key as wchar_t ptr) as any ptr
declare function hashtable_itemat(byval hashtable as hashtable_ ptr, byval key as wchar_t ptr) as wchar_t ptr
declare function hashtable_getiterator(byval hashtable as hashtable_ ptr) as forward_iter_ ptr
declare function hashtable_get0(byval hashtable as hashtable_ ptr, byval key as wchar_t ptr) as obj_ ptr

type iter_

public:
  dim ht as hashtable_ ptr
  dim pos as integer
  dim cur as obj_ ptr

end type


declare function iter_hasnext(byval iter as iter_ ptr) as byte
declare function iter_next(byval iter as iter_ ptr) as dictionaryentry_ ptr
declare function iter_create(byval ht as hashtable_ ptr) as iter_ ptr
declare sub iter_destroy(byref iter as iter_ ptr)

#endif ''ifndef COCO_HASHTABLE_H__

#include once "crt/string.bi"
#include once "crt/stdio.bi"
''#include once "HashTable.bi"
''#include once "Scanner.bi"

function hashtable_create(byval size as integer = 128) as hashtable_ ptr
  
  dim hashtable as hashtable_ ptr
  hashtable = callocate(1,sizeof(hashtable_))
  
  hashtable->size = size
  hashtable->data = callocate(size,sizeof(obj_ ptr))
  memset(hashtable->data, 0, size * sizeof(obj_ ptr))
  return hashtable
  
end function


sub hashtable_destroy(byref hashtable as hashtable_ ptr)
  
  if (hashtable = NIL) then
    return
  end if
  
  for i as integer = 0 to hashtable->size - 1
    dim o as obj_ ptr = hashtable->data[i]
    while (o <> NIL)
      dim del as obj_ ptr = o
      o = o->next
      coco_string_destroy(del->dictionary_entry.key)
      deallocate(del)
    wend
  next i
  deallocate(hashtable->data)
  hashtable->data = NIL

end sub

function hashtable_get0(byval hashtable as hashtable_ ptr, byval key as wchar_t ptr) as obj_ ptr
  
  dim k as integer = coco_string_hash(key) mod hashtable->size
  dim o as obj_ ptr = hashtable->data[k]
  while (o <> NIL andalso 0=coco_string_equal(key, o->dictionary_entry.key)) 
    o = o->next
  wend
  return o

end function

sub hashtable_set(byval hashtable as hashtable_ ptr,byval key as wchar_t ptr,byval value as any ptr)
  
  dim o as obj_ ptr = hashtable_get0(hashtable,key)
  if (o = NIL) then
    '' new entry
    dim k as integer = coco_string_hash(key) mod hashtable->size
    o = callocate(1,sizeof(obj_))
    o->dictionary_entry.key = key
    o->dictionary_entry.value = value
    o->next = hashtable->data[k]
    hashtable->data[k] = o
  else 
    '' exist entry - overwrite
    o->dictionary_entry.value = value
  end if

end sub

function hashtable_get(byval hashtable as hashtable_ ptr, byval key as wchar_t ptr) as any ptr
  
  dim o as obj_ ptr = hashtable_get0(hashtable,key)
  if (o <> NIL) then
    return o->dictionary_entry.value
  end if
  return NIL

end function

function hashtable_getiterator(byval hashtable as hashtable_ ptr) as iter_ ptr
  
  return iter_create(hashtable)

end function

function iter_create(byval ht as hashtable_ ptr) as iter_ ptr
  
  dim iter as iter_ ptr
  iter = callocate(1,sizeof(iter_))
  iter->ht = ht
  iter->pos = 0
  iter->cur = NIL
  return iter
  
end function

function iter_hasnext(byval iter as iter_ ptr) as byte
  
  while (iter->cur = NIL andalso iter->pos < iter->ht->size)
    iter->cur = iter->ht->data[pos]
    iter->pos += 1
  wend
  return iter->cur <> NIL

end function

function iter_next(byval iter as iter_ ptr) as dictionaryentry_ ptr
  
  if (iter_hasnext(iter) = 0) then
    return NIL
  end if
  dim next_ as obj_ ptr = iter->cur
  iter->cur = iter->cur->next
  return @(next_->dictionary_entry)

end function

function hashtable_itemat(byval hashtable as hashtable_ ptr, byval key as wchar_t ptr) as wchar_t ptr
 
  return hashtable_get(hashtable,key)

end function

#ifndef COCO_SCANNER_H__
#define COCO_SCANNER_H__

''coco_create can be found at start of file (other modules depended upon it)
#include once "crt/limits.bi"
#include once "crt/stdio.bi"
#include once "crt/stdlib.bi"
#include once "crt/string.bi"
#include once "crt/wchar.bi"

type token_

public:
  dim kind as integer     '' token kind
  dim pos as integer      '' token position in bytes in the source text (starting at 0)
  dim charpos as integer  '' token position in characters in the source text (starting at 0)
  dim col as integer      '' token column (starting at 1)
  dim line as integer     '' token line (starting at 1)
  dim val as wchar_t ptr  '' token value
  dim next as token_ ptr  '' ML 2005-03-11 Peek tokens are kept in linked list

end type

declare function token_create() as token_ ptr
declare sub token_destroy(byref token as token_ ptr)


type buffer_
'' This Buffer supports the following cases:
'' 1) seekable stream (file)
''    a) whole stream in buffer
''    b) part of stream in buffer
'' 2) non seekable stream (network, console)
public:
  dim buf as ubyte ptr '' input buffer
  dim bufcapacity as integer   '' capacity of buf
  dim bufstart as integer       '' position of first byte in buffer relative to input stream
  dim buflen as integer         '' length of buffer
  dim filelen as integer        '' length of input stream (may change if the stream is no file)
  dim bufpos as integer         '' current position in buffer
  dim stream as FILE ptr       '' input stream (seekable)
  dim isuserstream as byte  '' was the stream opened by the user?
  
  'function pointers
  dim close_ as sub(byval buffer as buffer_ ptr)
  dim read_ as function(byval buffer as buffer_ ptr) as integer
  dim peek_ as function(byval buffer as buffer_ ptr) as integer
  dim getstring_ as function(byval buffer as buffer_ ptr, byval beg as integer, byval end_ as integer) as wchar_t ptr
  dim getpos_ as function(byval buffer as buffer_ ptr) as integer
  dim setpos_ as sub (byval buffer as buffer_ ptr, byval value as integer)
  
  enum
    _EoF = COCO_WCHAR_MAX + 1
  end enum

end type

declare function buffer_create_file(byval s as FILE ptr, byval isUserStream as byte) as buffer_ ptr
declare function buffer_create_array(byval buf as ubyte ptr, byval len_ as integer) as buffer_ ptr
declare function buffer_create_buffer(byval b as buffer_ ptr) as buffer_ ptr
declare sub buffer_destroy(byref buffer as buffer_ ptr)
declare function buffer_readnextstreamchunk(byval buffer as buffer_ ptr) as integer
declare function buffer_canseek(byval buffer as buffer_ ptr) as byte     '' true if stream can be seeked otherwise false


type utf8buffer_

public:
  dim buffer as buffer_ ptr
  'function pointers
  dim close_ as sub(byval buffer as buffer_ ptr)
  dim read_ as function(byval utf8buffer as utf8buffer_ ptr) as integer
  dim peek_ as function(byval buffer as buffer_ ptr) as integer
  dim getstring_ as function(byval buffer as buffer_ ptr, byval beg as integer, byval end_ as integer) as wchar_t ptr
  dim getpos_ as function(byval buffer as buffer_ ptr) as integer
  dim setpos_ as sub (byval buffer as buffer_ ptr, byval value as integer)  

end type

declare function utf8buffer_create(byval b as buffer_ ptr) as utf8buffer_ ptr
declare sub utf8buffer_destroy(byref utf8buffer as utf8buffer_ ptr)

''-----------------------------------------------------------------------------------
'' StartStates  -- maps characters to start states of tokens
''-----------------------------------------------------------------------------------
type elem_

  public:
    dim val as integer
    dim key as integer
    dim next as elem_ ptr

end type

declare function elem_create(byval key as integer, byval val_ as integer) as elem_ ptr
declare sub elem_destroy(byref elem as elem_ ptr)

type startstates_

public:
  dim tab as elem_ ptr ptr

end type

declare function startstates_create() as startstates_ ptr
declare sub startstates_destroy(byref startstates as startstates_ ptr)
declare sub startstates_set(byval startstates as startstates_ ptr,byval key as integer, byval val_ as integer)
declare function startstates_state(byval startstates as startstates_ ptr, byval key as integer) as integer


''-------------------------------------------------------------------------------------------
'' KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
''-------------------------------------------------------------------------------------------
type keywordmap_elem_

  public:
    dim key as wchar_t ptr
    dim val as integer
    dim next as keywordmap_elem_ ptr

end type

declare function keywordmap_elem_create(byval key as wchar_t ptr, byval val_ as integer) as keywordmap_elem_ ptr
declare sub keywordmap_elem_destroy(byref keywordmap_elem as keywordmap_elem_ ptr)
  

type keywordmap_

public:
  dim tab as keywordmap_elem_ ptr ptr

end type

declare function keywordmap_create() as keywordmap_ ptr
declare sub keywordmap_destroy(byref keywordmap as keywordmap_ ptr)
declare sub keywordmap_set(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval val_ as integer)
declare function keywordmap_get(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval defaultval as integer) as integer


type scanner_

public:

  dim firstheap as any ptr
  dim heap as any ptr
  dim heaptop as any ptr
  dim heapend as any ptr ptr

  dim eol as ubyte
  dim eofsym as integer
  dim nosym as integer
  dim maxt as integer
  dim charsetsize as integer
  dim start as startstates_ ptr
  dim keywords as keywordmap_ ptr

  dim t as token_ ptr         '' current token
  dim tval as wchar_t ptr     '' text of current token
  dim tvallength as integer   '' length of text of current token
  dim tlen as integer         '' length of current token

  dim tokens as token_ ptr    '' list of tokens already peeked (first token is a dummy)
  dim pt as token_ ptr        '' current peek token

  dim ch as integer           '' current input character

  dim pos as integer          '' byte position of current character
  dim charpos as integer      '' position by unicode characters starting with 0
  dim line as integer         '' line number of current character
  dim col as integer          '' column number of current character
  dim oldeols as integer      '' eols that appeared in a comment;

  dim buffer_typ as integer   '' 0 (ansi) or 1 (utf8)
  
  buffer as buffer_ ptr           '' scanner buffer, ansi 
  utf8buffer as utf8buffer_ ptr   '' scanner buffer, utf8
  
end type

declare sub scanner_createheapblock(byval scanner as scanner_ ptr)
declare function scanner_createtoken(byval scanner as scanner_ ptr) as token_ ptr
declare sub scanner_destroytoken(byref token as token_ ptr)
declare sub scanner_appendval(byval scanner as scanner_ ptr,byval t as token_ ptr)
declare sub scanner_setscannerbehindt(byval scanner as scanner_ ptr)
declare sub scanner_init(byval scanner as scanner_ ptr)
declare sub scanner_nextch(byval scanner as scanner_ ptr)
declare sub scanner_addch(byval scanner as scanner_ ptr)
declare function scanner_comment0(byval scanner as scanner_ ptr) as byte
declare function scanner_comment1(byval scanner as scanner_ ptr) as byte
declare function scanner_nexttoken(byval scanner as scanner_ ptr) as token_ ptr
declare function scanner_create_buffer(byval buf as ubyte ptr, byval len_ as integer) as scanner_ ptr
declare function scanner_create_wfile(byval filename as wchar_t ptr) as scanner_ ptr
declare function scanner_create_file(byval s as FILE ptr) as scanner_ ptr
declare sub scanner_destroy(byref scanner as scanner_ ptr)
declare function scanner_scan(byval scanner as scanner_ ptr) as token_ ptr
declare function scanner_peek(byval scanner as scanner_ ptr) as token_ ptr
declare sub scanner_resetpeek(byval scanner as scanner_ ptr)

#endif '' ifndef COCO_SCANNER_H__

#include once "crt/string.bi"
'#include once "Scanner.bi"


'' string handling, wide character
function coco_string_create(byval value as wchar_t ptr) as wchar_t ptr
  
  return coco_string_create_i(value, 0)

end function

function coco_string_create_i(byval value as wchar_t ptr, byval startindex as integer) as wchar_t ptr
  
  var valuelen = 0
  var len_ = 0

  if (value) then
    valuelen = wcslen(value)
    len_ = valueLen - startindex
  end if

  return coco_string_create_il(value, startindex, len_)

end function

function coco_string_create_il(byval value as wchar_t ptr, byval startindex as integer, byval length as integer) as wchar_t ptr
  
  var len_ = 0
  dim data_ as wchar_t ptr

  if (value) then
    len_ = length
  end if
  data_ = callocate(length + 1,sizeof(wchar_t))
  wcsncpy(data_, @(value[startindex]), len_)
  data_[len_] = 0

  return data_

end function

function coco_string_create_upper(byval data_ as wchar_t ptr) as wchar_t ptr
  
  if (data_ = 0) then
    return NIL
  end if

  dim datalen as integer
  if (data_) then
    dataLen = wcslen(data_)
  end if

  dim newdata as wchar_t ptr
  newdata = callocate(datalen + 1,sizeof(wchar_t))

  for i as integer = 0 to datalen
    if ((asc("a") <= data_[i]) andalso (data_[i] <= asc("z"))) then
      newdata[i] = data_[i] + (asc("A") - asc("a"))
    else 
      newdata[i] = data_[i]
    end if
  next i

  newdata[datalen] = 0
  return newdata

end function

function coco_string_create_lower(byval data_ as wchar_t ptr) as wchar_t ptr
  
  if (data_ = NIL) then
    return NIL
  end if
  var dataLen = wcslen(data_)
  return coco_string_create_lower_il(data_, 0, datalen)

end function

function coco_string_create_lower_il(byval data_ as wchar_t ptr, byval startindex as integer, byval datalen as integer) as wchar_t ptr
  
  if (data_ = 0) then
    return NIL
  end if

  dim newdata as wchar_t ptr = callocate(datalen + 1,sizeof(wchar_t))

  for i as integer = 0 to datalen
    dim ch as wchar_t = data_[startindex + i]
    if ((asc("A") <= ch) andalso (ch <= asc("Z"))) then
      newdata[i] = ch - (asc("A") - asc("a"))
    else 
      newdata[i] = ch
    end if
  next i
  newdata[datalen] = asc(!"\0")
  return newdata

end function

function coco_string_create_appendws(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as wchar_t ptr
  
  dim data_ as wchar_t ptr
  var data1len = 0
  var data2len = 0

  if (data1) then
    data1len = wcslen(data1)
  end if
  
  if (data2) then
    data2len = wcslen(data2)
  end if

  data_ = callocate(data1len + data2len + 1,sizeof(wchar_t))

  if (data1) then
    wcsncpy(data_, data1,data1len)
  end if
  
  if (data2) then
    wcsncpy(data_ + data1len, data2,data2len)
  end if

  data_[data1len + data2len] = 0

  return data_

end function

function coco_string_create_appendwc(byval target as wchar_t ptr, byval appendix as wchar_t) as wchar_t ptr
  
  var targetlen = coco_string_length(target)
  dim data_ as wchar_t ptr = callocate(targetlen + 2,sizeof(wchar_t))
  wcsncpy(data_, target, targetlen)
  data_[targetlen] = appendix
  data_[targetlen + 1] = 0
  return data_

end function

sub coco_string_destroy(byref data_ as wchar_t ptr)
  
  if (data_ <> NIL) then
    deallocate(data_)
  end if
  data_ = NIL
  
end sub

function coco_string_length(byval data_ as wchar_t ptr) as integer
  
  if (data_) then
    return wcslen(data_)
  end if
  return 0

end function

function coco_string_endswith(byval data_ as wchar_t ptr, byval end_ as wchar_t ptr) as byte

  var datalen = wcslen(data_)
  var endlen = wcslen(end_)
  return (endlen <= datalen) andalso (wcscmp(data_ + datalen - endlen, end_) = 0)

end function

function coco_string_indexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
  
  dim chr_ as wchar_t ptr = wcschr(data_, value)

  if (chr_) then
    return (chr_- data_)
  end if
  return -1

end function

function coco_string_lastindexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
  
  dim chr_ as wchar_t ptr = wcsrchr(data_, value)

  if (chr_) then
    return (chr_-data_)
  end if
  return -1

end function

sub coco_string_merge(byref target as wchar_t ptr, byval appendix as wchar_t ptr)

  if (appendix = NIL) then
    return
  end if
  
  dim data_ as wchar_t ptr = coco_string_create_appendws(target, appendix)
  deallocate(target)
  target = data_

end sub

function coco_string_equal(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as byte

  return wcscmp( data1, data2 ) = 0

end function

function coco_string_compareto(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as integer

  return wcscmp(data1, data2)

end function

function coco_string_hash(byval data_ as wchar_t ptr) as integer
  
  var h = 0
  if (data_ = NIL) then
    return 0
  end if
  
  while (*data_ <> 0) 
    h = (h * 7) xor *data_
    data_ += 1
  wend
  if (h < 0) then
    h = -h
  end if
  return h

end function

'' string handling, ascii character

function coco_string_create_zstr(byval value as zstring ptr) as wchar_t ptr
  
  var len_ = 0
  if (value) then
    len_ = strlen(value)
  end if
  dim data_ as wchar_t ptr = callocate(len_ + 1,sizeof(wchar_t))
  for i as integer = 0 to len_ - 1
    data_[i] = cast(wchar_t,value[0][i])
  next i
  data_[len_] = 0
  return data_
  
end function

function coco_string_create_char(byval value as wchar_t ptr) as zstring ptr
  
  var len_ = coco_string_length(value)
  dim res as zstring ptr
  res = callocate(len_ + 1,sizeof(ubyte))
  for i as integer = 0 to len_ - 1
    res[0][i] = cast(ubyte,value[i])
  next i  
  res[0][len_] = 0
  return res
  
end function

sub coco_string_destroy_zstr(byref data_ as zstring ptr)
  
  if (data_ <> NIL) then
    deallocate(data_)
    data_ = NIL
  end if

end sub

sub keywordmap_set(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval val_ as integer)

  dim e as keywordmap_elem_ ptr = keywordmap_elem_create(key,val_)
  'change 128 to a larger value if the language you are implementing has lots of keywords
  '128 assumes there are 64 or less keywords (size of table = 2 * number of keywords). 
  'formula: var k = coco_string_hash(key) mod number_of_keywords * 2
  var k = coco_string_hash(key) mod 128
  e->next = keywordmap->tab[k]
  keywordmap->tab[k] = e

end sub

function keywordmap_get(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval defaultval as integer) as integer

  dim e as keywordmap_elem_ ptr = keywordmap->tab[coco_string_hash(key) mod 128]
  while (e <> NIL andalso 0 = coco_string_equal(e->key, key)) 
    e = e->next
  wend
  if (e = NIL) then
    return defaultval
  else
    return e->val
  end if

end function


function token_create() as token_ ptr
  
  dim token as token_ ptr
  token = callocate(1,sizeof(token_))
  token->kind = 0
  token->pos  = 0
  token->col  = 0
  token->line = 0
  token->val  = NIL
  token->next = NIL
  return token
  
end function

sub token_destroy(byref token as token_ ptr)
  
  if (token = NIL) then
    return
  end if
 
  if (token->val <> NIL) then
    coco_string_destroy(token->val)
  end if
  
  deallocate(token)
  token = NIL
  
end sub

sub buffer_close_imp(byval buffer as buffer_ ptr)
  
  if (buffer->isuserstream = 0 andalso buffer->stream <> NIL) then
    fclose(buffer->stream)
    ''AGS buffer->stream = NIL
  end if
  
end sub

function buffer_read_imp(byval buffer as buffer_ ptr) as integer
  
  if (buffer->bufpos < buffer->buflen) then
    buffer->bufpos += 1
    return buffer->buf[buffer->bufpos-1]
  elseif (buffer->getpos_(buffer) < buffer->filelen) then
    buffer->setpos_(buffer,buffer->getpos_(buffer)) '' shift buffer start to Pos
    buffer->bufpos += 1
    return buffer->buf[buffer->bufpos-1]
  elseif ((buffer->stream <> NIL) andalso buffer_canseek(buffer) = 0 andalso (buffer_readnextstreamchunk(buffer) > 0)) then
    buffer->bufpos += 1
    return buffer->buf[buffer->bufpos-1]
  else
    return buffer_._EoF
  end if

end function

function buffer_peek_imp(byval buffer as buffer_ ptr) as integer
  
  var curpos = buffer->getpos_(buffer)
  var ch = buffer->read_(buffer)
  buffer->setpos_(buffer,curpos)
  return ch

end function

'' beg .. begin, zero-based, inclusive, in byte
'' end .. end, zero-based, exclusive, in byte
function buffer_getstring_imp(byval buffer as buffer_ ptr,byval beg as integer,byval end_ as integer) as wchar_t ptr

  var len_ = 0
  dim buf as wchar_t ptr = callocate(end_ - beg,sizeof(wchar_t))
  var oldpos = buffer->getpos_(buffer)
  buffer->setpos_(buffer,beg)
  while (buffer->getpos_(buffer) < end_) 
    buf[len_] = cast(wchar_t, buffer->read_(buffer)):len_ += 1
  wend
  buffer->setpos_(buffer,oldpos)
  var res = coco_string_create_il(buf, 0, len_)
  coco_string_destroy(buf)
  return res

end function


function buffer_getpos_imp(byval buffer as buffer_ ptr) as integer
  
  return buffer->bufpos + buffer->bufstart

end function

sub buffer_setpos_imp(byval buffer as buffer_ ptr, byval value as integer)

  if ((value >= buffer->filelen) andalso (buffer->stream <> NIL) andalso buffer_canseek(buffer) = 0) then
    '' Wanted position is after buffer and the stream
    '' is not seek-able e.g. network or console,
    '' thus we have to read the stream manually till
    '' the wanted position is in sight.
    while ((value >= buffer->filelen) andalso (buffer_readnextstreamchunk(buffer) > 0))
    wend
  end if

  if ((value < 0) orelse (value > buffer->filelen)) then
    wprintf(@wstr(!"--- buffer out of bounds access, position: %d\n"), value)
    exit_(1)
  end if

  if ((value >= buffer->bufstart) andalso (value < (buffer->bufstart + buffer->buflen))) then '' already in buffer
    buffer->bufpos = value - buffer->bufstart
  elseif (buffer->stream <> NIL) then '' must be swapped in
    fseek(buffer->stream, value, SEEK_SET)
    buffer->buflen = fread(buffer->buf, sizeof(ubyte), buffer->bufcapacity, buffer->stream)
    buffer->bufstart = value:buffer->bufpos = 0
  else
    buffer->bufpos = buffer->fileLen - buffer->bufstart '' make Pos return fileLen
  end if

end sub

function buffer_create_file(byval s as FILE ptr, byval isuserstream as byte) as buffer_ ptr

  dim buffer as buffer_ ptr
  buffer = callocate(1,sizeof(buffer_))
'' ensure binary read on windows
  _setmode(_fileno(s), _O_BINARY)
  buffer->stream = s
  buffer->isuserstream = isuserstream
  if (buffer_canseek(buffer)) then
    fseek(s, 0, SEEK_END)
    buffer->filelen = ftell(s)
    fseek(s, 0, SEEK_SET)
    buffer->buflen = iif(buffer->filelen < MAX_BUFFER_LENGTH,buffer->filelen, MAX_BUFFER_LENGTH)
    buffer->bufstart = INT_MAX '' nothing in the buffer so far
  else 
    buffer->bufstart = 0 
    buffer->buflen = 0
    buffer->filelen =  0
  end if
  buffer->read_ = @buffer_read_imp
  buffer->close_ = @buffer_close_imp
  buffer->peek_ = @buffer_peek_imp
  buffer->getstring_ = @buffer_getstring_imp
  buffer->getpos_ = @buffer_getpos_imp
  buffer->setpos_ = @buffer_setpos_imp  
  buffer->bufcapacity = iif(buffer->buflen > 0, buffer->buflen,MIN_BUFFER_LENGTH)
  buffer->buf = callocate(buffer->bufcapacity,sizeof(ubyte))
  if (buffer->filelen > 0) then
    buffer->setpos_(buffer,0)          '' setup  buffer to position 0 (start)
  else 
    buffer->bufpos = 0 '' index 0 is already after the file, thus Pos = 0 is invalid
  end if
  if (buffer->buflen = buffer->filelen andalso buffer_canseek(buffer)) then
    buffer->close_(buffer)
  end if
  return buffer
  
end function

function buffer_create_buffer(byval b as buffer_ ptr) as buffer_ ptr

  dim buffer as buffer_ ptr
  buffer = callocate(1,sizeof(buffer_))

  buffer->buf = b->buf
  buffer->bufcapacity = b->bufcapacity
  b->buf = NIL
  buffer->bufstart = b->bufstart
  buffer->bufLen = b->buflen
  buffer->fileLen = b->filelen
  buffer->bufpos = b->bufpos
  buffer->stream = b->stream
  b->stream = NIL
  buffer->isuserstream = b->isuserstream
  'set function pointers
  buffer->read_ = b->read_
  buffer->close_ = b->close_
  buffer->peek_ = b->peek_
  buffer->getpos_ = b->getpos_
  buffer->setpos_ = b->setpos_
  return buffer
  
end function

function buffer_create_array(byval buf as ubyte ptr, byval len_ as integer) as buffer_ ptr

  dim buffer as buffer_ ptr
  buffer = callocate(1,sizeof(buffer_))
  
  buffer->buf = callocate(len_,sizeof(ubyte))
  memcpy(buffer->buf, buf, len_*sizeof(ubyte))
  buffer->bufstart = 0
  buffer->buflen = len_
  buffer->bufcapacity = len_
  buffer->fileLen = len_
  buffer->bufpos = 0
  buffer->stream = NIL
  'set function pointers
  buffer->close_ = @buffer_close_imp
  buffer->read_ = @buffer_read_imp
  buffer->peek_ = @buffer_peek_imp
  buffer->getstring_ = @buffer_getstring_imp
  buffer->getpos_ = @buffer_getpos_imp
  buffer->setpos_ = @buffer_setpos_imp  
  return buffer
  
end function

sub buffer_destroy(byref buffer as buffer_ ptr)
  
  if (buffer = NIL) then
    return
  end if
  
  buffer->close_(buffer)
  if (buffer->buf <> NIL) then
    deallocate(buffer->buf)
    buffer->buf = NIL
  end if
  buffer = NIL
  
end sub

function utf8buffer_read_imp(byval utf8buffer as utf8buffer_ ptr) as integer
  
  dim ch as integer
  do 
    ch = utf8buffer->buffer->read_(utf8buffer->buffer)
    '' until we find a utf8 start (0xxxxxxx or 11xxxxxx)
  loop while ((ch >= 128) andalso ((ch and &hC0) <> &hC0) andalso (ch <> buffer_._EoF))
  if (ch < 128 orelse ch = buffer_._EoF) then 
    '' nothing to do, first 127 chars are the same in ascii and utf8
    '' &hxxxxxx or end of file character
  elseif ((ch and &hF0) = &hF0) then
    '' 1111&hxx 1&hxxxxx 1&hxxxxx 1&hxxxxx
    var c1 = ch and &h07: ch = utf8buffer->buffer->read_(utf8buffer->buffer)
    var c2 = ch and &h3F: ch = utf8buffer->buffer->read_(utf8buffer->buffer)
    var c3 = ch and &h3F: ch = utf8buffer->buffer->read_(utf8buffer->buffer)
    var c4 = ch and &h3F
    ch = (((((c1 shl 6) or c2) shl 6) or c3) shl 6) or c4
  elseif ((ch and &hE0) = &hE0) then
    '' 111&hxxx 1&hxxxxx 1&hxxxxx
    var c1 = ch and &h0F:ch = utf8buffer->buffer->read_(utf8buffer->buffer)
    var c2 = ch and &h3F:ch = utf8buffer->buffer->read_(utf8buffer->buffer)
    var c3 = ch and &h3F
    ch = (((c1 shl 6) or c2) shl 6) or c3
  elseif ((ch and &hC0) = &hC0) then
    '' 11&hxxxx 1&hxxxxx
    var c1 = ch and &h1F:ch = utf8buffer->buffer->read_(utf8buffer->buffer)
    var c2 = ch and &h3F
    ch = (c1 shl 6) or c2
  end if
  return ch

end function

'' Read the next chunk of bytes from the stream, increases the buffer
'' if needed and updates the fields fileLen and bufLen.
'' Returns the number of bytes read.
function buffer_readnextstreamchunk(byval buffer as buffer_ ptr) as integer
  
  dim free_ as integer = buffer->bufcapacity - buffer->buflen
  if (free_ = 0) then
    '' in the case of a growing input stream
    '' we can neither seek in the stream, nor can we
    '' foresee the maximum length, thus we must adapt
    '' the buffer size on demand.
    buffer->bufcapacity = buffer->buflen * 2
    var newbuf = cast(ubyte ptr,callocate(buffer->bufcapacity,sizeof(ubyte)))
    memcpy(newbuf, buffer->buf, buffer->buflen*sizeof(ubyte))
    deallocate(buffer->buf)
    buffer->buf = newbuf
    free_ = buffer->buflen
  end if
  var read_ = fread(buffer->buf + buffer->buflen, sizeof(ubyte), free_, buffer->stream)
  if (read_ > 0) then
    buffer->buflen = buffer->buflen + read_
    buffer->filelen = buffer->buflen
    return read_
  end if
  '' end of stream reached
  return 0

end function

function buffer_canseek(byval buffer as buffer_ ptr) as byte
  
  return (buffer->stream <> NIL) andalso (ftell(buffer->stream) <> -1)

end function

function utf8buffer_create(byval b as buffer_ ptr) as utf8buffer_ ptr

  dim utf8buffer as utf8buffer_ ptr
  utf8buffer = callocate(1,sizeof(utf8buffer_))
  utf8buffer->read_ = @utf8buffer_read_imp
  'set function pointers
  utf8buffer->close_ = b->close_
  utf8buffer->peek_ = b->peek_
  utf8buffer->getstring_ = b->getstring_
  utf8buffer->getpos_ = b->getpos_
  utf8buffer->setpos_ = b->setpos_
  utf8buffer->buffer = b
  
  return utf8buffer

end function
 
sub utf8buffer_destroy(byref utf8buffer as utf8buffer_ ptr)

  if (utf8buffer = NIL) then
    return
  end if
  
  if (utf8buffer->buffer <> NIL) then
    buffer_destroy(utf8buffer->buffer)
  end if
  deallocate(utf8buffer)
  utf8buffer = NIL

end sub

function scanner_create_buffer(byval buf as ubyte ptr, byval len_ as integer) as scanner_ ptr
  
  dim scanner as scanner_ ptr
  scanner = callocate(1,sizeof(scanner_))
  scanner->buffer = buffer_create_array(buf, len_)
  scanner_init(scanner)
  return scanner
  
end function

function scanner_create_wfile(byval filename as wchar_t ptr) as scanner_ ptr
  
  dim stream as FILE ptr
  dim scanner as scanner_ ptr
  scanner = callocate(1,sizeof(scanner_))
  dim chfilename as zstring ptr = coco_string_create_char(filename)
  stream = fopen(chfilename, "rb")
  if (stream= NIL) then
    wprintf(@wstr(!"--- Cannot open file %ls\n"), filename)
    exit_(1)
  end if
  coco_string_destroy_zstr(cast(zstring ptr,chfilename))
  scanner->buffer = buffer_create_file(stream, 0)
  scanner_init(scanner)
  return scanner
  
end function

function scanner_create_file(byval s as FILE ptr) as scanner_ ptr
  
  dim scanner as scanner_ ptr
  scanner = callocate(1,sizeof(scanner_))
  scanner->buffer = buffer_create_file(s, 1)
  scanner_init(scanner)
  return scanner
  
end function

sub scanner_destroy(byref scanner as scanner_ ptr)
  
  dim cur as ubyte ptr = cast(ubyte ptr,scanner->firstheap)

  while(cur <> NIL) 
    cur = *(cast(ubyte ptr ptr,cur + HEAP_BLOCK_SIZE))
    deallocate(scanner->firstheap)
    scanner->firstheap = cur
  wend
  deallocate(scanner->tval)
  scanner->tval = NIL
  buffer_destroy(scanner->buffer)
  deallocate(scanner->buffer)
  utf8buffer_destroy(scanner->utf8buffer)  


end sub

function startstates_create() as startstates_ ptr

  dim startstates as startstates_ ptr
  startstates = callocate(1,sizeof(startstates_))  
  startstates->tab = callocate(128,sizeof(elem_ ptr))
  'AGS memset(startstates->tab,0,128 * sizeof(elem_ ptr))
  return startstates
  
end function

sub startstates_destroy(byref startstates as startstates_ ptr)
  
  for i as integer = 0 to 127
    dim e as elem_ ptr = startstates->tab[i]
    while (e <> NIL) 
      var next_ = e->next
      deallocate(e)
      e = NIL
      e = next_
    wend
  next i
  deallocate(startstates)

end sub

function elem_create(byval key as integer, byval val_ as integer) as elem_ ptr

  dim elem as elem_ ptr
  elem = callocate(1,sizeof(elem_))
  elem->key = key
  elem->val = val_
  elem->next = NIL
  return elem
  
end function

''STUB
sub elem_destroy(byref elem as elem_ ptr)

  if (elem <> NIL) then
    deallocate(elem)
    elem = NIL
  end if  

end sub

sub startstates_set(byval startstates as startstates_ ptr,byval key as integer, byval val_ as integer)

  dim e as elem_ ptr = elem_create(key, val_)
  dim k as integer = (cast(uinteger,key) mod 128)
  e->next = startstates->tab[k]
  startstates->tab[k] = e
end sub

function startstates_state(byval startstates as startstates_ ptr, byval key as integer) as integer

  dim e as elem_ ptr = startstates->tab[(cast(uinteger,key)) mod 128]
  while (e <> NIL andalso e->key <> key) 
    e = e->next
  wend
  if (e = NIL) then
    return 0
  else
    return e->val
  end if

end function
  
function keywordmap_create() as keywordmap_ ptr

  dim keywordmap as keywordmap_ ptr
  keywordmap = callocate(1,sizeof(keywordmap_))
  keywordmap->tab = callocate(128,sizeof(keywordmap_elem_ ptr))
  'AGS memset(keywordmap->tab, 0, 128 * sizeof(keywordmap_elem_ ptr))
  return keywordmap
  
end function
  
sub keywordmap_destroy(byref keywordmap as keywordmap_ ptr)

  for i as integer = 0 to 128 - 1
    dim e as keywordmap_elem_ ptr = keywordmap->tab[i]
    while (e <> NIL)
      dim nxt as keywordmap_elem_ ptr = e->next
      keywordmap_elem_destroy(e)
      deallocate(e)
      e = nxt
    wend
  next i  
  deallocate(keywordmap)

end sub

function keywordmap_elem_create(byval key as wchar_t ptr, byval val_ as integer) as keywordmap_elem_ ptr
  
  dim map as keywordmap_elem_ ptr
  map = callocate(1,sizeof(keywordmap_elem_))
  map->key = coco_string_create(key)
  map->val = val_
  map->next = NIL
  return map

end function

sub keywordmap_elem_destroy(byref keywordmap_elem as keywordmap_elem_ ptr)
    
  if (keywordmap_elem <> NIL) then
    coco_string_destroy(keywordmap_elem->key)
    deallocate(keywordmap_elem)
    keywordmap_elem = NIL
  end if
  
end sub

sub scanner_init(byval scanner as scanner_ ptr)
''FIXME checking for UTF8 BOM at start of buffer (or start of file)
''should be optional. BOM is not always there and when user is sure
''the content is UTF8 then it should be possible to have UTF8 scanning
''without a BOM.
  scanner->eol    = asc(!"\n")
  scanner->eofsym = 0
  scanner->maxt = 41
  scanner->nosym = 41
  scanner->start = startstates_create()
  scanner->keywords = keywordmap_create()
  dim i as integer
  for i = 65 to 90
    startstates_set(scanner->start,i, 1)
  next i
  for i = 95 to 95
    startstates_set(scanner->start,i, 1)
  next i
  for i = 97 to 122
    startstates_set(scanner->start,i, 1)
  next i
  for i = 48 to 57
    startstates_set(scanner->start,i, 1)
  next i
  startstates_set(scanner->start,34, 12)
  startstates_set(scanner->start,39, 5)
  startstates_set(scanner->start,36, 13)
  startstates_set(scanner->start,61, 16)
  startstates_set(scanner->start,46, 31)
  startstates_set(scanner->start,43, 17)
  startstates_set(scanner->start,45, 18)
  startstates_set(scanner->start,60, 32)
  startstates_set(scanner->start,62, 20)
  startstates_set(scanner->start,124, 23)
  startstates_set(scanner->start,40, 33)
  startstates_set(scanner->start,41, 24)
  startstates_set(scanner->start,91, 25)
  startstates_set(scanner->start,93, 26)
  startstates_set(scanner->start,123, 27)
  startstates_set(scanner->start,125, 28)
  startstates_set(scanner->start,buffer_._EoF, -1)
  keywordmap_set(scanner->keywords,@wstr(!"COMPILER"), 6)
  keywordmap_set(scanner->keywords,@wstr(!"IGNORECASE"), 7)
  keywordmap_set(scanner->keywords,@wstr(!"CHARACTERS"), 8)
  keywordmap_set(scanner->keywords,@wstr(!"TOKENS"), 9)
  keywordmap_set(scanner->keywords,@wstr(!"PRAGMAS"), 10)
  keywordmap_set(scanner->keywords,@wstr(!"COMMENTS"), 11)
  keywordmap_set(scanner->keywords,@wstr(!"FROM"), 12)
  keywordmap_set(scanner->keywords,@wstr(!"TO"), 13)
  keywordmap_set(scanner->keywords,@wstr(!"NESTED"), 14)
  keywordmap_set(scanner->keywords,@wstr(!"IGNORE"), 15)
  keywordmap_set(scanner->keywords,@wstr(!"PRODUCTIONS"), 16)
  keywordmap_set(scanner->keywords,@wstr(!"END"), 19)
  keywordmap_set(scanner->keywords,@wstr(!"ANY"), 23)
  keywordmap_set(scanner->keywords,@wstr(!"WEAK"), 29)
  keywordmap_set(scanner->keywords,@wstr(!"SYNC"), 36)
  keywordmap_set(scanner->keywords,@wstr(!"IF"), 37)
  keywordmap_set(scanner->keywords,@wstr(!"CONTEXT"), 38)


  scanner->tvallength = 128
  scanner->tval = callocate(scanner->tvallength,sizeof(wchar_t)) '' text of current token

  '' HEAP_BLOCK_SIZE byte heap + pointer to next heap block
  scanner->heap = callocate(1,HEAP_BLOCK_SIZE + sizeof(any ptr))
  scanner->firstheap = scanner->heap
  scanner->heapend = cast(any ptr ptr,((cast(ubyte ptr,scanner->heap) + HEAP_BLOCK_SIZE)))
	*(scanner->heapend) = 0
  scanner->heaptop = scanner->heap
  if (sizeof(token_) > HEAP_BLOCK_SIZE) then
    wprintf(@wstr(!"--- Too small HEAP_BLOCK_SIZE\n"))
    exit_(1)
  end if

  scanner->pos = -1:scanner->line = 1:scanner->col = 0:scanner->charpos = -1
  scanner->oldeols = 0
  scanner_nextch(scanner)
  if (scanner->ch = &hEF) then'' check optional byte order mark for UTF-8
    scanner_nextch(scanner): var ch1 = scanner->ch
    scanner_nextch(scanner): var ch2 = scanner->ch
    if (ch1 <> &hBB orelse ch2 <> &hBF) then
      wprintf(@wstr(!"Illegal byte order mark at start of file"))
      exit_(1)
    end if
    scanner->buffer_typ = 1 ''utf8
    scanner->utf8buffer = utf8buffer_create(scanner->buffer)
    scanner->col = 0
    scanner->charpos = -1
    scanner_nextch(scanner)
  end if

  scanner->tokens = token_create()
  scanner->pt = scanner->tokens '' first token is a dummy

end sub

sub scanner_nextch(byval scanner as scanner_ ptr)
  
  if (scanner->oldeols > 0) then
    scanner->ch = scanner->EOL
    scanner->oldeols -= 1
  else 
    scanner->pos = scanner->buffer->getpos_(scanner->buffer)
    '' buffer reads unicode chars, if UTF8 has been detected
    if (scanner->buffer_typ = 0) then
      scanner->ch = scanner->buffer->read_(scanner->buffer)
    else
      scanner->ch = scanner->utf8buffer->read_(scanner->utf8buffer)
    end if      
    scanner->col += 1:scanner->charpos += 1
    '' replace isolated '\r' by '\n' in order to make
    '' eol handling uniform across Windows, Unix and Mac
    if (scanner->ch = asc(!"\r") andalso scanner->buffer->peek_(scanner->buffer) <> asc(!"\n")) then
      scanner->ch = scanner->eol
    end if
    if (scanner->ch = scanner->eol) then
      scanner->line += 1
      scanner->col = 0
    end if
  end if

end sub

sub scanner_addch(byval scanner as scanner_ ptr)
  
  if (scanner->tlen >= scanner->tvallength) then
    scanner->tvallength *= 2
    var newbuf = callocate(scanner->tvallength,sizeof(wchar_t))
    memcpy(newbuf, scanner->tval, scanner->tlen*sizeof(wchar_t))
    deallocate(scanner->tval)
    scanner->tval = newbuf
  end if
  if (scanner->ch <> buffer_._EoF) then
    scanner->tval[scanner->tlen] = scanner->ch
    scanner->tlen += 1
    scanner_nextch(scanner)
  end if
  
end sub


function scanner_comment0(byval scanner as scanner_ ptr) as byte
  
  var level = 1
  var pos0 = scanner->pos
  var line0 = scanner->line
  var col0 = scanner->col
  var charpos0 = scanner->charpos
  
  scanner_nextch(scanner)
  if (scanner->ch = asc("/")) then
    scanner_nextch(scanner)
    while (1)
      if (scanner->ch = 10) then
        level -= 1
        if (level = 0) then
           scanner->oldeols = scanner->line - line0
           scanner_nextch(scanner)
           return 1
        end if
        scanner_nextch(scanner)
      elseif (scanner->ch = buffer_._EoF) then
        return 0
      else 
        scanner_nextch(scanner)
      end if
    wend
  else
    scanner->buffer->setpos_(scanner->buffer,pos0)
    scanner_nextch(scanner)
    scanner->line = line0
    scanner->col = col0
    scanner->charpos = charpos0
  end if
  return 0

end function

function scanner_comment1(byval scanner as scanner_ ptr) as byte

  var level = 1
  var pos0 = scanner->pos
  var line0 = scanner->line
  var col0 = scanner->col
  var charpos0 = scanner->charpos
  
  scanner_nextch(scanner)
  if (scanner->ch = asc("*")) then
    scanner_nextch(scanner)
    while(1)
      if (scanner->ch = asc("*")) then
        scanner_nextch(scanner)
        if (scanner->ch = asc("/")) then
          level -= 1
          if (level = 0) then
            scanner->oldeols = scanner->line - line0
            scanner_nextch(scanner)
            return 1
          end if
          scanner_nextch(scanner)
        end if
      elseif (scanner->ch = asc("/")) then
        scanner_nextch(scanner)
        if (scanner->ch = asc("*")) then
          level += 1
          scanner_nextch(scanner)
        end if
      elseif (scanner->ch = buffer_._EoF) then
        return 0
      else 
        scanner_nextch(scanner)
      end if
    wend
  else
    scanner->buffer->setpos_(scanner->buffer,pos0)
    scanner_nextch(scanner)
    scanner->line = line0
    scanner->col = col0
    scanner->charpos = charpos0
  end if
  return 0

end function


sub scanner_createheapblock(byval scanner as scanner_ ptr)
  
  dim newheap as any ptr
  dim cur as ubyte ptr = cast(ubyte ptr,scanner->firstheap)

  while((cast(ubyte ptr,scanner->tokens) < cur) orelse (cast(ubyte ptr,scanner->tokens) > (cur + HEAP_BLOCK_SIZE)))
    cur = *(cast(ubyte ptr ptr, (cur + HEAP_BLOCK_SIZE)))
    deallocate(scanner->firstheap)
    scanner->firstheap = cur
  wend

  '' HEAP_BLOCK_SIZE byte heap + pointer to next heap block
  newheap = callocate(1,HEAP_BLOCK_SIZE + sizeof(any ptr))
  *(scanner->heapend) = newheap
  scanner->heapend = cast(any ptr ptr,((cast(ubyte ptr,newheap)) + HEAP_BLOCK_SIZE))
  *(scanner->heapend) = 0
  scanner->heap = newheap
  scanner->heaptop = scanner->heap

end sub

function scanner_createtoken(byval scanner as scanner_ ptr) as token_ ptr
  
  dim t as token_ ptr
  if ((cast(ubyte ptr,scanner->heaptop) + cast(integer,sizeof(token_))) >= cast(ubyte ptr,scanner->heapend)) then
    scanner_createheapblock(scanner)
  end if
  t = cast(token_ ptr,scanner->heaptop)
  scanner->heaptop = cast(any ptr, (cast(ubyte ptr,scanner->heaptop) + sizeof(token_)))
  t->val = NIL
  t->next = NIL
  return t

end function

sub scanner_appendval(byval scanner as scanner_ ptr, byval t as token_ ptr)
  
  var reqmem = (scanner->tlen + 1) * sizeof(wchar_t)
  if ((cast(ubyte ptr,scanner->heaptop) + reqmem) >= cast(ubyte ptr,scanner->heapend)) then
    if (reqmem > HEAP_BLOCK_SIZE) then
      wprintf(@wstr(!"--- Too long token value\n"))
      exit_(1)
    end if
    scanner_createheapblock(scanner)
  end if
  t->val = cast(wchar_t ptr,scanner->heaptop)
  scanner->heaptop = cast(any ptr,(cast(ubyte ptr,scanner->heaptop) + reqmem))

  wcsncpy(t->val, scanner->tval, scanner->tlen)
  t->val[scanner->tlen] = 0

end sub

function scanner_nexttoken(byval scanner as scanner_ ptr) as token_ ptr
  
  while (scanner->ch = asc(" ") orelse _
        (scanner->ch >= 9 andalso scanner->ch <= 10) _
         orelse scanner->ch = 13)
    
    scanner_nextch(scanner)
  
  wend
  
  if ((scanner->ch = asc("/") andalso scanner_comment0(scanner)) orelse _
      (scanner->ch = asc("/") andalso scanner_comment1(scanner))) then
    
    return scanner_nexttoken(scanner)
  
  end if
  
  var reckind = scanner->nosym
  var recend = scanner->pos
  scanner->t = scanner_createtoken(scanner)
  scanner->t->pos = scanner->pos
  scanner->t->col = scanner->col
  scanner->t->line = scanner->line
  scanner->t->charpos = scanner->charpos
  var state = startstates_state(scanner->start,scanner->ch)
  scanner->tlen = 0
  scanner_addch(scanner)

  select case as const state
    case 0 
      case_0:
      if (reckind <> scanner->nosym) then
        scanner->tlen = recend - scanner->t->pos
        scanner_setscannerbehindt(scanner)
      end if
      scanner->t->kind = reckind
      '' Nextscanner->ch already done
    case 1
      case_1:
      recend = scanner->pos:reckind = 1
      if ((scanner->ch >= asc("0") andalso scanner->ch <= asc("9")) orelse (scanner->ch >= asc("A") andalso scanner->ch <= asc("Z")) orelse _
      scanner->ch = asc("_") orelse (scanner->ch >= asc("a") andalso scanner->ch <= asc("z"))) then
        scanner_addch(scanner)
        goto case_1
      else 
        scanner->t->kind = 1
        dim literal as wchar_t ptr = coco_string_create_il(scanner->tval, 0, scanner->tlen)
        scanner->t->kind = keywordmap_get(scanner->keywords,literal, scanner->t->kind)
        coco_string_destroy(literal)
        exit select
      end if
    case 2
      case_2:
      recend = scanner->pos:reckind = 2
      if ((scanner->ch >= asc("0") andalso scanner->ch <= asc("9"))) then
        scanner_addch(scanner)
        goto case_2
      else 
        scanner->t->kind = 2
        exit select
      end if
    case 3
      case_3:
        scanner->t->kind = 3:exit select
    case 4
      case_4:
        scanner->t->kind = 4:exit select
    case 5
      if (scanner->ch <= 9 orelse (scanner->ch >= 11 andalso scanner->ch <= 12) orelse _
         (scanner->ch >= 14 andalso scanner->ch <= asc("&")) orelse _
         (scanner->ch >= asc("(") andalso scanner->ch <= asc("[")) orelse _
         (scanner->ch >= asc("]") andalso scanner->ch <= 65535)) then
          scanner_addch(scanner)
          goto case_6
      elseif (scanner->ch = 92) then
        scanner_addch(scanner)
        goto case_7
      else 
        goto case_0
      end if
    case 6
      case_6:
      if (scanner->ch = 39) then
        scanner_addch(scanner)
        goto case_9
      else 
        goto case_0
      end if
    case 7
      case_7:
      if ((scanner->ch >= asc(" ") andalso scanner->ch <= asc("~"))) then
        scanner_addch(scanner)
        goto case_8
      else 
        goto case_0
      end if
    case 8
      case_8:
      if ((scanner->ch >= asc("0") andalso scanner->ch <= asc("9")) orelse (scanner->ch >= asc("a") andalso scanner->ch <= asc("f"))) then         
        scanner_addch(scanner)
        goto case_8
      elseif (scanner->ch = 39) then
        scanner_addch(scanner)
        goto case_9      
      else 
        goto case_0
      end if
    case 9
      case_9:
        scanner->t->kind = 5
    case 10
      case_10:
      recend = scanner->pos : reckind = 42
      if ((scanner->ch >= asc("0") andalso scanner->ch <= asc("9")) orelse (scanner->ch >= asc("A") andalso scanner->ch <= asc("Z")) orelse _
           scanner->ch = asc("_") orelse (scanner->ch >= asc("a") andalso scanner->ch <= asc("z"))) then
           scanner_addch(scanner)
           goto case_10           
      else 
        scanner->t->kind = 42
        exit select
      end if
    case 11
      case_11:
      recend = scanner->pos:reckind = 43
      if ((scanner->ch >= asc("-") andalso scanner->ch <= asc(".")) orelse (scanner->ch >= asc("0") andalso scanner->ch <= asc(":")) orelse _
          (scanner->ch >= asc("A") andalso scanner->ch <= asc("Z")) orelse scanner->ch = asc("_") orelse (scanner->ch >= asc("a") andalso _
           scanner->ch <= asc("z"))) then
         scanner_addch(scanner)
         goto case_11
      else 
        scanner->t->kind = 43
        exit select
      end if
    case 12
      case_12:
      if (scanner->ch <= 9 orelse (scanner->ch >= 11 andalso scanner->ch <= 12) orelse _
         (scanner->ch >= 14 andalso scanner->ch <= asc("!")) orelse (scanner->ch >= asc("#") andalso _
          scanner->ch <= asc("[")) orelse (scanner->ch >= asc("]") andalso _
          scanner->ch <= 65535)) then
          scanner_addch(scanner)
          goto case_12
      elseif (scanner->ch = 10 orelse scanner->ch = 13) then
        scanner_addch(scanner)
        goto case_4
      elseif (scanner->ch = asc("""")) then
        scanner_addch(scanner)
        goto case_3
      elseif (scanner->ch = 92) then
        scanner_addch(scanner)
        goto case_14
      else 
        goto case_0
      end if
    case 13
      recend = scanner->pos:reckind = 42
      if (scanner->ch >= asc("0") andalso scanner->ch <= asc("9")) then
        scanner_addch(scanner)
        goto case_10
      elseif ((scanner->ch >= asc("A") andalso scanner->ch <= asc("Z")) orelse _
              scanner->ch = asc("_") orelse (scanner->ch >= asc("a") andalso _
              scanner->ch <= asc("z"))) then
        scanner_addch(scanner)
        goto case_15
      else 
        scanner->t->kind = 42:exit select
      end if
    case 14
      case_14:
      if (scanner->ch >= asc(" ") andalso scanner->ch <= asc("~")) then
        scanner_addch(scanner)
        goto case_12
      else 
        goto case_0
      end if
    case 15
      case_15:
      recend = scanner->pos:reckind = 42
      if (scanner->ch >= asc("0") andalso scanner->ch <= asc("9")) then
        scanner_addch(scanner)
        goto case_10
      elseif ((scanner->ch >= asc("A") andalso scanner->ch <= asc("Z") orelse scanner->ch = asc("_") orelse _
              (scanner->ch >= asc("a") andalso scanner->ch <= asc("z")))) then
              scanner_addch(scanner)
              goto case_15
      elseif (scanner->ch = asc("=")) then
        scanner_addch(scanner)
        goto case_11
      else 
        scanner->t->kind = 42:exit select
      end if
    case 16
      scanner->t->kind = 17 
    case 17
      scanner->t->kind = 20 
    case 18
      scanner->t->kind = 21 
    case 19
      case_19:
      scanner->t->kind = 22 
    case 20
      scanner->t->kind = 25 
    case 21
      case_21:
      scanner->t->kind = 26 
    case 22
      case_22:
      scanner->t->kind = 27 
    case 23
      scanner->t->kind = 28 
    case 24
      scanner->t->kind = 31 
    case 25
      scanner->t->kind = 32 
    case 26
      scanner->t->kind = 33 
    case 27
      scanner->t->kind = 34 
    case 28
      scanner->t->kind = 35 
    case 29
      case_29:
      scanner->t->kind = 39 
    case 30
      case_30:
      scanner->t->kind = 40 
    case 31
      recend = scanner->pos: reckind = 18
      if (scanner->ch = asc(".")) then 
        scanner_addch(scanner)
        goto case_19
      elseif (scanner->ch = asc(">")) then
        scanner_addch(scanner)
        goto case_22
      elseif (scanner->ch = asc(")")) then
        scanner_addch(scanner)
        goto case_30
      else 
        scanner->t->kind = 18
        exit select
      end if
    case 32
      recend = scanner->pos:reckind = 24
      if (scanner->ch = asc(".")) then
        scanner_addch(scanner)
        goto case_21
      else 
        scanner->t->kind = 24
        exit select
      end if
    case 33
      recend = scanner->pos:reckind = 30
      if (scanner->ch = asc(".")) then
        scanner_addch(scanner)
        goto case_29
      else 
        scanner->t->kind = 30
        exit select
      end if
    case else
      if (state = -1) then
        scanner->t->kind = scanner->eofsym  '' Nextscanner->ch already done
      end if
      exit select
  end select
  scanner_appendval(scanner,scanner->t)
#ifdef DEBUG
  wprintf(@wstr(!"token = %ls\n"),scanner->t->val)
#endif  
  return scanner->t

end function

sub scanner_setscannerbehindt(byval scanner as scanner_ ptr)
  
  scanner->buffer->setpos_(scanner->buffer,scanner->t->pos)
  scanner_nextch(scanner)
  scanner->line = scanner->t->line
  scanner->col = scanner->t->col
  scanner->charpos = scanner->t->charpos
  for i as integer = 0 to scanner->tlen - 1 
    scanner_nextch(scanner)
  next i
  
end sub

'' get the next token (possibly a token already seen during peeking)
function scanner_scan(byval scanner as scanner_ ptr) as token_ ptr
''FIXME
  if (scanner->tokens->next = NIL) then
    scanner->tokens = scanner_nexttoken(scanner)
    scanner->pt = scanner->tokens
    return scanner->pt
  else 
    scanner->tokens = scanner->tokens->next
    scanner->pt = scanner->tokens
    return scanner->tokens
  end if

end function

'' peek for the next token, ignore pragmas
function scanner_peek(byval scanner as scanner_ ptr) as token_ ptr

  do
    if (scanner->pt->next = NIL) then
      scanner->pt->next = scanner_nexttoken(scanner)
    end if
    scanner->pt = scanner->pt->next
  loop while (scanner->pt->kind > scanner->maxt) '' skip pragmas

  return scanner->pt

end function

'' make sure that peeking starts at the current scan position
sub scanner_resetpeek(byval scanner as scanner_ ptr)

  if (scanner = NIL) then
    return
  end if
  scanner->pt = scanner->tokens

end sub

#ifndef COCO_SYMBOL_H__
#define COCO_SYMBOL_H__

#include once "crt/wchar.bi"
'#include "Position.bi"
'#include "Scanner.bi"
''forward declaration
type node__ as node_

type symbol_

public:
  '' token kinds
  enum
    fixedtoken    = 0   '' e.g. 'a' ('b' | 'c') (structure of literals)
    classtoken    = 1   '' e.g. digit {digit}   (at least one char class)
    littoken      = 2   '' e.g. "while"
    classlittoken = 3   '' e.g. letter {letter} but without literals that have the same structure
  end enum
  
  dim n as integer                 '' symbol number
  dim typ as integer               '' t, nt, pr, unknown, rslv /' ML 29_11_2002 slv added '/ /' AW slv --> rslv '/
  dim name as wchar_t ptr          '' symbol name
  ''node__ is a forward declaration
  dim graph as node__ ptr           '' nt: to first node of syntax graph
  dim tokenkind as integer         '' t:  token kind (fixedToken, classToken, ...)
  dim deletable as byte            '' nt: true if nonterminal is deletable
  dim firstready as byte           '' nt: true if terminal start symbols have already been computed
  dim first as bitarray_ ptr       '' nt: terminal start symbols
  dim follow as bitarray_ ptr      '' nt: terminal followers
  dim nts as bitarray_ ptr         '' nt: nonterminals whose followers have to be added to this sym
  dim line as integer              '' source text line number of item in this node
  dim attrpos as position_ ptr     '' nt: position of attributes in source text (or null)
  dim sempos as position_ ptr      '' pr: pos of semantic action in source text (or null)
                                   '' nt: pos of local declarations in source text (or null)

end type

declare function symbol_create(byval typ as integer, byval name_ as wchar_t ptr, byval line_ as integer) as symbol_ ptr
declare sub symbol_destroy(byref symbol as symbol_ ptr)


#endif '' ifndef COCO_SYMBOL_H__

'#include "Symbol.bi"
'#include "Scanner.bi"

function symbol_create(byval typ as integer, byval name_ as wchar_t ptr, byval line_ as integer) as symbol_ ptr
  
  dim symbol as symbol_ ptr
  symbol = callocate(1,sizeof(symbol_))
  symbol->n = 0
  symbol->graph = NIL
  symbol->tokenkind = 0
  symbol->deletable = 0
  symbol->firstready = 0
  symbol->first = NIL
  symbol->follow = NIL
  symbol->nts = NIL 
  symbol->attrpos = NIL 
  symbol->sempos = NIL 

  symbol->typ = typ 
  symbol->name = coco_string_create(name_)
  symbol->line = line_

  return symbol

end function

''STUB
sub symbol_destroy(byref symbol as symbol_ ptr)
  
  if (symbol = NIL) then
    return
  end if
  
  coco_string_destroy(symbol->name)
  
  deallocate(symbol)
  symbol = NIL

end sub

#ifndef COCO_GRAPH_H__
#define COCO_GRAPH_H__

'#include once "Node.bi"
'#include once "Graph.bi"

type graph_
public:
  dim l as node__ ptr '' left end of graph = head
  dim r as node__ ptr '' right end of graph = list of nodes to be linked to successor graph

end type

declare function graph_create() as graph_ ptr
declare function graph_create_leftright(byval left_ as node__ ptr, byval right_ as node__ ptr) as graph_ ptr
declare function graph_create_node(byval p as node__ ptr) as graph_ ptr
declare sub graph_destroy(byref graph as graph_ ptr)

#endif '' ifndef COCO_GRAPH_H__

function graph_create() as graph_ ptr
  
    dim graph as graph_ ptr
    graph = callocate(1,sizeof(graph_))
    graph->l = NIL
    graph->r = NIL
    return graph

end function

function graph_create_leftright(byval left_ as node__ ptr, byval right_ as node__ ptr) as graph_ ptr

    dim graph as graph_ ptr
    graph = callocate(1,sizeof(graph_))
    graph->l = left_
    graph->r = right_
    return graph

end function

function graph_create_node(byval p as node__ ptr) as graph_ ptr
  
  dim graph as graph_ ptr
  graph = callocate(1,sizeof(graph_))
  graph->l = p
  graph->r = p
  return graph
  
end function

sub graph_destroy(byref graph as graph_ ptr)

  if (graph <> NIL) then
    deallocate(graph)
  end if
  graph = NIL
  
end sub

#ifndef COCO_STATE_H__
#define COCO_STATE_H__

'#include once "Action.bi"
'#include once "Symbol.bi"
type action__ as action_

type state_  '' state of finite automaton

public:
  dim nr as integer       '' state number
  dim firstaction as action__ ptr '' to first action of this state
  dim endof as symbol_ ptr        '' recognized token if state is final
  dim ctx as byte                 '' true if state is reached via contexttrans
  dim next as state_ ptr

end type

declare function state_create() as state_ ptr
declare sub state_destroy(byref state as state_ ptr)
'next few functions have been added to the action section (state<-->action dependency)
'declare sub state_addaction(byval state as state_ ptr,byval act as action_ ptr)
'declare sub state_detachaction(byval state as state_ ptr, byval act as action_ ptr)
'declare sub state_meltwith(byval state as state_ ptr,byval s as state_ ptr)

#endif '' ifndef COCO_STATE_H__

'#include once "Action.bi"
'#include once "State.bi"

function state_create() as state_ ptr
  
  dim state as state_ ptr
  state = callocate(1,sizeof(state_))
  state->firstaction = NIL
  state->endof       = NIL
  state->ctx         = 0
  state->next        = NIL
  return state
  
end function

''STUB
sub state_destroy(byref state as state_ ptr)

  if (state = NIL) then
    return
  end if
  deallocate(state)
  state = NIL
  
end sub


''COMPILES using stubs

#ifndef COCO_MELTED_H__
#define COCO_MELTED_H__

'#include once "State.bi"
'#include once "Scanner.bi"


type melted_      '' info about melted states

public:
  dim set as bitarray_ ptr      '' set of old states
  dim state as state_ ptr       '' new state
  dim next as melted_ ptr
  
end type

declare function melted_create(byval set as bitarray_ ptr, byval state as state_ ptr) as melted_ ptr
declare sub melted_destroy(byref melted as melted_ ptr)

'#include "Melted.bi"

function melted_create(byval set as bitarray_ ptr, byval state as state_ ptr) as melted_ ptr

  dim melted as melted_ ptr
  melted = callocate(1,sizeof(melted_))
  melted->set = set
  melted->state = state
  return melted

end function

''STUB
sub melted_destroy(byref melted as melted_ ptr)

  if (melted = NIL) then
    return
  end if
  
  if (melted->set <> NIL) then
    bitarray_destroy(melted->set)
  end if
  melted->set = NIL
  if (melted->state <> NIL) then
    state_destroy(melted->state)
  end if
  melted->state = NIL
  if (melted->next <> NIL) then
    melted_destroy(melted->next)
  end if
  melted->next = NIL
  deallocate(melted)
  melted = NIL

end sub

#endif ''ifndef COCO_MELTED_H__

#ifndef COCO_COMMENT_H__
#define COCO_COMMENT_H__

#include once "crt/wchar.bi"

type comment_           '' info about comment syntax

public:
  dim start as wchar_t ptr
  dim stop as wchar_t ptr
  dim nested as byte
  dim next as comment_ ptr

end type

declare function comment_create(byval start_ as wchar_t ptr, byval stop as wchar_t ptr, byval nested as byte) as comment_ ptr
declare sub comment_destroy(byref comment as comment_ ptr)

#endif ''ifndef COCO_COMMENT_H__

'#include "Comment.bi"
'#include "Scanner.bi"

function comment_create(byval start_ as wchar_t ptr, byval stop_ as wchar_t ptr, byval nested as byte) as comment_ ptr
  
  dim comment as comment_ ptr
  comment = callocate(sizeof(comment_),1)
  comment->start = coco_string_create(start_)
  comment->stop = coco_string_create(stop_)
  comment->nested = nested
  return comment
  
end function

sub comment_destroy(byref comment as comment_ ptr)

  if (comment = NIL) then
    return
  end if
  coco_string_destroy(comment->start)
  coco_string_destroy(comment->stop)
  deallocate(comment)
  comment = NIL
  
end sub

#ifndef COCO_NODE_H__
#define COCO_NODE_H__

#include once "crt/stdio.bi"
'#include once "Position.bi"
'#include once "State.bi"
'#include once "Scanner.bi"

type node_

public:
  dim n as integer      '' node number
  dim typ as integer    '' t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt, rslv
  dim next_ as node_ ptr    '' to successor node
  dim down as node_ ptr    '' alt: to next alternative
  dim sub_ as node_ ptr    '' alt, iter, opt: to first node of substructure
  dim up as byte      '' true: "next" leads to successor in enclosing structure
  dim sym as symbol_ ptr    '' nt, t, wt: symbol represented by this node
  dim val_ as integer    '' chr:  ordinal character value
                        '' clas: index of character class
  dim code as integer    '' chr, clas: transition code
  dim set as bitarray_ ptr    '' any, sync: the set represented by this node
  dim pos_ as position_ ptr    '' nt, t, wt: pos of actual attributes
                      '' sem:       pos of semantic action in source text
            '' rslv:       pos of resolver in source text
  dim line_ as integer    '' source text line number of item in this node
  dim state as state_ ptr  '' DFA state corresponding to this node
                        '' (only used in DFA.ConvertToStates)
  '' constants for node kinds
  enum
    t = 1      '' terminal symbol
    pr = 2    '' pragma
    nt = 3    '' nonterminal symbol
    clas = 4  '' character class
    chr = 5   '' character
    wt = 6    '' weak terminal symbol
    any_ = 7   '' 
    eps = 8   '' empty
    sync = 9  '' synchronization symbol
    sem = 10   '' semantic action: (. .)
    alt = 11   '' alternative: |
    iter = 12  '' iteration: { }
    opt = 13   '' option: [ ]
    rslv = 14  '' resolver expr
    
    normaltrans = 0    '' transition codes
    contexttrans = 1
  end enum
  '                      
end type 

declare function node_create(byval typ as integer, byval sym as symbol_ ptr, byval line_ as integer) as node_ ptr
declare sub node_destroy(byref node as node_ ptr)

#endif '' ifndef COCO_NODE_H__

'#include "Node.bi"

function node_create(byval typ as integer, byval sym as symbol_ ptr, byval line_ as integer) as node_ ptr

  dim node as node_ ptr
  node = callocate(1,sizeof(node_))
  node->n     = 0
  node->next_  = NIL
  node->down  = NIL
  node->sub_   = NIL
  node->up    = 0
  node->val_   = 0
  node->code  = 0
  node->set   = NIL
  node->pos_   = NIL
  node->state = NIL

  node->typ = typ 
  node->sym = sym
  node->line_ = line_
  return node
  
end function

sub node_destroy(byref node as node_ ptr)

  if (node = NIL) then
    return
  end if
  deallocate(node)
  node = NIL
  
end sub

#ifndef COCO_TARGET_H__
#define COCO_TARGET_H__

type target_      '' set of states that are reached by an action

public:
  dim state as state_ ptr       '' target state
  dim next as target_ ptr
  
end type

declare function target_create(byval s as state_ ptr) as target_ ptr
declare sub target_destroy(byref target as target_ ptr)


#endif '' ifndef COCO_TARGET_H__

#include once "crt/stdio.bi"
'#include once "Target.bi"
'#include once "State.bi"

function target_create(byval s as state_ ptr) as target_ ptr

  dim target as target_ ptr
  target = callocate(1,sizeof(target_))
  target->next = NIL
  target->state = s
  return target
  
end function

sub target_destroy(byref target as target_ ptr)

  if (target = NIL) then
    return 
  end if
  
  'if (target->state <> NIL) then
  '  state_destroy(target->state)
  'end if
  'target->state = NIL
  'if (target->next <> NIL) then
  '  target_destroy(target->next)
  'end if
  'target->next = NIL
  deallocate(target)
  target = NIL

end sub

#ifndef COCO_ACTION_H__
#define COCO_ACTION_H__

'#include once "State.bi"
'#include once "Target.bi"
'#include once "Tab.bi"

type action_        '' action of finite automaton

public:
  dim typ as integer      '' type of action symbol: clas, chr
  dim sym as integer      '' action symbol
  dim tc as integer       '' transition code: normalTrans, contextTrans
  dim target as target_ ptr   '' states reached from this action
  dim next as action_ ptr

end type

declare function action_create(byval typ as integer, byval sym as integer, byval tc as integer) as action_ ptr
declare sub action_destroy(byref action as action_ ptr, byval sym as integer, byval tc as integer)
declare sub action_addtarget(byval action as action_ ptr,byval t as target_ ptr)  '' add t to the action.targets
declare sub action_addtargets(byval action as action_ ptr, byval a as action_ ptr) '' add copy of a.targets to action.targets
'FIXME commented out next two functions as these need access to tab (not declared yet)



#endif '' ifndef COCO_ACTION_H__

'#include once "Action.bi"
'#include once "Target.bi"
'#include once "CharSet.bi"

function action_create(byval typ as integer, byval sym as integer, byval tc as integer) as action_ ptr
  
  dim action as action_ ptr
  action = callocate(1,sizeof(action_))
  action->target = NIL
  action->next   = NIL

  action->typ = typ
  action->sym = sym
  action->tc = tc
  
  return action

end function


sub action_addtarget(byval action as action_ ptr,byval t as target_ ptr)  '' add t to the action.targets

  dim last as target_ ptr = NIL
  dim p as target_ ptr = action->target
  while (p <> NIL andalso t->state->nr >= p->state->nr)
    if (t->state = p->state) then
      return
    end if
    last = p
    p = p->next
  wend
  t->next = p
  if (p = action->target) then
    action->target = t
  else 
    last->next = t
  end if

end sub

sub action_addtargets(byval action as action_ ptr, byval a as action_ ptr) '' add copy of a.targets to action.targets

  dim p as target_ ptr
  p = a->target
  while(p <> NULL)
    dim t as target_ ptr = target_create(p->state)
    action_addtarget(action,t)
    p = p->next    
  wend
  if (a->tc = node_.contexttrans)  then
    action->tc = node_.contexttrans
  end if

end sub

'FIXME commented out next two functions as these need access to tab

''state_ functions moved here because of action dependency (no need for forward declaration)
sub state_addaction(byval state as state_ ptr,byval act as action_ ptr)
  
  dim lasta as action_ ptr = NIL
  dim a as action_ ptr = state->firstaction
  while (a <> NIL andalso act->typ >= a->typ) 
    lasta = a
    a = a->next
  wend
  '' collecting classes at the beginning gives better performance
  act->next = a
  if (a = state->firstaction) then
    state->firstaction = act
  else 
    lasta->next = act
  end if
  
end sub

sub state_detachaction(byval state as state_ ptr, byval act as action_ ptr)
  
  dim lasta as action_ ptr = NIL
  dim a as action_ ptr = state->firstaction
  while (a <> NIL andalso a <> act) 
    lasta = a
    a = a->next
  wend
  
  if (a <> NIL)  then
    if (a = state->firstaction) then
      state->firstaction = a->next
    else 
      lasta->next = a->next
    end if
  end if

end sub

sub state_meltwith(byval state as state_ ptr,byval s as state_ ptr)
'' copy actions of s to state
  
  dim a as action_ ptr
  dim action as action_ ptr
  action = s->firstaction
  while(action <> NIL)
    a = action_create(action->typ, action->sym, action->tc)
    action_addtargets(a,action)
    state_addaction(state,a)
    action = action->next
  wend

end sub

#ifndef COCO_TAB_H__
#define COCO_TAB_H__

'#include "ArrayList.bi"
'#include "HashTable.bi"
'#include "StringBuilder.bi"
'#include "SortedList.bi"
'#include "Scanner.bi"
'#include "Position.bi"
'#include "Symbol.bi"
'#include "Node.bi"
'#include "Graph.bi"
'#include "Sets.bi"
'#include "CharClass.bi"
type parser__ as parser_

''errors taken from parser.bi to solve tab->errors dependency
type errors_

public:
  dim count as integer  '' number of errors detected

end type '' Errors

function errors_create() as errors_ ptr
  
  dim errors as errors_ ptr
  errors = callocate(1,sizeof(errors_))
  errors->count = 0
  return errors

end function

sub errors_destroy(byref errors as errors_ ptr)
  
  if (errors = NIL) then
    return
  end if
  deallocate(errors)
  errors = NIL

end sub

sub errors_synerr(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval n as integer)
  
  dim s as wchar_t ptr
  select case as const (n) 
    case 0: s = coco_string_create(@wstr(!"EOF expected"))
    case 1: s = coco_string_create(@wstr(!"ident expected"))
    case 2: s = coco_string_create(@wstr(!"number expected"))
    case 3: s = coco_string_create(@wstr(!"string expected"))
    case 4: s = coco_string_create(@wstr(!"badString expected"))
    case 5: s = coco_string_create(@wstr(!"char expected"))
    case 6: s = coco_string_create(@wstr(!"\"COMPILER\" expected"))
    case 7: s = coco_string_create(@wstr(!"\"IGNORECASE\" expected"))
    case 8: s = coco_string_create(@wstr(!"\"CHARACTERS\" expected"))
    case 9: s = coco_string_create(@wstr(!"\"TOKENS\" expected"))
    case 10: s = coco_string_create(@wstr(!"\"PRAGMAS\" expected"))
    case 11: s = coco_string_create(@wstr(!"\"COMMENTS\" expected"))
    case 12: s = coco_string_create(@wstr(!"\"FROM\" expected"))
    case 13: s = coco_string_create(@wstr(!"\"TO\" expected"))
    case 14: s = coco_string_create(@wstr(!"\"NESTED\" expected"))
    case 15: s = coco_string_create(@wstr(!"\"IGNORE\" expected"))
    case 16: s = coco_string_create(@wstr(!"\"PRODUCTIONS\" expected"))
    case 17: s = coco_string_create(@wstr(!"\"=\" expected"))
    case 18: s = coco_string_create(@wstr(!"\".\" expected"))
    case 19: s = coco_string_create(@wstr(!"\"END\" expected"))
    case 20: s = coco_string_create(@wstr(!"\"+\" expected"))
    case 21: s = coco_string_create(@wstr(!"\"-\" expected"))
    case 22: s = coco_string_create(@wstr(!"\"..\" expected"))
    case 23: s = coco_string_create(@wstr(!"\"ANY\" expected"))
    case 24: s = coco_string_create(@wstr(!"\"<\" expected"))
    case 25: s = coco_string_create(@wstr(!"\">\" expected"))
    case 26: s = coco_string_create(@wstr(!"\"<.\" expected"))
    case 27: s = coco_string_create(@wstr(!"\".>\" expected"))
    case 28: s = coco_string_create(@wstr(!"\"|\" expected"))
    case 29: s = coco_string_create(@wstr(!"\"WEAK\" expected"))
    case 30: s = coco_string_create(@wstr(!"\"(\" expected"))
    case 31: s = coco_string_create(@wstr(!"\")\" expected"))
    case 32: s = coco_string_create(@wstr(!"\"[\" expected"))
    case 33: s = coco_string_create(@wstr(!"\"]\" expected"))
    case 34: s = coco_string_create(@wstr(!"\"{\" expected"))
    case 35: s = coco_string_create(@wstr(!"\"}\" expected"))
    case 36: s = coco_string_create(@wstr(!"\"SYNC\" expected"))
    case 37: s = coco_string_create(@wstr(!"\"IF\" expected"))
    case 38: s = coco_string_create(@wstr(!"\"CONTEXT\" expected"))
    case 39: s = coco_string_create(@wstr(!"\"(.\" expected"))
    case 40: s = coco_string_create(@wstr(!"\".)\" expected"))
    case 41: s = coco_string_create(@wstr(!"??? expected"))
    case 42: s = coco_string_create(@wstr(!"this symbol not expected in Coco"))
    case 43: s = coco_string_create(@wstr(!"this symbol not expected in TokenDecl"))
    case 44: s = coco_string_create(@wstr(!"invalid TokenDecl"))
    case 45: s = coco_string_create(@wstr(!"invalid AttrDecl"))
    case 46: s = coco_string_create(@wstr(!"invalid SimSet"))
    case 47: s = coco_string_create(@wstr(!"invalid Sym"))
    case 48: s = coco_string_create(@wstr(!"invalid Term"))
    case 49: s = coco_string_create(@wstr(!"invalid Factor"))
    case 50: s = coco_string_create(@wstr(!"invalid Attribs"))
    case 51: s = coco_string_create(@wstr(!"invalid TokenFactor"))
    case else
      dim format_(0 to 20) as wchar_t
      coco_swprintf(@format_(0), 20, @wstr(!"error %d"), n)
      s = coco_string_create(@format_(0))
  end select
  wprintf(@wstr(!"-- line %d col %d: %ls\n"), line_, col, s)
  coco_string_destroy(s)
  errors->count+=1

end sub

sub errors_error(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval s as wchar_t ptr) 
  
  wprintf(@wstr(!"-- line %d col %d: %ls\n"), line_, col, s)
  errors->count += 1

end sub

sub errors_warning_line(byval errors as errors_ ptr, byval line_ as integer, byval col as integer, byval s as wchar_t ptr)
  
  wprintf(@wstr(!"-- line %d col %d: %ls\n"), line_, col, s)

end sub

sub errors_warning(byval errors as errors_ ptr, byval s as wchar_t ptr)
  
  wprintf(@wstr(!"%ls\n"), s)

end sub

sub errors_exception(byval errors as errors_ ptr, byval s as wchar_t ptr) 
  
  wprintf(@wstr(!"%ls"), s) 
  exit_(1)

end sub

type tab_

public:
  dim semdeclpos as position_ ptr       '' position of global semantic declarations
  dim ignored as charset_ ptr           '' characters ignored by the scanner
  dim ddt(0 to 9) as byte               '' debug and test switches
  dim gramsy as symbol_ ptr             '' root nonterminal; filled by ATG
  dim eofsy as symbol_ ptr              '' end of file symbol
  dim nosym as symbol_ ptr              '' used in case of an error
  dim allsyncsets as bitarray_ ptr      '' union of all synchronisation sets
  dim literals as hashtable_ ptr        '' symbols that are used as literals

  dim srcname as wchar_t ptr            '' name of the atg file (including path)
  dim srcdir as wchar_t ptr             '' directory path of the atg file
  dim nsname as wchar_t ptr             '' namespace for generated files
  dim framedir as wchar_t ptr           '' directory containing the frame files
  dim outdir as wchar_t ptr             '' directory for generated files
  dim checkeof as byte                  '' should coco generate a check for EOF at
                                        '' the end of Parser.Parse():
  dim emitlines as byte                 '' emit line directives in generated parser

  dim visited as bitarray_ ptr          '' mark list for graph traversals
  dim cursy as symbol_ ptr              '' current symbol in computation of sets

  ''forward reference
  dim parser as parser__ ptr            '' other Coco objects
  dim trace as FILE ptr

  dim errors as errors_ ptr

  dim terminals as arraylist_ ptr
  dim pragmas as arraylist_ ptr
  dim nonterminals as arraylist_ ptr
  dim tkind(0 to 3) as zstring ptr => {@"fixedToken", @"classToken", @"litToken", @"classLitToken"}

  dim nodes as arraylist_ ptr
  dim ntyp(0 to 14) as zstring ptr => {@"    ", @"t   ", @"pr  ", @"nt  ", @"clas", @"chr ", @"wt  ", @"any ", @"eps ",_
                                              @"sync", @"sem ", @"alt ", @"iter", @"opt ", @"rslv"}
  dim dummynode as node_ ptr

  dim classes as arraylist_ ptr
  dim dummyname as integer

end type

'all declarations declared later due to parser_ dependency (declared later)



  ''--------------- check for circular productions ----------------------
  type cnode_   '' node of list for finding circular productions

  public:
    dim left as symbol_ ptr
    dim right as symbol_ ptr

  end type
  
#endif '' ifndef COCO_TAB_H__

#ifndef COCO_GENERATOR_H__
#define COCO_GENERATOR_H__

#include once "crt/stdio.bi"
'#include once "Tab.bi"
'#include once "Parser.bi"
'

type generator_

public:
  dim fram as FILE ptr
  dim gen as FILE ptr
  dim tab as tab_ ptr
  dim framefile as wchar_t ptr
  dim errors as errors_ ptr

end type


declare function generator_create(byval _tab as tab_ ptr, byval errors as errors_ ptr) as generator_ ptr
declare sub generator_destroy(byref generator as generator_ ptr)
declare function generator_openframe(byval generator as generator_ ptr, byval frame as wchar_t ptr) as FILE ptr
declare function generator_opengen(byval generator as generator_ ptr, byval genname as wchar_t ptr) as FILE ptr
declare sub generator_copyright(byval generator as generator_ ptr)
declare sub generator_skipframepart(byval generator as generator_ ptr, byval stop_ as wchar_t ptr)
declare sub generator_copyframepart(byval generator as generator_ ptr, byval stop_ as wchar_t ptr)
declare sub generator_copyframepart_output(byval generator as generator_ ptr, byval stop_ as wchar_t ptr, byval generateoutput as byte)

#endif '' ifndef COCO_GENERATOR_H__

''FIXME next section gives problems (errors and tab)
'
''#include "Generator.bi"
''#include "Scanner.bi"
'
function generator_create(byval _tab as tab_ ptr, byval errors as errors_ ptr) as generator_ ptr
    
    dim generator as generator_ ptr
    generator = callocate(1,sizeof(generator_))
    generator->errors = errors
    generator->tab = _tab
    generator->fram = NIL
    generator->gen = NIL
    generator->framefile = NIL
    return generator
    
end function

function generator_openframe(byval generator as generator_ ptr, byval frame as wchar_t ptr) as FILE ptr
    
  if (coco_string_length(generator->tab->framedir) <> 0) then
    generator->framefile = coco_string_create_appendwc(generator->tab->framedir, cast(wchar_t,asc("/")))
    coco_string_merge(generator->framefile, frame)
    dim chframefile as zstring ptr = coco_string_create_char(generator->framefile)
    generator->fram = fopen(chframefile, "r")
    deallocate(chframefile)
  end if
  if (generator->fram = NIL) then
    deallocate(generator->framefile)
    generator->framefile = coco_string_create_appendws(generator->tab->srcdir, frame)  /' pdt '/
    dim chframefile as zstring ptr = coco_string_create_char(generator->framefile)
    generator->fram = fopen(chframefile, "r")
    deallocate(chframefile)
  end if
  if (generator->fram = NIL) then
    dim message as wchar_t ptr = coco_string_create_appendws(@wstr(!"-- Cannot find : "), frame)
    errors_exception(generator->errors,message)
    deallocate(message)
  end if

  return generator->fram
  
end function


function generator_opengen(byval generator as generator_ ptr, byval genname as wchar_t ptr) as FILE ptr /' pdt '/
    
  dim fn as wchar_t ptr = coco_string_create_appendws(generator->tab->outdir, genname) /' pdt '/
  dim chfn as zstring ptr = coco_string_create_char(fn)

  generator->gen = fopen(chfn, "r")
  if (generator->gen <> NIL) then
    fclose(generator->gen)
    dim oldname as wchar_t ptr = coco_string_create_appendws(fn, @wstr(".old"))
    dim choldname as zstring ptr = coco_string_create_char(oldname)    
    remove(choldname)
    rename_(chfn, choldname) '' copy with overwrite
    coco_string_destroy_zstr(choldname)
    coco_string_destroy(oldname)
  end if
  generator->gen = fopen(chfn, "w")
  if (generator->gen = NIL) then
    dim message as wchar_t ptr = coco_string_create_appendws(@wstr(!"-- Cannot generate : "), genname)
    errors_exception(generator->errors,message)
    coco_string_destroy(message)
  end if
  coco_string_destroy_zstr(chfn)
  coco_string_destroy(fn)

  return generator->gen

end function


sub generator_copyright(byval generator as generator_ ptr)
  
  dim file_ as FILE ptr = NIL

  if (coco_string_length(generator->tab->framedir) <> 0) then
    dim copyfr as wchar_t ptr = coco_string_create_appendws(generator->tab->framedir, @wstr(!"/Copyright.frame"))
    dim chcopyfr as zstring ptr = coco_string_create_char(copyfr)
    file_ = fopen(chcopyfr, "r")
    coco_string_destroy(copyfr)
    coco_string_destroy_zstr(chcopyfr)
  end if
  if (file_ = NIL) then
    dim copyfr as wchar_t ptr = coco_string_create_appendws(generator->tab->srcdir, @wstr(!"Copyright.frame"))
    dim chcopyfr as zstring ptr = coco_string_create_char(copyfr)
    file_ = fopen(chcopyfr, "r")
    coco_string_destroy(copyfr)
    coco_string_destroy_zstr(chcopyfr)
  end if
  
  if (file_ = NIL) then
    return
  end if

  dim scannerfram as FILE ptr = generator->fram
  generator->fram = file_

  generator_copyframepart(generator,NIL)
  generator->fram = scannerfram

  fclose(file_)

end sub

sub generator_skipframepart(byval generator as generator_ ptr, byval stop_ as wchar_t ptr)
  
  generator_copyframepart_output(generator,stop_, 0)

end sub

sub generator_copyframepart(byval generator as generator_ ptr, byval stop_ as wchar_t ptr)
  
  generator_copyframepart_output(generator,stop_, 1)

end sub

sub generator_copyframepart_output(byval generator as generator_ ptr, byval stop_ as wchar_t ptr, byval generateoutput as byte)
  
  dim startch as wchar_t = 0
  dim endofstopstring as integer = 0
  dim ch as wchar_t = 0

  if (stop_ <> NIL) then
    startch = stop_[0]
    endofstopstring = coco_string_length(stop_)-1
  end if

  fwscanf(generator->fram, @wstr(!"%lc"), @ch) '' fram.ReadByte();
  while (feof(generator->fram) = 0) '' ch <> EOF
    if (stop_ <> NIL andalso ch = startch) then
      dim i as integer = 0
      do
        if (i = endofstopstring) then
          return '' stop_[0..i] found
        end if
        fwscanf(generator->fram, @wstr(!"%lc"), @ch)
        i += 1
      loop while (ch = stop_[i])
      '' stop_[0..i-1] found; continue with last read character
      if (generateoutput) then
        dim substop as wchar_t ptr = coco_string_create_il(stop_, 0, i)
        fwprintf(generator->gen, @wstr(!"%ls"), substop)
        coco_string_destroy(substop)
      end if
    else
      if (generateoutput) then
        fwprintf(generator->gen, @wstr(!"%lc"), ch)
      end if
      fwscanf(generator->fram, @wstr(!"%lc"), @ch)
    end if
  wend
  if (stop_ <> NIL) then
    dim message as wchar_t ptr = coco_string_create_appendws(@wstr(!" -- Incomplete or corrupt frame file: "), generator->framefile)
    errors_exception(generator->errors,message)
    coco_string_destroy(message)
  end if

end sub

#ifndef COCO_DFA_H__
#define COCO_DFA_H__

#include once "crt/stddef.bi"
'#include once "Action.bi"
'#include once "Comment.bi"
'#include once "State.bi"
'#include once "Symbol.bi"
'#include once "Melted.bi"
'#include once "Node.bi"
'#include once "Target.bi"

type dfa_

public:
  dim maxstates as integer
  dim laststatenr as integer  '' highest state number
  dim firststate as state_ ptr
  dim laststate as state_ ptr '' last allocated state
  dim lastsimstate as integer '' last non melted state
  dim fram as FILE ptr        '' scanner frame input
  dim gen as FILE ptr         '' generated scanner file
  dim cursy as symbol_ ptr    '' current token to be recognized (in findtrans)
  dim curgraph as node_ ptr   '' start of graph for current token (in findtrans)
  dim ignorecase as byte      '' true if input should be treated case-insensitively
  dim dirtydfa as byte        '' DFA may become nondeterministic in matchliteral
  dim hasctxmoves as byte     '' DFA has context transitions
  dim existlabel as byte ptr  '' checking the labels (in order to avoid the warning messages)

  dim parser as parser__ ptr  '' other Coco objects
  dim tab as tab_ ptr
  dim errors as errors_ ptr
  dim trace as FILE ptr

  dim firstmelted as melted_ ptr    '' head of melted state list
  dim firstcomment as comment_ ptr  '' list of comments

end type
  
  ''---------- Output primitives
declare function dfa_ch(byval dfa as dfa_ ptr,byval ch as wchar_t) as wchar_t ptr
declare function dfa_chcond(byval dfa as dfa_ ptr,byval ch as wchar_t) as wchar_t ptr
declare sub dfa_putrange(byval dfa as dfa_ ptr, byval s as charset_ ptr)

  ''---------- state handling
declare function dfa_newstate(byval dfa as dfa_ ptr) as state_ ptr
declare sub dfa_newtransition(byval dfa as dfa_ ptr,byval from_ as state_ ptr, _
                              byval to_ as state_ ptr, byval typ as integer, _
                              byval sym as integer, byval tc as integer)
declare sub dfa_combineshifts(byval dfa as dfa_ ptr)
declare sub dfa_findusedstates(byval dfa as dfa_ ptr,byval state as state_ ptr, byval used as bitarray_ ptr)
declare sub dfa_deleteredundantstates(byval dfa as dfa_ ptr)
declare function dfa_thestate(byval dfa as dfa_ ptr,byval p as node_ ptr) as state_ ptr
declare sub dfa_step(byval dfa as dfa_ ptr,byval from_ as state_ ptr, byval p as node_ ptr, byval stepped as bitarray_ ptr)
declare sub dfa_numbernodes(byval dfa as dfa_ ptr,byval p as node_ ptr, byref state as state_ ptr, byval renumiter as byte)
declare sub dfa_findtrans(byval dfa as dfa_ ptr, byval p as node_ ptr, byval start_ as byte, byval marked as bitarray_ ptr)
declare sub dfa_converttostates(byval dfa as dfa_ ptr,byval p as node_ ptr, byval sym as symbol_ ptr)

  '' match string against current automaton store it either as a fixedtoken or as a littoken
declare sub dfa_matchliteral(byval dfa as dfa_ ptr,byval s as wchar_t ptr, byval sym as symbol_ ptr)
declare sub dfa_splitactions(byval dfa as dfa_ ptr,byval state as state_ ptr, byval a as action_ ptr, byval b as action_ ptr)
declare function dfa_overlap(byval dfa as dfa_ ptr,byval a as action_ ptr, byval b as action_ ptr) as byte
declare function dfa_makeunique(byval dfa as dfa_ ptr,byval state as state_ ptr) as byte '' return true if actions were split
declare sub dfa_meltstates(byval dfa as dfa_ ptr,byval state as state_ ptr)
declare sub dfa_findctxstates(byval dfa as dfa_ ptr)
declare sub dfa_makedeterministic(byval dfa as dfa_ ptr)
declare sub dfa_printstates(byval dfa as dfa_ ptr)
declare sub dfa_checklabels(byval dfa as dfa_ ptr)

  ''---------------------------- actions --------------------------------
declare function dfa_findaction(byval dfa as dfa_ ptr,byval state as state_ ptr, byval ch as wchar_t) as action_ ptr
declare sub dfa_gettargetstates(byval dfa as dfa_ ptr,byval a as action_ ptr, _
                                byref targets as bitarray_ ptr, byref endof as symbol_ ptr, byval ctx as byte)

  ''------------------------- melted states ------------------------------
declare function dfa_newmelted(byval dfa as dfa_ ptr,byval set as bitarray_ ptr, byval state as state_ ptr) as melted_ ptr
declare function dfa_meltedset(byval dfa as dfa_ ptr,byval nr as integer) as bitarray_ ptr
declare function dfa_statewithset(byval dfa as dfa_ ptr,byval s as bitarray_ ptr) as melted_ ptr

  ''------------------------ comments --------------------------------
declare function dfa_commentstr(byval dfa as dfa_ ptr,byval p as node_ ptr) as wchar_t ptr
declare sub dfa_newcomment(byval dfa as dfa_ ptr,byval from_ as node_ ptr, byval to_ as node_ ptr, byval nested as byte)

  ''------------------------ scanner generation ----------------------
declare sub dfa_gencombody(byval dfa as dfa_ ptr,byval com_ as comment_ ptr)
declare sub dfa_gencommentheader(byval dfa as dfa_ ptr,byval com_ as comment_ ptr, byval i as integer)
declare sub dfa_gencomment(byval dfa as dfa_ ptr,byval com_ as comment_ ptr, byval i as integer)
declare sub dfa_copyframepart(byval dfa as dfa_ ptr,byval stop_ as wchar_t ptr)
declare function dfa_symname(byval dfa as dfa_ ptr,byval sym as symbol_ ptr) as wchar_t ptr '' real name value is stored in tab.literals
declare sub dfa_genliterals (byval dfa as dfa_ ptr)
declare function dfa_gennamespaceopen(byval dfa as dfa_ ptr,byval nsname as wchar_t ptr) as integer
declare sub dfa_gennamespaceclose(byval dfa as dfa_ ptr,byval nrofns as integer)
declare sub dfa_writestate(byval dfa as dfa_ ptr,byval state as state_ ptr)
declare sub dfa_writestarttab(byval dfa as dfa_ ptr)
declare sub dfa_opengen(byval dfa as dfa_ ptr,byval genname as wchar_t ptr, byval backup as byte) /' pdt '/
declare sub dfa_writescanner(byval dfa as dfa_ ptr)
'FIXME next function needs access to parser


#endif '' ifndef COCO_DFA_H__


#ifndef COCO_PARSERGEN_H__
#define COCO_PARSERGEN_H__

'#include once "Position.bi"
'#include once "Tab.bi"
'#include once "Symbol.bi"
'#include once "Scanner.bi"
'#include once "DFA.bi"

type parsergen_

public:
  dim maxterm as integer'' sets of size < maxTerm are enumerated
  dim CR as ubyte
  dim LF as ubyte

  dim terr as integer     '' error codes
  dim alterr as integer
  dim syncerr as integer

  dim usingpos as position_ ptr '' "using" definitions from the attributed grammar

  dim errornr as integer      '' highest parser error number
  dim cursy as symbol_ ptr    '' symbol whose production is currently generated
  dim fram as FILE ptr       '' parser frame file
  dim gen as FILE ptr '' generated parser source file
  dim err as wchar_t ptr '' generated parser error messages
  dim symset as arraylist_ ptr

  dim tab as tab_ ptr         '' other Coco objects
  dim trace as FILE ptr
  dim errors as errors_ ptr
  dim buffer as buffer_ ptr

end type

declare sub parsergen_indent(byval parsergen as parsergen_ ptr,byval n as integer)
declare function parsergen_useswitch(byval parsergen as parsergen_ ptr,byval p as node_ ptr) as byte
declare sub parsergen_copyframepart(byval parsergen as parsergen_ ptr, byval stop as wchar_t ptr)
declare sub parsergen_copysourcepart(byval parsergen as parsergen_ ptr,byval pos_ as position_ ptr, byval indent as integer)
declare function parsergen_gennamespaceopen(byval parsergen as parsergen_ ptr, byval nsname as wchar_t ptr) as integer
declare sub parsergen_gennamespaceclose(byval parsergen as parsergen_ ptr,byval nrofns as integer)
declare sub parsergen_generrormsg(byval parsergen as parsergen_ ptr,byval errtyp as integer, byval sym as symbol_ ptr)
declare function parsergen_newcondset(byval parsergen as parsergen_ ptr,byval s as bitarray_ ptr) as integer
declare sub parsergen_gencond(byval parsergen as parsergen_ ptr,byval s as bitarray_ ptr, byval p as node_ ptr)
declare sub parsergen_putcaselabels(byval parsergen as parsergen_ ptr,byval s as bitarray_ ptr)
declare sub parsergen_gencode(byval parsergen as parsergen_ ptr,byval p as node_ ptr, byval indent as integer, byval ischecked as bitarray_ ptr)
declare sub parsergen_gentokens(byval parsergen as parsergen_ ptr)
declare sub parsergen_gentokensheader(byval parsergen as parsergen_ ptr)
declare sub parsergen_genpragmas(byval parsergen as parsergen_ ptr)
declare sub parsergen_genpragmasheader(byval parsergen as parsergen_ ptr)
declare sub parsergen_gencodepragmas(byval parsergen as parsergen_ ptr)
declare sub parsergen_genproductions(byval parsergen as parsergen_ ptr)
declare sub parsergen_genproductionsheader(byval parsergen as parsergen_ ptr)
declare sub parsergen_initsets(byval parsergen as parsergen_ ptr)
declare sub parsergen_opengen(byval parsergen as parsergen_ ptr,byval genname as wchar_t ptr, byval backup as byte)
declare sub parsergen_writeparser (byval parsergen as parsergen_ ptr)
declare sub parsergen_writestatistics (byval parsergen as parsergen_ ptr)
declare sub parsergen_destroy(byref parsergen as parsergen_ ptr)

#endif '' ifndef COCO_PARSERGEN_H__

#ifndef COCO_PARSER_H__
#define COCO_PARSER_H__

'#include "Tab.bi"
'#include "DFA.bi"
'#include "ParserGen.bi"
'#include "Scanner.bi"


type parser_

  enum 
    _EOF=0,
    _ident=1,
    _number=2,
    _string=3,
    _badString=4,
    _char=5,
    _ddtSym=42,
    _optionSym=43
  end enum

  dim maxt as integer

  dim dummytoken as token_ ptr
  dim errdist as integer
  dim minerrdist as integer


  dim scanner as scanner_ ptr
  dim errors as errors_ ptr

  dim t as token_ ptr       '' last recognized token
  dim la as token_ ptr      '' lookahead token

  dim id as integer
  dim str as integer

  dim trace as FILE ptr     '' other Coco objects referenced in this ATG
  dim tab as tab_ ptr
  dim dfa as dfa_ ptr
  dim pgen as parsergen_ ptr

  dim genscanner as byte
  dim tokenstring as wchar_t ptr   '' used in declarations of literal tokens
  dim nostring as wchar_t ptr'' used in declarations of literal tokens

end type

declare sub parser_initdeclarations(byval parser as parser_ ptr)

/'-------------------------------------------------------------------------'/
declare sub parser_synerr(byval parser as parser_ ptr, byval n as integer)
declare sub parser_get(byval parser as parser_ ptr)
declare sub parser_expect(byval parser as parser_ ptr, byval n as integer)
declare function parser_startof(byval parser as parser_ ptr, byval s as integer) as byte
declare sub parser_expectweak(byval parser as parser_ ptr, byval n as integer, byval follow as integer)
declare function parser_weakseparator(byval parser as parser_ ptr, byval n as integer, _
                                      byval syfol as integer, byval repfol as integer) as byte

declare function parser_create(byval scanner as scanner_ ptr) as parser_ ptr
declare sub parser_destroy(byref parser as parser_ ptr)
declare sub parser_semerr(byval parser as parser_ ptr, byval msg as wchar_t ptr)

declare sub parser_coco(byval parser as parser_ ptr)
declare sub parser_setdecl(byval parser as parser_ ptr)
declare sub parser_tokendecl(byval parser as parser_ ptr,byval typ as integer)
declare sub parser_tokenexpr(byval parser as parser_ ptr,byref g as graph_ ptr)
declare sub parser_set(byval parser as parser_ ptr,byref s as charset_ ptr)
declare sub parser_attrdecl(byval parser as parser_ ptr,byref sym as symbol_ ptr)
declare sub parser_semtext(byval parser as parser_ ptr, byref pos_ as position_ ptr)
declare sub parser_expression(byval parser as parser_ ptr,byref g as graph_ ptr)
declare sub parser_simset(byval parser as parser_ ptr,byref s as charset_ ptr)
declare sub parser_char(byval parser as parser_ ptr, byval n as integer ptr)
declare sub parser_sym(byval parser as parser_ ptr,byref name_ as wchar_t ptr, byval kind as integer ptr)
declare sub parser_term(byval parser as parser_ ptr,byref g as graph_ ptr)
declare sub parser_resolver(byval parser as parser_ ptr, byref pos_ as position_ ptr)
declare sub parser_factor(byval parser as parser_ ptr,byref g as graph_ ptr)
declare sub parser_attribs(byval parser as parser_ ptr,byref p as node_ ptr)
declare sub parser_condition(byval parser as parser_ ptr)
declare sub parser_tokenterm(byval parser as parser_ ptr,byref g as graph_ ptr)
declare sub parser_tokenfactor(byval parser as parser_ ptr,byref g as graph_ ptr)
declare sub parser_parse(byval parser as parser_ ptr)

#endif '' ifndef COCO_PARSER_H__


''the following declarations and definitions have been moved
''as these need access to parser, parsergen, dfa etc....
''
#ifndef COCO_SORTEDLIST_H__
#define COCO_SORTEDLIST_H__

type sortedentry_

public:
  dim key as symbol_ ptr
  dim value as any ptr
  dim next as sortedentry_ ptr

end type

declare function sortedentry_create(byval key as symbol_ ptr, byval value as any ptr) as sortedentry_ ptr
declare sub sortedentry_destroy(byref sortedentry as sortedentry_ ptr)

type sortedlist_

public:
  dim count as integer
  dim data as sortedentry_ ptr

end type

declare function sortedlist_create() as sortedlist_ ptr
declare sub sortedlist_destroy(byref sortedlist as sortedlist_ ptr)
declare sub sortedlist_set(byval sortedlist as sortedlist_ ptr, byval key as symbol_ ptr,byval value as any ptr)
declare function sortedlist_get(byval sortedlist as sortedlist_ ptr,byval key as symbol_ ptr) as any ptr '' Value
declare function sortedlist_getkey(byval sortedlist as sortedlist_ ptr, byval index as integer) as any ptr'' Key
declare function sortedlist_itemat(byval sortedlist as sortedlist_ ptr, byval index as integer) as sortedentry_ ptr
declare function sortedlist_find(byval sortedlist as sortedlist_ ptr,byval key as symbol_ ptr) as byte

#endif '' ifndef COCO_SORTEDLIST_H__

function compare(byval x as symbol_ ptr, byval y as symbol_ ptr) as integer
  
  return coco_string_compareto(x->name, y->name)

end function

function sortedentry_create(byval key as symbol_ ptr, byval value as any ptr) as sortedentry_ ptr
  
  dim sortedentry as sortedentry_ ptr
  sortedentry = callocate(1,sizeof(sortedentry_))
  sortedentry->key   = key
  sortedentry->value = value
  sortedentry->next = nil
  return sortedentry
  
end function

sub sortedentry_destroy(byref sortedentry as sortedentry_ ptr)
  
  if (sortedentry = NIL) then
    return
  end if
  if (sortedentry->key = NIL) then
    return
  end if
  symbol_destroy(sortedentry->key)
  deallocate(sortedentry)
  sortedentry = NIL 
  
end sub


function sortedlist_create() as sortedlist_ ptr
  
  dim sortedlist as sortedlist_ ptr
  sortedlist = callocate(1,sizeof(sortedlist_))
  sortedlist->count = 0
  sortedlist->data = NIL
  return sortedlist
  
end function

sub sortedlist_destroy(byref sortedlist as sortedlist_ ptr)

  if (sortedlist <> NIL) then
    if (sortedlist->data <> NIL) then
      for i as integer = sortedlist->count -1 to 0 step -1
        sortedentry_destroy(sortedlist_itemat(sortedlist,i))
      next i
    end if
    deallocate(sortedlist)
    sortedlist = NIL
  end if

end sub

function sortedlist_find(byval sortedlist as sortedlist_ ptr,byval key as symbol_ ptr) as byte
  
  dim psortedentry as sortedentry_ ptr = sortedlist->data
  while (psortedentry) 
    if (compare(psortedentry->key, key)= 0) then
      return 1
    end if
    psortedentry = psortedentry->next
  wend
  return 0

end function

sub sortedlist_set(byval sortedlist as sortedlist_ ptr,byval key as symbol_ ptr,byval value as any ptr)
  
  if (sortedlist_find(sortedlist,key) = 0) then
    '' new entry
    dim psortedentry as sortedentry_ ptr = sortedlist->data
    dim psortedentryprev as sortedentry_ ptr = NIL
    dim newsortedentry as sortedentry_ ptr = sortedentry_create(key, value)
    if (psortedentry) then
      '' insert
      if (compare(psortedentry->key, key) > 0) then   '' before the first
        newsortedentry->next = sortedlist->data
        sortedlist->data = newsortedentry
      else
        while (psortedentry) 
          if (compare(psortedentry->key, key) < 0) then
            psortedentryprev = psortedentry
            psortedentry = psortedentry->next
          else 
            exit while
          end if
        wend
        psortedentryprev->next = newsortedentry
        newsortedentry->next = psortedentry
      end if
    else
      sortedlist->data = newsortedentry     '' first entry
    end if
    sortedlist->count += 1
  else 
    '' exist entry - overwrite
    dim psortedentry as sortedentry_ ptr = sortedlist->data
    while (compare(psortedentry->key, key)) 
      psortedentry = psortedentry->next
    wend
    psortedentry->value = value
  end if

end sub

function sortedlist_get(byval sortedlist as sortedlist_ ptr,byval key as symbol_ ptr) as any ptr '' Value

  dim psortedentry as sortedentry_ ptr = sortedlist->data
  while (psortedentry) 
    if (compare(psortedentry->key, key) = 0) then
      return psortedentry->value
    end if
    psortedentry = psortedentry->next
  wend
  return NIL

end function


function sortedlist_getkey(byval sortedlist as sortedlist_ ptr, byval index as integer) as any ptr'' Key

  if (0 <= index andalso index < sortedlist->count) then
    dim psortedentry as sortedentry_ ptr = sortedlist->data
    for i as integer = 0 to index - 1
      psortedentry = psortedentry->next
    next i
    return psortedentry->key
  else
    return NIL
  end if

end function

function sortedlist_itemat(byval sortedlist as sortedlist_ ptr, byval index as integer) as sortedentry_ ptr
  
  if (0 <= index andalso index < sortedlist->count) then
    dim psortedentry as sortedentry_ ptr = sortedlist->data
    for i as integer = 0 to index - 1
      psortedentry = psortedentry->next
    next i
    return psortedentry
  else
    return NIL
  end if

end function

''DFA
declare function dfa_create(byval parser as parser_ ptr) as dfa_ ptr
declare sub dfa_destroy(byref dfa as dfa_ ptr)
''TAB
declare function tab_create(byval parser as parser_ ptr) as tab_ ptr

''---------------------------------------------------------------------
''  Symbol list management
''---------------------------------------------------------------------
declare function tab_newsym(byval _tab as tab_ ptr, byval typ as integer, _
                            byval name_ as wchar_t ptr, byval line_ as integer) as symbol_ ptr
declare function tab_findsym(byval _tab as tab_ ptr,byval name_ as wchar_t ptr) as symbol_ ptr
declare function tab_num(byval _tab as tab_ ptr, byval p as node_ ptr) as integer
declare sub tab_printsym(byval _tab as tab_ ptr, byval sym as symbol_ ptr)
declare sub tab_printsymboltable(byval _tab as tab_ ptr)
declare sub tab_printset(byval _tab as tab_ ptr, byval s as bitarray_ ptr, byval indent as integer)

''---------------------------------------------------------------------
''  Syntax graph management
''---------------------------------------------------------------------
declare function tab_newnode(byval _tab as tab_ ptr, byval typ as integer, _
                             byval sym as symbol_ ptr, byval line_ as integer) as node_ ptr
declare function tab_newnode_node(byval _tab as tab_ ptr, byval typ as integer, byval sub_ as node_ ptr) as node_ ptr
declare function tab_newnode_val(byval _tab as tab_ ptr, byval typ as integer, _
                              byval val_ as integer, byval line_ as integer) as node_ ptr
declare sub tab_makefirstalt(byval _tab as tab_ ptr, byval g as graph_ ptr)
declare sub tab_makealternative(byval _tab as tab_ ptr, byval g1 as graph_ ptr, byval g2 as graph_ ptr)
declare sub tab_makesequence(byval _tab as tab_ ptr, byval g1 as graph_ ptr, byval g2 as graph_ ptr)
declare sub tab_makeiteration(byval _tab as tab_ ptr, byval g as graph_ ptr)
declare sub tab_makeoption(byval _tab as tab_ ptr, byval g as graph_ ptr)
declare sub tab_finish(byval _tab as tab_ ptr, byval g as graph_ ptr)
declare sub tab_deletenodes(byval _tab as tab_ ptr)
declare function tab_strtograph(byval _tab as tab_ ptr, byval str_ as wchar_t ptr) as graph_ ptr
declare sub tab_setcontexttrans(byval _tab as tab_ ptr, byval p as node_ ptr ) '' set transition code in the graph rooted at p

''------------ graph deletability check -----------------
declare function tab_delgraph(byval _tab as tab_ ptr, byval p as node_ ptr) as byte
declare function tab_delsubgraph(byval _tab as tab_ ptr, byval p as node_ ptr) as byte
declare function tab_delnode(byval _tab as tab_ ptr, byval p as node_ ptr) as byte

''----------------- graph printing ----------------------
declare function tab_ptr(byval _tab as tab_ ptr, byval p as node_ ptr, byval up as byte) as integer
declare function tab_pos(byval _tab as tab_ ptr, byval pos_ as position_ ptr) as wchar_t ptr
declare function tab_name(byval _tab as tab_ ptr, byval name_ as wchar_t ptr) as wchar_t ptr
declare sub tab_printnodes(byval _tab as tab_ ptr )

''---------------------------------------------------------------------
''  Character class management
''---------------------------------------------------------------------
declare function tab_newcharclass(byval _tab as tab_ ptr,  byval name_ as wchar_t ptr, byval s as charset_ ptr) as charclass_ ptr
declare function tab_findcharclass_wchar(byval _tab as tab_ ptr,  byval name_ as wchar_t ptr) as charclass_ ptr
declare function tab_findcharclass_charset(byval _tab as tab_ ptr, byval s as charset_ ptr) as charclass_ ptr
declare function tab_charclassset(byval _tab as tab_ ptr, byval i as integer) as charset_ ptr

''----------- character class printing

declare function tab_ch(byval _tab as tab_ ptr, byval ch as wchar_t) as wchar_t ptr
declare sub tab_writecharset(byval _tab as tab_ ptr, byval s as charset_ ptr)
declare sub tab_writecharclasses (byval _tab as tab_ ptr)

''---------------------------------------------------------------------
''  Symbol set computations
''---------------------------------------------------------------------

/' Computes the first set for the given Node. '/
declare function tab_first0(byval _tab as tab_ ptr, byval p as node_ ptr, byval mark as bitarray_ ptr) as bitarray_ ptr
declare function tab_first(byval _tab as tab_ ptr, byval p as node_ ptr) as bitarray_ ptr
declare sub tab_compfirstsets(byval _tab as tab_ ptr)
declare sub tab_compfollow(byval _tab as tab_ ptr, byval p as node_ ptr)
declare sub tab_complete(byval _tab as tab_ ptr, byval sym as symbol_ ptr)
declare sub tab_compfollowsets(byval _tab as tab_ ptr)
declare function tab_leadingany(byval _tab as tab_ ptr, byval p as node_ ptr) as node_ ptr
declare sub tab_findas(byval _tab as tab_ ptr, byval p as node_ ptr) '' find ANY sets
declare sub tab_companysets(byval _tab as tab_ ptr)
declare function tab_expected(byval _tab as tab_ ptr, byval p as node_ ptr, byval cursy as symbol_ ptr) as bitarray_ ptr
'' does not look behind resolvers; only called during LL(1) test and in CheckRes
declare function tab_expected0(byval _tab as tab_ ptr, byval p as node_ ptr, byval cursy as symbol_ ptr) as bitarray_ ptr
declare sub tab_compsync(byval _tab as tab_ ptr, byval p as node_ ptr)
declare sub tab_compsyncsets(byval _tab as tab_ ptr)
declare sub tab_setupanys(byval _tab as tab_ ptr)
declare sub tab_compdeletablesymbols(byval _tab as tab_ ptr)
declare sub tab_renumberpragmas(byval _tab as tab_ ptr)
declare sub tab_compsymbolsets(byval _tab as tab_ ptr)

''---------------------------------------------------------------------
''  String handling
''---------------------------------------------------------------------

declare function tab_hex2char(byval _tab as tab_ ptr, byval s as wchar_t ptr) as wchar_t
declare function tab_char2hex(byval _tab as tab_ ptr, byval ch as wchar_t) as wchar_t ptr
declare function tab_unescape(byval _tab as tab_ ptr, byval s as wchar_t ptr) as wchar_t ptr
declare function tab_escape(byval _tab as tab_ ptr, byval s as wchar_t ptr) as wchar_t ptr

''---------------------------------------------------------------------
''  Grammar checks
''---------------------------------------------------------------------
declare function tab_grammarok(byval _tab as tab_ ptr) as byte

  declare function tab_cnode_create(byval l as symbol_ ptr, byval r as symbol_ ptr) as cnode_ ptr
  declare sub tab_getsingles(byval _tab as tab_ ptr, byval p as node_ ptr, byval singles as arraylist_ ptr)
  declare function tab_nocircularproductions(byval _tab as tab_ ptr) as byte

  '''--------------- check for LL(1) errors ----------------------

  declare sub tab_ll1error(byval _tab as tab_ ptr, byval cond as integer, byval sym as symbol_ ptr)
  declare sub tab_checkoverlap(byval _tab as tab_ ptr, byval s1 as bitarray_ ptr, byval s2 as bitarray_ ptr, byval cond as integer)
  declare sub tab_checkalts(byval _tab as tab_ ptr, byval p as node_ ptr)
 declare sub tab_checkll1(byval _tab as tab_ ptr)

  '''------------- check if resolvers are legal  --------------------

  'declare sub tab_reserr(byval _tab as tab_ ptr, byval p as node_ ptr, byval msg as wchar_t ptr)
  declare sub tab_checkres(byval _tab as tab_ ptr, byval p as node_ ptr, byval rslvallowed as byte)
  declare sub tab_checkresolvers(byval _tab as tab_ ptr)

  '''------------- check if every nts has a production --------------------

  declare function tab_ntscomplete(byval _tab as tab_ ptr) as byte

  '''-------------- check if every nts can be reached  -----------------

  declare sub tab_markreachednts(byval _tab as tab_ ptr, byval p as node_ ptr)
 declare function tab_allntreached(byval _tab as tab_ ptr) as byte

  '''--------- check if every nts can be derived to terminals  ------------

  declare function tab_isterm(byval _tab as tab_ ptr, byval p as node_ ptr, byval mark as bitarray_ ptr) as byte '' true if graph can be derived to terminals
  declare function tab_allnttoterm(byval _tab as tab_ ptr) as byte

  '''---------------------------------------------------------------------
  ''  Cross reference list
  ''---------------------------------------------------------------------

  declare sub tab_xref(byval _tab as tab_ ptr)
  declare sub tab_setddt(byval _tab as tab_ ptr, byval s as wchar_t ptr)
  declare sub tab_setoption(byval _tab as tab_ ptr, byval s as wchar_t ptr)

''ACTION
declare function action_symbols(byval action as action_ ptr, byval _tab as tab_ ptr) as charset_ ptr
declare sub action_shiftwith(byval action as action_ ptr, byval s as charset_ ptr, byval tab as tab_ ptr)

function action_symbols(byval action as action_ ptr, byval _tab as tab_ ptr) as charset_ ptr
  
  dim s as charset_ ptr
  if (action->typ = node_.clas) then
    s = charset_clone(tab_charclassset(_tab,action->sym))
  else 
    s = charset_create()
    charset_set(s,action->sym)
  end if
  return s

end function

sub action_shiftwith(byval action as action_ ptr, byval s as charset_ ptr, byval _tab as tab_ ptr)

  if (charset_elements(s) = 1) then
    action->typ = node_.chr
    action->sym = charset_first(s)
  else 
    dim c as charclass_ ptr = tab_findcharclass_charset(_tab,s)
    if (c = NIL) then
      c = tab_newcharclass(_tab,@wstr(!"#"), s) '' class with dummy name
    end if
    action->typ = node_.clas
    action->sym = c->n
  end if

end sub

''PARSERGEN
#include "crt/ctype.bi"
'#include "ArrayList.bi"
'#include "ParserGen.bi"
'#include "Parser.bi"
'#include "BitArray.bi"
'#include "Scanner.bi"
'#include "Generator.bi"

declare function parsergen_create(byval parser as parser_ ptr) as parsergen_ ptr

''STUB
sub parsergen_destroy(byref parsergen as parsergen_ ptr)

  if (parsergen = NIL) then
    return
  end if
  deallocate(parsergen)

end sub

sub parsergen_indent(byval parsergen as parsergen_ ptr,byval n as integer)
  
  for i as integer = 1 to n
    fwprintf(parsergen->gen, @wstr(!"  "))
  next i

end sub

'' AW: use a switch if more than 5 alternatives and none starts with a resolver
function parsergen_useswitch(byval parsergen as parsergen_ ptr,byval p as node_ ptr) as byte
  
  if (p->typ <> node_.alt) then
    return 0
  end if
  dim nalts as integer = 0
  while (p <> NIL) 
    nalts += 1
    '' must not optimize with switch-statement, if alt uses a resolver expression
    if (p->sub_->typ = node_.rslv) then
      return 0
    end if
    p = p->down
  wend
  return nalts > 5

end function

function parsergen_gennamespaceopen(byval parsergen as parsergen_ ptr, byval nsname as wchar_t ptr) as integer
  
  if (nsname = NIL orelse coco_string_length(nsname) = 0) then
    return 0
  end if
  dim len_ as integer = coco_string_length(nsname)
  dim startpos as integer = 0
  dim nrofns as integer = 0
  do
    dim curlen as integer = coco_string_indexof(nsname + startpos, cast(wchar_t,asc(":")))
    if (curlen = -1) then
      curLen = len_ - startpos
    end if
    dim curns as wchar_t ptr = coco_string_create_il(nsname, startpos, curlen)
    fwprintf(parsergen->gen, @wstr(!"namespace %ls \n"), curns)
    coco_string_destroy(curns)
    startpos = startpos + curlen + 1
    nrofns += 1
  loop while (startpos < len_)
  return nrofns

end function

sub parsergen_gennamespaceclose(byval parsergen as parsergen_ ptr,byval nrofns as integer)
  
  ''AGS no namespaces
  'for i as integer = 0 to nrofns - 1
  '  fwprintf(parsergen->gen, @wstr(!"end namespace\n"))
  'next i

end sub

sub parsergen_copysourcepart(byval parsergen as parsergen_ ptr,byval pos_ as position_ ptr, byval indent as integer)
  '' Copy text described by pos from atg to gen
  ''FIXME
  dim as integer ch,i
  if (pos_ <> NIL) then
    parsergen->buffer->setpos_(parsergen->buffer,pos_->beg) 
    ch = parsergen->buffer->read_(parsergen->buffer)
    if (parsergen->tab->emitlines andalso pos_->line) then
      fwprintf(parsergen->gen, @wstr(!"\n#line %d \"%ls\"\n"), pos_->line, parsergen->tab->srcname)
    end if
    parsergen_indent(parsergen,indent)
    while (parsergen->buffer->getpos_(parsergen->buffer) <= pos_->end) 
      while (ch = parsergen->CR orelse ch = parsergen->LF) '' eol is either CR or CRLF or LF
        fwprintf(parsergen->gen, @wstr(!"\n"))
        parsergen_indent(parsergen,indent)
        if (ch = parsergen->CR) then 
          ch = parsergen->buffer->read_(parsergen->buffer) '' skip CR
        end if
        if (ch = parsergen->LF) then 
          ch = parsergen->buffer->read_(parsergen->buffer) '' skip LF
        end if
        i = 1
        while (i <= pos_->col_ andalso (ch = asc(" ") orelse ch = asc(!"\t")))
          '' skip blanks at beginning of line
          ch = parsergen->buffer->read_(parsergen->buffer)
          i += 1
        wend
        if (i <= pos_->col_) then 
          pos_->col_ = i - 1 '' heading TABs => not enough blanks
        end if
        if (parsergen->buffer->getpos_(parsergen->buffer) > pos_->end) then 
          goto done
        end if
      wend
      fwprintf(parsergen->gen, @wstr(!"%lc"), ch)
      ch = parsergen->buffer->read_(parsergen->buffer)
    wend
    done:
    if (indent > 0) then 
      fwprintf(parsergen->gen, @wstr(!"\n"))
    end if
  end if

end sub

sub parsergen_generrormsg(byval parsergen as parsergen_ ptr,byval errtyp as integer, byval sym as symbol_ ptr)
  
  parsergen->errornr += 1
  dim formatlen as const integer = 1000
  dim format_(0 to formatlen - 1) as wchar_t
  coco_swprintf(@format_(0), formatlen, @wstr(!"  case %d: s = coco_string_create(@wstr(!\""), parsergen->errornr)
  coco_string_merge(parsergen->err, @format_(0))
  if (errtyp = parsergen->terr) then
    if (sym->name[0] = asc("""")) then
      coco_swprintf(@format_(0), formatlen, @wstr(!"%ls expected"), tab_escape(parsergen->tab,sym->name))
      coco_string_merge(parsergen->err, @format_(0))
    else
      coco_swprintf(@format_(0), formatlen, @wstr(!"%ls expected"), sym->name)
      coco_string_merge(parsergen->err, @format_(0))
    end if
  elseif (errtyp = parsergen->alterr) then
    coco_swprintf(@format_(0), formatlen, @wstr(!"invalid %ls"), sym->name)
    coco_string_merge(parsergen->err, @format_(0))
  elseif (errtyp = parsergen->syncerr) then
    coco_swprintf(@format_(0), formatlen, @wstr(!"this symbol not expected in %ls"), sym->name)
    coco_string_merge(parsergen->err, @format_(0))
  end if
  coco_swprintf(@format_(0), formatlen, @wstr(!"\"))\n"))
  coco_string_merge(parsergen->err, @format_(0))

end sub

function parsergen_newcondset(byval parsergen as parsergen_ ptr,byval s as bitarray_ ptr) as integer

  for i as integer = 1 to parsergen->symset->count '' skip symSet[0] (reserved for union of SYNC sets)
    if (sets_equals(s, cast(bitarray_ ptr,arraylist_itemat(parsergen->symset,i)))) then
      return i
    end if
  next i
  arraylist_add(parsergen->symset,bitarray_clone(s))
  return parsergen->symset->count - 1

end function

sub parsergen_gencond(byval parsergen as parsergen_ ptr,byval s as bitarray_ ptr, byval p as node_ ptr)
  
  if (p->typ = node_.rslv) then
    parsergen_copysourcepart(parsergen,p->pos_, 0)
  else
    dim n as integer = sets_elements(s)
    if (n = 0) then
      fwprintf(parsergen->gen, @wstr(!"0")) '' happens if an ANY set matches no symbol
    elseif (n <= parsergen->maxterm) then
      dim sym as symbol_ ptr
      for i as integer = 0 to parsergen->tab->terminals->count - 1
        sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->terminals,i))
        if (bitarray_itemat(s,sym->n)) then
          fwprintf(parsergen->gen, @wstr(!"parser->la->kind = %d"), sym->n)
          n -= 1
          if (n > 0) then
            fwprintf(parsergen->gen, @wstr(!" orelse "))
          end if
        end if
      next i
    else
      fwprintf(parsergen->gen, @wstr(!"parser_startof(parser,%d)"), parsergen_newcondset(parsergen,s))
    end if
  end if

end sub

sub parsergen_putcaselabels(byval parsergen as parsergen_ ptr,byval s as bitarray_ ptr)
  ''FIXME fix: make sure case %d is followed by \ncase_%d: and make sure
  ''indentation is correct!
  dim sym as symbol_ ptr
  
  for i as integer = 0 to parsergen->tab->terminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->terminals,i))
    if (bitarray_itemat(s,sym->n)) then 
      fwprintf(parsergen->gen, @wstr("case %d: "), sym->n)
    end if
  next i

end sub

sub parsergen_gencode(byval parsergen as parsergen_ ptr,byval p as node_ ptr, _
                      byval indent as integer, byval ischecked as bitarray_ ptr)
  
  'FIXME
  dim p2 as node_ ptr
  dim s1 as bitarray_ ptr
  dim s2 as bitarray_ ptr
  
  while (p <> NIL)
    if (p->typ = node_.nt) then
      parsergen_indent(parsergen,indent)
      fwprintf(parsergen->gen, @wstr(!"parser_%ls(parser"), p->sym->name)
      if (p->sym->attrpos <> NIL) then
        fwprintf(parsergen->gen,@wstr(!","))
      end if
      parsergen_copysourcepart(parsergen,p->pos_, 0)
      fwprintf(parsergen->gen, @wstr(!")\n"))
    elseif (p->typ = node_.t) then
      parsergen_indent(parsergen,indent)
      '' assert: if isChecked[p->sym->n] is true, then isChecked contains only p->sym->n
      if (bitarray_itemat(ischecked,p->sym->n)) then
        fwprintf(parsergen->gen, @wstr(!"parser_get(parser)\n"))
      else 
        fwprintf(parsergen->gen, @wstr(!"parser_expect(parser,%d)\n"), p->sym->n)
      end if
    end if
    if (p->typ = node_.wt) then
      parsergen_indent(parsergen,indent)
      s1 = tab_expected(parsergen->tab,p->next_, parsergen->cursy)
      bitarray_or(s1,parsergen->tab->allsyncsets)
      fwprintf(parsergen->gen, @wstr(!"parser_expectweak(parser,%d, %d)\n"), p->sym->n, parsergen_newcondset(parsergen,s1))
    end if
    if (p->typ = node_.any_) then
      parsergen_indent(parsergen,indent)
      dim acc as integer = sets_elements(p->set)
      if (parsergen->tab->terminals->count = (acc + 1) orelse (acc > 0 andalso sets_equals(p->set, ischecked))) then
      '' either this ANY accepts any terminal (the + 1 = end of file), or exactly what's allowed here
        fwprintf(parsergen->gen, @wstr(!"parser_get(parser)\n"))
      else
        parsergen_generrormsg(parsergen,parsergen->alterr, parsergen->cursy)
        if (acc > 0) then
          fwprintf(parsergen->gen, @wstr(!"if ("))
          parsergen_gencond(parsergen,p->set, p)
          fwprintf(parsergen->gen, @wstr(!") then\n     parser_get(parser)\n  else\n    parser_synerr(parser,%d)\n  end if"), parsergen->errornr)
        else 
          fwprintf(parsergen->gen, @wstr(!"parser_synerr(parser,%d) '' ANY node that matches no symbol\n"), parsergen->errornr)
        end if
      end if
    end if
    if (p->typ = node_.eps) then    '' nothing
    end if
    if (p->typ = node_.rslv) then   '' nothing
    end if
    if (p->typ = node_.sem) then
      parsergen_copysourcepart(parsergen,p->pos_, indent)
    end if       
    ''FIXME
    if (p->typ = node_.sync) then
      parsergen_indent(parsergen,indent)
      parsergen_generrormsg(parsergen,parsergen->syncerr, parsergen->cursy)
      s1 = bitarray_clone(p->set)
      fwprintf(parsergen->gen, @wstr(!"while (0=("))
      parsergen_gencond(parsergen,s1, p)
      fwprintf(parsergen->gen, @wstr(!")) "))
      fwprintf(parsergen->gen, @wstr(!"parser_synerr(parser,%d):parser_get(parser)\n"), parsergen->errornr)
      fwprintf(parsergen->gen, @wstr(!"wend\n"))
      ''FIXME
    end if
    if (p->typ = node_.alt) then
      s1 = tab_first(parsergen->tab,p)
      dim equal as byte = sets_equals(s1, ischecked)
      dim useswitch as byte = parsergen_useswitch(parsergen,p)
      if (useswitch) then
        parsergen_indent(parsergen,indent)
        fwprintf(parsergen->gen, @wstr(!"select case as const (parser->la->kind)\n"))
      end if
      p2 = p
      while (p2 <> NIL)
        s1 = tab_expected(parsergen->tab,p2->sub_, parsergen->cursy)
        parsergen_indent(parsergen,indent)
        if (useswitch) then
          parsergen_putcaselabels(parsergen,s1)
          fwprintf(parsergen->gen, @wstr(!"\n"))
        elseif (p2 = p) then
          fwprintf(parsergen->gen, @wstr(!"if ("))
          parsergen_gencond(parsergen,s1, p2->sub_)
          fwprintf(parsergen->gen, @wstr(!") then\n"))
        elseif (p2->down = NIL andalso equal) then
          fwprintf(parsergen->gen, @wstr(!"else \n"))
        else 
          fwprintf(parsergen->gen, @wstr(!"elseif ("))
          parsergen_gencond(parsergen,s1, p2->sub_)
          fwprintf(parsergen->gen,@wstr(!") then\n"))
        end if
        parsergen_gencode(parsergen,p2->sub_, indent + 1, s1)
        ''FIXME?
        if (useswitch) then
          parsergen_indent(parsergen,indent)
          fwprintf(parsergen->gen, @wstr(!"\n"))
          parsergen_indent(parsergen,indent)
          fwprintf(parsergen->gen, @wstr(!"\n"))
        end if
        p2 = p2->down
      wend
      parsergen_indent(parsergen,indent)
      if (equal) then
        fwprintf(parsergen->gen, @wstr(!"\n"))
      else 
        parsergen_generrormsg(parsergen,parsergen->alterr, parsergen->cursy)
        if (useswitch) then
          fwprintf(parsergen->gen, @wstr(!"case else:parser_synerr(parser,%d)\n"), parsergen->errornr)
          parsergen_indent(parsergen,indent)
          fwprintf(parsergen->gen, @wstr(!"end select\n"))
        else 
          fwprintf(parsergen->gen, @wstr(!"else\n      parser_synerr(parser,%d)\n"), parsergen->errornr)
          fwprintf(parsergen->gen,@wstr(!"    end if\n"))
        end if
      end if
    end if
    if (p->typ = node_.iter) then
      parsergen_indent(parsergen,indent)
      p2 = p->sub_
      fwprintf(parsergen->gen, @wstr(!"while ("))
      if (p2->typ = node_.wt) then
        s1 = tab_expected(parsergen->tab,p2->next_, parsergen->cursy)
        s2 = tab_expected(parsergen->tab,p->next_, parsergen->cursy)
        fwprintf(parsergen->gen, @wstr(!"parser_weakseparator(parser,%d,%d,%d) "), _
                 p2->sym->n, parsergen_newcondset(parsergen,s1), _
                 parsergen_newcondset(parsergen,s2))
        s1 = bitarray_create(parsergen->tab->terminals->count,0)  '' for inner structure
        if (p2->up orelse p2->next_ = NIL) then
          p2 = NULL
        else 
          p2 = p2->next_
        end if
      else
        s1 = tab_first(parsergen->tab,p2)
        parsergen_gencond(parsergen,s1, p2)
      end if
      fwprintf(parsergen->gen, @wstr(!")\n"))
      parsergen_gencode(parsergen,p2, indent + 1, s1)
      parsergen_indent(parsergen,indent)
      fwprintf(parsergen->gen, @wstr(!"wend\n"))
    end if
    if (p->typ = node_.opt) then
      s1 = tab_first(parsergen->tab,p->sub_)
      parsergen_indent(parsergen,indent)
      fwprintf(parsergen->gen, @wstr(!"if ("))
      parsergen_gencond(parsergen,s1, p->sub_)
      fwprintf(parsergen->gen, @wstr(!") then\n"))
      parsergen_gencode(parsergen,p->sub_, indent + 1, s1)
      parsergen_indent(parsergen,indent)
      fwprintf(parsergen->gen, @wstr(!"end if\n"))
    end if
    if (p->typ <> node_.eps andalso p->typ <> node_.sem andalso p->typ <> node_.sync) then
      bitarray_setall(ischecked,0)  '' = new BitArray(Symbol.terminals.Count);
    end if
    if (p->up) then
      exit while
    end if
    p = p->next_
  wend

end sub


sub parsergen_gentokensheader(byval parsergen as parsergen_ ptr)
  
  dim sym as symbol_ ptr
  dim i as integer
  
  dim isfirst as byte = 1

  fwprintf(parsergen->gen, @wstr(!"  enum \n"))

  '' tokens
  for i as integer = 0 to parsergen->tab->terminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->terminals,i))
    if (isalpha(sym->name[0]) = 0) then
      continue for
    end if
    if (isfirst) then
      isfirst = 0
    else 
      fwprintf(parsergen->gen , @wstr(!",\n"))
    end if

    fwprintf(parsergen->gen , @wstr(!"    _%ls=%d"), sym->name, sym->n)
  next i

  '' pragmas
  for i as integer = 0 to parsergen->tab->pragmas->count - 1
    if (isfirst) then
      isfirst = 0
    else 
      fwprintf(parsergen->gen, @wstr(!",\n"))
    end if
    sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->pragmas,i))
    fwprintf(parsergen->gen, @wstr(!"    _%ls=%d"), sym->name, sym->n)
  next i

  fwprintf(parsergen->gen, @wstr(!"\n  end enum\n"))

end sub

sub parsergen_gencodepragmas(byval parsergen as parsergen_ ptr)

  dim sym as symbol_ ptr
  
  for i as integer = 0 to parsergen->tab->pragmas->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->pragmas,i))
    fwprintf(parsergen->gen, @wstr(!"    if (parser->la->kind = %d) then\n"), sym->n)
    parsergen_copysourcepart(parsergen,sym->sempos, 4)
    fwprintf(parsergen->gen, @wstr(!"    end if\n"))
  next i

end sub

sub parsergen_genproductionsheader(byval parsergen as parsergen_ ptr)
  
  dim sym as symbol_ ptr
  
  for i as integer = 0 to parsergen->tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->nonterminals,i))
    parsergen->cursy = sym
    fwprintf(parsergen->gen, @wstr(!"  declare sub parser_%ls(byval parser as parser_ ptr"), sym->name)
    ''add a comma to argumentlist: (byval parser as parser_ ptr,
    if (sym->attrpos <> NIL) then
      fwprintf(parsergen->gen,@wstr(","))
    end if
    parsergen_copysourcepart(parsergen,sym->attrpos, 0)
    fwprintf(parsergen->gen, @wstr(!")\n"))
  next i

end sub

sub parsergen_genproductions(byval parsergen as parsergen_ ptr)

  dim sym as symbol_ ptr 
  for i as integer = 0 to parsergen->tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->nonterminals,i))
    parsergen->cursy = sym
    fwprintf(parsergen->gen, @wstr(!"sub parser_%ls(byval parser as parser_ ptr"), sym->name)
    ''parser procedure has attributes: append , to  byval parser as parser_ ptr
    if (sym->attrpos <> NIL) then
      fwprintf(parsergen->gen,@wstr(","))
    end if
    parsergen_copysourcepart(parsergen,sym->attrpos, 0)
    fwprintf(parsergen->gen, @wstr(!") \n\n"))
    parsergen_copysourcepart(parsergen,sym->sempos, 2)
    parsergen_gencode(parsergen,sym->graph, 2, bitarray_create(parsergen->tab->terminals->count,0))
    fwprintf(parsergen->gen, @wstr(!"\nend sub\n"))
    fwprintf(parsergen->gen, @wstr(!"\n"))
  next i

end sub

sub parsergen_initsets(byval parsergen as parsergen_ ptr)
  
  fwprintf(parsergen->gen, @wstr(!"\static set(0 to %d,0 to %d) as ubyte => {_\n"), _
           parsergen->symset->count - 1, parsergen->tab->terminals->count)

  for i as integer = 0 to parsergen->symset->count - 1
    dim s as bitarray_ ptr = cast(bitarray_ ptr,arraylist_itemat(parsergen->symset,i))
    fwprintf(parsergen->gen, @wstr(!"    {"))
    var j = 0
    dim sym as symbol_ ptr
    for k as integer = 0 to parsergen->tab->terminals->count - 1
      sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->terminals,k))
      if (bitarray_itemat(s,sym->n)) then
        fwprintf(parsergen->gen, @wstr(!"T,"))
      else 
        fwprintf(parsergen->gen, @wstr(!"x,"))
      end if
      j += 1
      if (j mod 4 = 0) then
        fwprintf(parsergen->gen, @wstr(" "))
      end if
    next k
    if (i = parsergen->symset->count-1) then
      fwprintf(parsergen->gen, @wstr(!"x}_\n"))
    else 
      fwprintf(parsergen->gen, @wstr(!"x},_\n"))
    end if    
  next i
  fwprintf(parsergen->gen, @wstr(!"  }\n\n"))

end sub

sub parsergen_writeparser (byval parsergen as parsergen_ ptr)
  
  dim g as generator_ ptr = generator_create(parsergen->tab, parsergen->errors)
  dim oldpos as integer = parsergen->buffer->getpos_(parsergen->buffer)  '' Pos is modified by CopySourcePart
  arraylist_add(parsergen->symset,parsergen->tab->allsyncsets)

  parsergen->fram = generator_openframe(g,@wstr("Parser.frame"))
  parsergen->gen = generator_opengen(g,@wstr("Parser.bi"))

  dim sym as symbol_ ptr
  
  for i as integer = 0 to parsergen->tab->terminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(parsergen->tab->terminals,i))
    parsergen_generrormsg(parsergen,parsergen->terr, sym)
  next i

  generator_copyright(g)
  generator_skipframepart(g,@wstr("-->begin"))
  generator_copyframepart(g,@wstr("-->headerdef"))

  if (parsergen->usingpos <> NIL) then
    parsergen_copysourcepart(parsergen,parsergen->usingpos, 0)
    fwprintf(parsergen->gen, @wstr(!"\n"))
  end if
  generator_copyframepart(g,@wstr("-->namespace_open"))
  dim nrofns as integer = parsergen_gennamespaceopen(parsergen,parsergen->tab->nsname)

  generator_copyframepart(g,@wstr("-->constantsheader"))
  parsergen_gentokensheader(parsergen)  /' ML 2002/09/07 write the token kinds '/
  fwprintf(parsergen->gen, @wstr(!"  dim maxt as integer\n"))
  generator_copyframepart(g,@wstr("-->declarations"))
  parsergen_copysourcepart(parsergen,parsergen->tab->semdeclpos, 0)
  generator_copyframepart(g,@wstr("-->productionsheader"))
  parsergen_genproductionsheader(parsergen)
  generator_copyframepart(g,@wstr("-->namespace_close"))
  parsergen_gennamespaceclose(parsergen,nrofns)

  generator_copyframepart(g,@wstr("-->implementation"))
  fclose(parsergen->gen)

  '' Source
  parsergen->gen = generator_opengen(g,@wstr("Parser.bas"))

  generator_copyright(g)
  generator_skipframepart(g,@wstr("-->begin"))
  generator_copyframepart(g,@wstr("-->namespace_open"))
  ''TODO namespaces are not supported (parsergen_gennamespaceopen is a stub)
  nrofns = parsergen_gennamespaceopen(parsergen,parsergen->tab->nsname)

  generator_copyframepart(g,@wstr("-->pragmas"))
  parsergen_gencodepragmas(parsergen)
  generator_copyframepart(g,@wstr("-->productions"))
  parsergen_genproductions(parsergen)
  generator_copyframepart(g,@wstr("-->parseroot"))
  fwprintf(parsergen->gen, @wstr(!"  parser_%ls(parser)\n"), parsergen->tab->gramsy->name)
  if (parsergen->tab->checkeof) then
    fwprintf(parsergen->gen, @wstr(!"  parser_expect(parser,0)"))
  end if
  generator_copyframepart(g,@wstr("-->constants"))
  fwprintf(parsergen->gen, @wstr(!"  parser->maxt = %d\n"), parsergen->tab->terminals->count-1)
  generator_copyframepart(g,@wstr("-->initialization"))
  parsergen_initsets(parsergen)
  generator_copyframepart(g,@wstr("-->errors"))
  fwprintf(parsergen->gen, @wstr(!"%ls"), parsergen->err)
  generator_copyframepart(g,@wstr("-->namespace_close"))
  parsergen_gennamespaceclose(parsergen,nrofns)
  generator_copyframepart(g,NIL)
  fclose(parsergen->gen)
  parsergen->buffer->setpos_(parsergen->buffer,oldpos)

end sub


sub parsergen_writestatistics (byval parsergen as parsergen_ ptr)
  
  fwprintf(parsergen->trace, @wstr(!"\n"))
  fwprintf(parsergen->trace, @wstr(!"%d terminals\n"), parsergen->tab->terminals->count)
  fwprintf(parsergen->trace, @wstr(!"%d symbols\n"), parsergen->tab->terminals->count + _
                                              parsergen->tab->pragmas->count + _
                                              parsergen->tab->nonterminals->count)
  fwprintf(parsergen->trace, @wstr(!"%d nodes\n"), parsergen->tab->nodes->count)
  fwprintf(parsergen->trace, @wstr(!"%d sets\n"), parsergen->symset->count)

end sub


function parsergen_create(byval parser as parser_ ptr) as parsergen_ ptr
  
  dim parsergen as parsergen_ ptr
  parsergen = callocate(1,sizeof(parsergen_))
  parsergen->maxterm = 3
  parsergen->CR = asc(!"\r")
  parsergen->LF = asc(!"\n")
  parsergen->terr = 0
  parsergen->alterr = 1
  parsergen->syncerr = 2
  parsergen->tab = parser->tab
  parsergen->errors = parser->errors
  parsergen->trace = parser->trace
  parsergen->buffer = parser->scanner->buffer
  parsergen->errornr = -1
  parsergen->usingpos = NIL

  parsergen->symset = arraylist_create()
  parsergen->err = NIL
  return parsergen
  
end function

#include once "crt/wchar.bi"
'#include "Tab.bi"
'#include "Parser.bi"
'#include "BitArray.bi"
'#include "Scanner.bi"


function tab_create(byval parser as parser_ ptr) as tab_ ptr
  
  dim _tab as tab_ ptr
  _tab = callocate(1,sizeof(tab_))
  
  for i as integer = 0 to 9
    _tab->ddt(i) = 0
  next i

  _tab->terminals = arraylist_create()
  _tab->pragmas = arraylist_create()
  _tab->nonterminals = arraylist_create()
  _tab->nodes = arraylist_create()
  _tab->dummynode = NIL
  _tab->classes= arraylist_create()
  _tab->dummyname = asc("A")

  _tab->parser = parser
  _tab->trace = parser->trace
  _tab->errors = parser->errors
  _tab->eofsy = tab_newsym(_tab,node_.t, @wstr("EOF"), 0)
  _tab->dummynode = tab_newnode(_tab,node_.eps, cast(symbol_ ptr,NIL), 0)
  _tab->literals = hashtable_create()
  _tab->checkeof = 1
  return _tab
  
end function

'STUB
sub tab_destroy(byref _tab as tab_ ptr)

end sub

function tab_newsym(byval _tab as tab_ ptr, byval typ as integer, _
                    byval name_ as wchar_t ptr, byval line_ as integer) as symbol_ ptr
  
  if (coco_string_length(name_) = 2 andalso name_[0] = asc("""")) then
    parser_semerr(_tab->parser,@wstr(!"empty token not allowed"))
    name_ = coco_string_create(@wstr(!"???"))
  end if
  dim sym as symbol_ ptr = symbol_create(typ, name_, line_)

  if (typ = node_.t) then
    sym->n = _tab->terminals->count
    arraylist_add(_tab->terminals,sym)
  elseif (typ = node_.pr) then
    arraylist_add(_tab->pragmas,sym)
  elseif (typ = node_.nt) then
    sym->n = _tab->nonterminals->count
    arraylist_add(_tab->nonterminals,sym)
  end if

  return sym

end function


function tab_findsym(byval _tab as tab_ ptr,byval name_ as wchar_t ptr) as symbol_ ptr
  
  dim s as symbol_ ptr
  
  for i as integer = 0 to _tab->terminals->count - 1
    s = cast(symbol_ ptr,arraylist_itemat(_tab->terminals,i))
    if (coco_string_equal(s->name, name_)) then
      return s
    end if
  next i
  for i as integer = 0 to _tab->nonterminals->count - 1
    s = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    if (coco_string_equal(s->name, name_)) then
      return s
    end if
  next i
  return NIL

end function

function tab_num(byval _tab as tab_ ptr, byval p as node_ ptr) as integer
  
  if (p = NIL) then
    return 0
  else 
    return p->n
  end if

end function

sub tab_printsym(byval _tab as tab_ ptr, byval sym as symbol_ ptr)
  
  dim paddedname as wchar_t ptr = tab_name(_tab,sym->name)
  fwprintf(_tab->trace, @wstr(!"%3d %14s %ls"), sym->n, paddedname, _tab->ntyp(sym->typ))
  coco_string_destroy(paddedname)

  if (sym->attrpos = NIL) then
    fwprintf(_tab->trace, @wstr(!" 0 "))
  else
    fwprintf(_tab->trace, @wstr(!" 1  "))
  end if
  if (sym->typ = node_.nt) then
    fwprintf(_tab->trace, @wstr(!"%5d"), tab_num(_tab,sym->graph))
    if (sym->deletable) then
      fwprintf(_tab->trace, @wstr(!" 1  "))
    else 
      fwprintf(_tab->trace, @wstr(!" 0 "))
    end if
  else
    fwprintf(_tab->trace, @wstr(!"            "))
  end if
    

  fwprintf(_tab->trace, @wstr(!"%5d %ls\n"), sym->line, _tab->tkind(sym->tokenkind))

end sub

sub tab_printsymboltable(byval _tab as tab_ ptr)
  
  fwprintf(_tab->trace, @wstr(!"Symbol Table:\n"))
  fwprintf(_tab->trace, @wstr(!"------------\n\n"))
  fwprintf(_tab->trace, @wstr(!" nr name          typ  hasAt graph  del    line tokenKind\n"))

  dim sym as symbol_ ptr
  dim i as integer
  
  for i = 0 to _tab->terminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->terminals,i))
    tab_printsym(_tab,sym)
  next i
  
  for i = 0 to _tab->pragmas->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->pragmas,i))
    tab_printsym(_tab,sym)
  next i
  
  for i =0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    tab_printsym(_tab,sym)
  next i


  fwprintf(_tab->trace, @wstr(!"\nLiteral Tokens:\n"))
  fwprintf(_tab->trace, @wstr(!"--------------\n"))

  var iter = hashtable_getiterator(_tab->literals)
  while (iter_hasnext(iter))
    var e = iter_next(iter)
    fwprintf(_tab->trace, @wstr(!"_%ls =  %ls.\n"), (cast(symbol_ ptr,e->value))->name, e->key)
  wend
  fwprintf(_tab->trace, @wstr(!"\n"))

end sub

sub tab_printset(byval _tab as tab_ ptr, byval s as bitarray_ ptr, byval indent as integer)
  
  dim col  as integer
  dim len_ as integer
  col = indent
  dim sym as symbol_ ptr
  for i as integer = 0 to _tab->terminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->terminals,i))
    if (bitarray_itemat(s,sym->n)) then
      len_ = coco_string_length(sym->name)
      if (col + len_ >= 80) then
        fwprintf(_tab->trace, @wstr(!"\n"))
        for col = 1 to indent - 1
          fwprintf(_tab->trace, @wstr(!" "))
        next col
      end if
      fwprintf(_tab->trace, @wstr(!"%ls "), sym->name)
      col += len_ + 1
    end if
  next i
  if (col = indent) then
    fwprintf(_tab->trace, @wstr(!"-- empty set --"))
  end if
  fwprintf(_tab->trace, @wstr(!"\n"))

end sub

'''---------------------------------------------------------------------
'''  Syntax graph management
'''---------------------------------------------------------------------

function tab_newnode(byval _tab as tab_ ptr, byval typ as integer, _
                     byval sym as symbol_ ptr, byval line_ as integer) as node_ ptr
  
  var node = node_create(typ, sym, line_)
  node->n = _tab->nodes->count
  arraylist_add(_tab->nodes,node)
  return node

end function


function tab_newnode_node(byval _tab as tab_ ptr, byval typ as integer, byval sub_ as node_ ptr) as node_ ptr
  
  dim node as node_ ptr = tab_newnode(_tab,typ, cast(symbol_ ptr,NIL), 0)
  node->sub_ = sub_
#ifdef DEBUG
  wprintf(@wstr(!"sub_ = %d"),sub_)
#endif
  return node
  
end function

function tab_newnode_val(byval _tab as tab_ ptr, byval typ as integer, _
                         byval val_ as integer, byval line_ as integer) as node_ ptr
  
  dim node as node_ ptr = tab_newnode(_tab,typ, cast(symbol_ ptr,NIL), line_)
  node->val_ = val_
  return node

end function


sub tab_makefirstalt(byval _tab as tab_ ptr, byval g as graph_ ptr)

#ifdef DEBUG
  wprintf(@wstr(!"g->l %d\n"),g->l)  
#endif
  g->l = tab_newnode_node(_tab,node_.alt, g->l)
#ifdef DEBUG
  if (g->l->sub_ = NIL) then
    wprintf(@wstr("g->l->sub_ = NIL!!!"))
    end
  end if
#endif
  g->l->line_ = g->l->sub_->line_
  g->r->up = 1
  g->l->next_ = g->r
  g->r = g->l

end sub
'
''' The result will be in g1
sub tab_makealternative(byval _tab as tab_ ptr, byval g1 as graph_ ptr, byval g2 as graph_ ptr)
  
  g2->l = tab_newnode_node(_tab,node_.alt, g2->l)
  g2->l->line_ = g2->l->sub_->line_
  g2->l->up = 1
  g2->r->up = 1
  var p = g1->l
  while (p->down <> NIL) 
    p = p->down
  wend
  p->down = g2->l
  p = g1->r
  while (p->next_ <> NIL) 
    p = p->next_
  wend
  '' append alternative to g1 end list
  p->next_ = g2->l
  '' append g2 end list to g1 end list
  g2->l->next_ = g2->r

end sub

''' The result will be in g1
sub tab_makesequence(byval _tab as tab_ ptr, byval g1 as graph_ ptr, byval g2 as graph_ ptr)
  
  var p = g1->r->next_
  g1->r->next_ = g2->l '' link head node
  while (p <> NIL)   '' link substructure
    var q = p->next_
    p->next_ = g2->l
    p = q
  wend
  g1->r = g2->r

end sub

sub tab_makeiteration(byval _tab as tab_ ptr, byval g as graph_ ptr)
  
  g->l = tab_newnode_node(_tab,node_.iter, g->l)
  g->r->up = 1
  var p = g->r
  g->r = g->l
  while (p <> NIL) 
    var q = p->next_
    p->next_ = g->l
    p = q
  wend

end sub

sub tab_makeoption(byval _tab as tab_ ptr, byval g as graph_ ptr)
  
  g->l = tab_newnode_node(_tab,node_.opt, g->l)
  g->r->up = 1
  g->l->next_ = g->r
  g->r = g->l

end sub

sub tab_finish(byval _tab as tab_ ptr, byval g as graph_ ptr)
  
  var p = g->r
  while (p <> NIL) 
    var q = p->next_
    p->next_ = NIL
    p = q
  wend

end sub

sub tab_deletenodes(byval _tab as tab_ ptr)
  
  _tab->nodes = arraylist_create()
  _tab->dummynode = tab_newnode(_tab,node_.eps, cast(symbol_ ptr,NIL), 0)

end sub

function tab_strtograph(byval _tab as tab_ ptr, byval str_ as wchar_t ptr) as graph_ ptr
  
  DWPRINTFUN
#ifdef DEBUG
  wprintf(@wstr(!"str_ = %ls\n"),str_)
#endif
  var substr = coco_string_create_il(str_, 1, coco_string_length(str_)-2)
#ifdef DEBUG
  wprintf(@wstr(!"substr = %ls\n"),substr)
#endif
  var s = tab_unescape(_tab,substr)
  coco_string_destroy(substr)
  if (coco_string_length(s) = 0) then
    parser_semerr(_tab->parser,@wstr("empty token not allowed"))
  end if
  var g = graph_create()
  g->r = _tab->dummynode
  for i as integer = 0 to coco_string_length(s) - 1
    var p = tab_newnode_val(_tab,node_.chr, cast(integer,s[i]), 0)
    g->r->next_ = p
    g->r = p
  next i
  g->l = _tab->dummynode->next_
  _tab->dummynode->next_ = NIL
  coco_string_destroy(s)
  DWPRINTFUNE:return g
  
DWPRINTFUNE:end function


sub tab_setcontexttrans(byval _tab as tab_ ptr, byval p as node_ ptr ) '' set transition code in the graph rooted at p
  
  while (p <> NIL) 
    if (p->typ = node_.chr orelse p->typ = node_.clas) then
      p->code = node_.contextTrans
    elseif (p->typ = node_.opt orelse p->typ = node_.iter) then
      tab_setcontexttrans(_tab,p->sub_)
    elseif (p->typ = node_.alt) then
      tab_setcontexttrans(_tab,p->sub_)
      tab_setcontexttrans(_tab,p->down)
    end if
    if (p->up) then
      exit while
    end if
    p = p->next_
  wend

end sub

'''------------ graph deletability check -----------------
'
function tab_delgraph(byval _tab as tab_ ptr, byval p as node_ ptr) as byte
  
  return p = NIL orelse (tab_delnode(_tab,p) andalso tab_delgraph(_tab,p->next_))

end function

function tab_delsubgraph(byval _tab as tab_ ptr, byval p as node_ ptr) as byte
  
  return p = NIL orelse (tab_delnode(_tab,p) andalso (p->up orelse tab_delsubgraph(_tab,p->next_)))

end function

function tab_delnode(byval _tab as tab_ ptr, byval p as node_ ptr) as byte
  
  if (p->typ = node_.nt) then
    return p->sym->deletable
  elseif (p->typ = node_.alt) then
    return tab_delsubgraph(_tab,p->sub_) orelse (p->down <> NIL andalso tab_delsubgraph(_tab,p->down))
  else 
    return p->typ = node_.iter orelse p->typ = node_.opt orelse p->typ = node_.sem _    
          orelse p->typ = node_.eps orelse p->typ = node_.rslv orelse p->typ = node_.sync
  end if

end function
'
'''----------------- graph printing ----------------------
'
function tab_ptr(byval _tab as tab_ ptr, byval p as node_ ptr, byval up as byte) as integer
  
  if (p = NIL) then
    return 0
  elseif (up) then
    return -(p->n)
  else
    return p->n
  end if

end function

function tab_pos(byval _tab as tab_ ptr, byval pos_ as position_ ptr) as wchar_t ptr
  
  var format_ = callocate(10,sizeof(wchar_t))
  if (pos_ = NIL) then
    coco_swprintf(format_, 10, @wstr(!"     "))
  else
    coco_swprintf(format_, 10, @wstr(!"%5d"), pos_->beg)
  end if
  return format_

end function

function tab_name(byval _tab as tab_ ptr, byval name_ as wchar_t ptr) as wchar_t ptr
  
  var name2 = coco_string_create_appendws(name_, @wstr(!"           "))
  var subname2 = coco_string_create_il(name2, 0, 12)
  coco_string_destroy(name2)
  return subName2
  '' found no simpler way to get the first 12 characters of the name
  '' padded with blanks on the right

end function

sub tab_printnodes(byval _tab as tab_ ptr )
  
  fwprintf(_tab->trace, @wstr(!"Graph nodes:\n"))
  fwprintf(_tab->trace, @wstr(!"----------------------------------------------------\n"))
  fwprintf(_tab->trace, @wstr(!"   n type name          next  down   sub   pos  line\n"))
  fwprintf(_tab->trace, @wstr(!"                               val  code\n"))
  fwprintf(_tab->trace, @wstr(!"----------------------------------------------------\n"))

  dim p as node_ ptr
  for i as integer = 0 to _tab->nodes->count - 1
    p = cast(node_ ptr,arraylist_itemat(_tab->nodes,i))
    fwprintf(_tab->trace, @wstr(!"%4d %ls "), p->n, _tab->ntyp(p->typ))
    if (p->sym <> NIL) then
      var paddedname = tab_name(_tab,p->sym->name)
      fwprintf(_tab->trace, @wstr(!"%12s "), paddedname)
      coco_string_destroy(paddedname)
    elseif (p->typ = node_.clas) then
      var c = cast(charclass_ ptr,arraylist_itemat(_tab->classes,p->val_))
      var paddedname = tab_name(_tab,c->name)
      fwprintf(_tab->trace, @wstr(!"%12s "), paddedname)
      coco_string_destroy(paddedname)
    else 
      fwprintf(_tab->trace, @wstr(!"             "))
    end if
    fwprintf(_tab->trace, @wstr(!"%5d "), tab_ptr(_tab,p->next_, p->up))

    if (p->typ = node_.t orelse p->typ = node_.nt orelse p->typ = node_.wt) then
      fwprintf(_tab->trace, @wstr(!"             %5s"), tab_pos(_tab,p->pos_))
    end if
    if (p->typ = node_.chr) then
      fwprintf(_tab->trace, @wstr(!"%5d %5d       "), p->val_, p->code)
    end if
    if (p->typ = node_.clas) then
      fwprintf(_tab->trace, @wstr(!"      %5d       "), p->code)
    end if
    if (p->typ = node_.alt orelse p->typ = node_.iter orelse p->typ = node_.opt) then
      fwprintf(_tab->trace, @wstr(!"%5d %5d       "), tab_ptr(_tab,p->down, 0), tab_ptr(_tab,p->sub_, 0))
    end if
    if (p->typ = node_.sem) then
      fwprintf(_tab->trace, @wstr(!"             %5s"), tab_pos(_tab,p->pos_))
    end if
    if (p->typ = node_.eps orelse p->typ = node_.any_ orelse p->typ = node_.sync) then
      fwprintf(_tab->trace, @wstr(!"                  "))
    end if
    fwprintf(_tab->trace, @wstr(!"%5d\n"), p->line_)
  next i
  fwprintf(_tab->trace, @wstr(!"\n"))

end sub

'''---------------------------------------------------------------------
'''  Character class management
'''---------------------------------------------------------------------
function tab_newcharclass(byval _tab as tab_ ptr,  byval name_ as wchar_t ptr, byval s as charset_ ptr) as charclass_ ptr
  
  dim c as charclass_ ptr
  if (coco_string_equal(name_, @wstr(!"#"))) then
    var temp = coco_string_create_appendwc(name_, cast(wchar_t,_tab->dummyname))
    _tab->dummyname += 1
    c = charclass_create(temp, s)
    coco_string_destroy(temp)
  else 
    c = charclass_create(name_, s)
  end if
  c->n = _tab->classes->count
  arraylist_add(_tab->classes,c)
  return c

end function

function tab_findcharclass_wchar(byval _tab as tab_ ptr,  byval name_ as wchar_t ptr) as charclass_ ptr

  dim c as charclass_ ptr
  for i as integer = 0 to _tab->classes->count - 1
    c = cast(charclass_ ptr,arraylist_itemat(_tab->classes,i))
    if (coco_string_equal(c->name, name_)) then
      return c
    end if
  next i
  return NIL

end function

function tab_findcharclass_charset(byval _tab as tab_ ptr, byval s as charset_ ptr) as charclass_ ptr
  
  dim c as charclass_ ptr
  for i as integer = 0 to _tab->classes->count - 1
    c = cast(charclass_ ptr,arraylist_itemat(_tab->classes,i))
    if (charset_equals(s,c->set)) then
      return c
    end if
  next i
  return NIL

end function

function tab_charclassset(byval _tab as tab_ ptr, byval i as integer) as charset_ ptr
  
  return (cast(charclass_ ptr,arraylist_itemat(_tab->classes,i))->set)

end function
'
'''----------- character class printing
function tab_ch(byval _tab as tab_ ptr, byval ch as wchar_t) as wchar_t ptr
  
  var format_ = callocate(10,sizeof(wchar_t))
  if (ch < asc(" ") orelse ch >= 127 orelse ch = asc(!"\'") orelse ch = asc(!"\\")) then
    coco_swprintf(format_, 10, @wstr(!"%d"), ch)
    return format_
  else
    coco_swprintf(format_, 10, @wstr(!"\'%lc\'"), ch)
    return format_
  end if

end function

sub tab_writecharset(byval _tab as tab_ ptr, byval s as charset_ ptr)
  
  var r = s->head
  while (r <> NIL)
    if (r->from < r->to) then
      var from_ = tab_ch(_tab,r->from)
      var to_ = tab_ch(_tab,r->to)
      fwprintf(_tab->trace, @wstr(!"%ls .. %ls "), from_, to_)
      deallocate(from_)
      deallocate(to_)
    else 
      var from_ = tab_ch(_tab,r->from)
      fwprintf(_tab->trace, @wstr(!"%ls "), from_)
      deallocate(from_)
    end if
    r = r->next
  wend

end sub

sub tab_writecharclasses (byval _tab as tab_ ptr)
  
  dim c as charclass_ ptr
  
  for i as integer = 0 to _tab->classes->count - 1
    
    c = cast(charclass_ ptr,arraylist_itemat(_tab->classes,i))

    var format2 = coco_string_create_appendws(c->name, @wstr(!"            "))
    var format_  = coco_string_create_il(format2, 0, 10)
    coco_string_merge(format_, @wstr(!": "))
    fwprintf(_tab->trace, format_)

    tab_writecharset(_tab,c->set)
    fwprintf(_tab->trace, @wstr(!"\n"))
    coco_string_destroy(format_)
    coco_string_destroy(format2)
  next i
  fwprintf(_tab->trace, @wstr(!"\n"))

end sub
'
'''---------------------------------------------------------------------
'''  Symbol set computations
'''---------------------------------------------------------------------

'/' Computes the first set for the given Node. '/
function tab_first0(byval _tab as tab_ ptr, byval p as node_ ptr, byval mark as bitarray_ ptr) as bitarray_ ptr
  
  var fs = bitarray_create(_tab->terminals->count,0)
  while (p <> NIL andalso 0=(bitarray_itemat(mark,p->n)))
    bitarray_set(mark,p->n, 1)
    if (p->typ = node_.nt) then
      if (p->sym->firstready) then
        bitarray_or(fs,p->sym->first)
      else 
        var fs0 = tab_first0(_tab,p->sym->graph, mark)
        bitarray_or(fs,fs0)
        bitarray_destroy(fs0)
      end if
    elseif (p->typ = node_.t orelse p->typ = node_.wt) then
      bitarray_set(fs,p->sym->n, 1)
    elseif (p->typ = node_.any_) then
      bitarray_or(fs,p->set)
    elseif (p->typ = node_.alt)then
      var fs0 = tab_first0(_tab,p->sub_, mark)
      bitarray_or(fs,fs0)
      bitarray_destroy(fs0)
      fs0 = tab_first0(_tab,p->down, mark)
      bitarray_or(fs,fs0)
      bitarray_destroy(fs0)
    elseif (p->typ = node_.iter orelse p->typ = node_.opt) then
      var fs0 = tab_first0(_tab,p->sub_, mark)
      bitarray_or(fs,fs0)
      bitarray_destroy(fs0)
    end if

    if (0 = tab_delnode(_tab,p)) then
      exit while
    end if
    p = p->next_
  wend
  return fs

end function

function tab_first(byval _tab as tab_ ptr, byval p as node_ ptr) as bitarray_ ptr
  
  var mark = bitarray_create(_tab->nodes->count,0)
  var fs = tab_first0(_tab,p, mark)
  bitarray_destroy(mark)
  if (_tab->ddt(3)) then
    fwprintf(_tab->trace, @wstr(!"\n"))
    if (p <> NIL) then
      fwprintf(_tab->trace, @wstr(!"First: node = %d\n"), p->n )
    else 
      fwprintf(_tab->trace, @wstr(!"First: node = NIL\n"))
    end if
    tab_printset(_tab,fs, 0)
  end if
  return fs

end function


sub tab_compfirstsets(byval _tab as tab_ ptr)
  
  dim sym as symbol_ ptr
  dim i as integer
  
  for i = 0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    sym->first = bitarray_create(_tab->terminals->count,0)
    sym->firstready = 0
  next i
  
  for i = 0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    sym->first = tab_first(_tab,sym->graph)
    sym->firstready = 1
  next i

end sub

sub tab_compfollow(byval _tab as tab_ ptr, byval p as node_ ptr)
  
  while (p <> NIL andalso bitarray_itemat(_tab->visited,p->n) = 0)
    bitarray_set(_tab->visited,p->n, 1)
    if (p->typ = node_.nt) then
      var s = tab_first(_tab,p->next_)
      bitarray_or(p->sym->follow,s)
      if (tab_delgraph(_tab,p->next_)) then
        bitarray_set(p->sym->nts,_tab->cursy->n, 1)
      end if
    elseif (p->typ = node_.opt orelse p->typ = node_.iter) then
      tab_compfollow(_tab,p->sub_)
    elseif (p->typ = node_.alt) then
      tab_compfollow(_tab,p->sub_) 
      tab_compfollow(_tab,p->down)
    end if
    p = p->next_
  wend

end sub

sub tab_complete(byval _tab as tab_ ptr, byval sym as symbol_ ptr)
  
  if (bitarray_itemat(_tab->visited,sym->n) = 0) then
    bitarray_set(_tab->visited,sym->n, 1)
    dim s as symbol_ ptr
    
    for i as integer = 0 to _tab->nonterminals->count - 1
      s = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
      if (bitarray_itemat(sym->nts,s->n)) then
        tab_complete(_tab,s)
        bitarray_or(sym->follow,s->follow)
        if (sym = _tab->cursy) then
          bitarray_set(sym->nts,s->n, 0)
        end if
      end if
    next i
  end if

end sub

sub tab_compfollowsets(byval _tab as tab_ ptr)
  
  dim sym as symbol_ ptr
  dim i as integer
  
  for i = 0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    sym->follow = bitarray_create(_tab->terminals->count,0)
    sym->nts = bitarray_create(_tab->nonterminals->count,0)
  next i
  bitarray_set(_tab->gramsy->follow,_tab->eofsy->n, 1)
  _tab->visited = bitarray_create(_tab->nodes->count,0)
  for i as integer = 0 to _tab->nonterminals->count - 1  '' get direct successors of nonterminals
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    _tab->cursy = sym
    tab_compfollow(_tab,sym->graph)
  next i

  for i = 0 to _tab->nonterminals->count - 1  '' add indirect successors to followers
    sym = cast(symbol_ ptr, arraylist_itemat(_tab->nonterminals,i))
    _tab->visited = bitarray_create(_tab->nonterminals->count,0)
    _tab->cursy = sym
    tab_complete(_tab,sym)
  next i

end sub

function tab_leadingany(byval _tab as tab_ ptr, byval p as node_ ptr) as node_ ptr
  
  if (p = NIL) then
    return NIL
  end if
  
  dim as node_ ptr a = NIL
  if (p->typ = node_.any_) then
    a = p
  elseif (p->typ = node_.alt) then
    a = tab_leadingany(_tab,p->sub_)
    if (a = NIL) then
      a = tab_leadingany(_tab,p->down)
    end if
  elseif (p->typ = node_.opt orelse p->typ = node_.iter) then
    a = tab_leadingany(_tab,p->sub_)
  end if
  if (a = NIL andalso tab_delnode(_tab,p) andalso 0=p->up) then
    a = tab_leadingany(_tab,p->next_)
  end if
  return a

end function

sub tab_findas(byval _tab as tab_ ptr, byval p as node_ ptr) '' find ANY sets
  
  dim a as node_ ptr
  while (p <> NIL) 
    if (p->typ = node_.opt orelse p->typ = node_.iter) then
      tab_findas(_tab,p->sub_)
      a = tab_leadingany(_tab,p->sub_)
      if (a <> NIL) then
        sets_subtract(a->set, tab_first(_tab,p->next_))
      end if
    elseif (p->typ = node_.alt) then
      var s1 = bitarray_create(_tab->terminals->count,0)
      var q = p
      while (q <> NIL) 
        tab_findas(_tab,q->sub_)
        a = tab_leadingany(_tab,q->sub_)
        if (a <> NIL) then
          var tmp = tab_first(_tab,q->down)
          bitarray_or(tmp,s1)
          sets_subtract(a->set, tmp)
        else 
          var f = tab_first(_tab,q->sub_)
          bitarray_or(s1,f)
          bitarray_destroy(f)
        end if
        q = q->down
      wend
    end if

    '' Remove alternative terminals before ANY, in the following
    '' examples a and b must be removed from the ANY set:
    '' [a] ANY, or {a|b} ANY, or [a][b] ANY, or (a|) ANY, or
    '' A = [a]. A ANY
    if (tab_delnode(_tab,p)) then
      a = tab_leadingany(_tab,p->next_)
      if (a <> NIL) then
        dim q as node_ ptr
        if (p->typ = node_.nt) then
          q = p->sym->graph
        else
          q = p->sub_
        end if
        sets_subtract(a->set, tab_first(_tab,q))
      end if
    end if

    if (p->up) then
      exit while
    end if
    p = p->next_
  wend

end sub

sub tab_companysets(byval _tab as tab_ ptr)
  
  dim sym as symbol_ ptr
  for i as integer = 0 to _tab->nonterminals->count -1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    tab_findas(_tab,sym->graph)
  next i

end sub

function tab_expected(byval _tab as tab_ ptr, byval p as node_ ptr, byval cursy as symbol_ ptr) as bitarray_ ptr
  
  var s = tab_first(_tab,p)
  if (tab_delgraph(_tab,p)) then
    bitarray_or(s,cursy->follow)
  end if
  return s

end function

'' does not look behind resolvers; only called during LL(1) test and in CheckRes
function tab_expected0(byval _tab as tab_ ptr, byval p as node_ ptr, byval cursy as symbol_ ptr) as bitarray_ ptr
  
  if (p->typ = node_.rslv) then
    return bitarray_create(_tab->terminals->count,0)
  else 
    return tab_expected(_tab,p, cursy)
  end if

end function

sub tab_compsync(byval _tab as tab_ ptr, byval p as node_ ptr)
  
  while (p <> NIL andalso (bitarray_get(_tab->visited,p->n) = 0)) 
    bitarray_set(_tab->visited,p->n, 1)
    if (p->typ = node_.sync) then
      var s = tab_expected(_tab,p->next_, _tab->cursy)
      bitarray_set(s,_tab->eofsy->n, 1)
      bitarray_or(_tab->allsyncsets,s)
      p->set = s
    elseif (p->typ = node_.alt) then
      tab_compsync(_tab,p->sub_)
      tab_compsync(_tab,p->down)
    elseif (p->typ = node_.opt orelse p->typ = node_.iter) then
      tab_compsync(_tab,p->sub_)
    end if
    p = p->next_
  wend

end sub

sub tab_compsyncsets(byval _tab as tab_ ptr)
  
  _tab->allsyncsets = bitarray_create(_tab->terminals->count,0)
  bitarray_set(_tab->allsyncsets,_tab->eofsy->n, 1)
  _tab->visited = bitarray_create(_tab->nodes->count,0)

  dim sym as symbol_ ptr
  for i as integer = 0 to _tab->nonterminals->count - 1  
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    _tab->cursy = sym
    tab_compsync(_tab,_tab->cursy->graph)
  next i

end sub

sub tab_setupanys(byval _tab as tab_ ptr)
  
  dim p as node_ ptr
  
  for i as integer = 0 to _tab->nodes->count - 1
    p = cast(node_ ptr,arraylist_itemat(_tab->nodes,i))
    if (p->typ = node_.any_) then
      p->set = bitarray_create(_tab->terminals->count, 1)
      bitarray_set(p->set,_tab->eofsy->n, 0)
    end if
  next i

end sub

sub tab_compdeletablesymbols(byval _tab as tab_ ptr)
  
  dim changed as byte
  dim sym as symbol_ ptr
  dim i as integer
  do
    changed = 0
    for i = 0 to _tab->nonterminals->count - 1
      sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
      if (sym->deletable = 0 andalso sym->graph <> NIL andalso tab_delgraph(_tab,sym->graph)) then
        sym->deletable = 1
        changed = 1
      end if
    next i
  loop while (changed)

  for i = 0 to _tab->nonterminals->count - 1  
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    if (sym->deletable) then
      wprintf(@wstr(!"  %ls deletable\n"),  sym->name)
    end if
  next i

end sub

sub tab_renumberpragmas(byval _tab as tab_ ptr)
  
  var n = _tab->terminals->count
  dim sym as symbol_ ptr
  for i as integer = 0 to _tab->pragmas->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->pragmas,i))
    sym->n = n:n += 1
  next i

end sub

sub tab_compsymbolsets(byval _tab as tab_ ptr)
  
  tab_compdeletablesymbols(_tab)
  tab_compfirstsets(_tab)
  tab_companysets(_tab)
  tab_compfollowsets(_tab)
  tab_compsyncsets(_tab)
  
  if (_tab->ddt(1)) then
    fwprintf(_tab->trace, @wstr(!"\n"))
    fwprintf(_tab->trace, @wstr(!"First & follow symbols:\n"))
    fwprintf(_tab->trace, @wstr(!"----------------------\n\n"))

    dim sym as symbol_ ptr
    for i as integer = 0 to _tab->nonterminals->count - 1
      sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
      fwprintf(_tab->trace, @wstr(!"%ls\n"), sym->name)
      fwprintf(_tab->trace, @wstr(!"first:   "))
      tab_printset(_tab,sym->first, 10)
      fwprintf(_tab->trace, @wstr(!"follow:  "))
      tab_printset(_tab,sym->follow, 10)
      fwprintf(_tab->trace, @wstr(!"\n"))
    next i
  end if
  if (_tab->ddt(4)) then
    fwprintf(_tab->trace, @wstr(!"\n"))
    fwprintf(_tab->trace, @wstr(!"ANY and SYNC sets:\n"))
    fwprintf(_tab->trace, @wstr(!"-----------------\n"))

    dim p as node_ ptr
    for i as integer = 0 to _tab->nodes->count - 1
      p = cast(node_ ptr,arraylist_itemat(_tab->nodes,i))
      if (p->typ = node_.any_ orelse p->typ = node_.sync) then
        fwprintf(_tab->trace, @wstr(!"%4d %4s "), p->n, _tab->ntyp(p->typ))
        tab_printset(_tab,p->set, 11)
      end if
    next i
  end if

end sub

''---------------------------------------------------------------------
''  String handling
''---------------------------------------------------------------------

function tab_hex2char(byval _tab as tab_ ptr, byval s as wchar_t ptr) as wchar_t
  
  dim val_ as integer = 0
  dim len_ as integer = coco_string_length(s)
  for i as integer = 0 to len_ - 1
    var ch = s[i]
    if (asc("0") <= ch andalso ch <= asc("9")) then
      val_ = 16 * val_ + (ch - asc("0"))
    elseif (asc("a") <= ch andalso ch <= asc("f")) then
      val_ = 16 * val_ + (10 + ch - asc("a"))
    elseif (asc("A") <= ch andalso ch <= asc("F")) then
      val_ = 16 * val_ + (10 + ch - asc("A"))
    else 
      parser_semerr(_tab->parser,@wstr(!"bad escape sequence in string or character"))
    end if
  next i
  if (val_ >= COCO_WCHAR_MAX) then /' pdt '/
    parser_semerr(_tab->parser,@wstr(!"bad escape sequence in string or character"))
  end if
  return cast(wchar_t, val_)

end function

function tab_char2hex(byval _tab as tab_ ptr, byval ch as wchar_t) as wchar_t ptr
  
  var format_ = callocate(10,sizeof(wchar_t))
  ''FIXME
  coco_swprintf(format_, 10, @wstr(!"\\&h%04x"), ch)
  return format_

end function

function tab_unescape(byval _tab as tab_ ptr, byval s as wchar_t ptr) as wchar_t ptr
  
  /' replaces escape sequences in s by their Unicode values. '/
  var buf = stringbuilder_create()
  dim i as integer = 0
  var len_ = coco_string_length(s)
  while (i < len_) 
    if (s[i] = asc(!"\\")) then
      select case as const s[i+1]
        case asc(!"\\"): stringbuilder_appendwc(buf,asc(!"\\")): i += 2
        case asc(!"\'"): stringbuilder_appendwc(buf,asc(!"\'")): i += 2
        case asc(!"\""): stringbuilder_appendwc(buf,asc(!"\"")): i += 2
        case asc(!"r"): stringbuilder_appendwc(buf,asc(!"\r")): i += 2
        case asc(!"n"): stringbuilder_appendwc(buf,asc(!"\n")): i += 2
        case asc(!"t"): stringbuilder_appendwc(buf,asc(!"\t")): i += 2
        case asc(!"0"): stringbuilder_appendwc(buf,asc(!"\0")): i += 2
        case asc(!"a"): stringbuilder_appendwc(buf,asc(!"\a")): i += 2
        case asc(!"b"): stringbuilder_appendwc(buf,asc(!"\b")): i += 2
        case asc(!"f"): stringbuilder_appendwc(buf,asc(!"\f")): i += 2
        case asc(!"v"): stringbuilder_appendwc(buf,asc(!"\v")): i += 2
        case asc(!"u"), asc(!"x"):
          if (i + 6 <= coco_string_length(s)) then
            var subs = coco_string_create_il(s, i+2, 4)
            stringbuilder_appendwc(buf,tab_hex2char(_tab,subs))
            i += 6
            ''FIXME? in original source code the destroy is written after the break
            ''I think this means subs does not get deallocated (memory leak)
            coco_string_destroy(subs)
          else 
            parser_semerr(_tab->parser,@wstr(!"bad escape sequence in string or character"))
            i = coco_string_length(s)
          end if
        case else
            parser_semerr(_tab->parser,@wstr(!"bad escape sequence in string or character"))
            i += 2
      end select
    else 
      stringbuilder_appendwc(buf,s[i])
      i += 1
    end if
  wend

  return stringbuilder_tostring(buf)  

end function


function tab_escape(byval _tab as tab_ ptr, byval s as wchar_t ptr) as wchar_t ptr
  
  var buf = stringbuilder_create()
  dim ch as wchar_t
  var len_ = coco_string_length(s)
  for i as integer = 0 to len_ - 1  
    ch = s[i]
    select case as const (ch)
      case asc(!"\\"):stringbuilder_appendws(buf,@wstr(!"\\\\"))
      case asc(!"\'"):stringbuilder_appendws(buf,@wstr(!"\\'"))
      case asc(!"\""):stringbuilder_appendws(buf,@wstr(!"\\\""))
      case asc(!"\t"):stringbuilder_appendws(buf,@wstr(!"\\t"))
      case asc(!"\r"):stringbuilder_appendws(buf,@wstr(!"\\r"))
      case asc(!"\n"):stringbuilder_appendws(buf,@wstr(!"\\n"))
      case else
        if ((ch < asc(!" ")) orelse (ch > &h7f)) then
          var res = tab_char2hex(_tab,ch)
          stringbuilder_appendws(buf,res)
          coco_string_destroy(res)
        else
          stringbuilder_appendwc(buf,ch)
        end if
        
    end select
  next i
  return stringbuilder_tostring(buf)

end function


''---------------------------------------------------------------------
''  Grammar checks
''---------------------------------------------------------------------

function tab_grammarok(byval _tab as tab_ ptr) as byte
  
  dim ok as byte = tab_ntscomplete(_tab) andalso _
                   tab_allntreached(_tab) andalso _
                   tab_nocircularproductions(_tab) andalso _
                   tab_allnttoterm(_tab)
    if (ok) then
      tab_checkresolvers(_tab)
      tab_checkll1(_tab)
    end if
    return ok

end function


''--------------- check for circular productions ----------------------
function tab_cnode_create(byval l as symbol_ ptr, byval r as symbol_ ptr) as cnode_ ptr
     
  dim cnode as cnode_ ptr
  cnode = callocate(1,sizeof(cnode_))
  cnode->left = l
  cnode->right = r
  return cnode
  
end function

sub tab_getsingles(byval _tab as tab_ ptr, byval p as node_ ptr, byval singles as arraylist_ ptr)
  
  if (p = NIL) then
    return  '' end of graph
  end if
  if (p->typ = node_.nt) then
    if (p->up orelse tab_delgraph(_tab,p->next_)) then
      arraylist_add(singles,p->sym)
    end if
  elseif (p->typ = node_.alt orelse p->typ = node_.iter orelse p->typ = node_.opt) then
    if (p->up orelse tab_delgraph(_tab,p->next_)) then
      tab_getsingles(_tab,p->sub_, singles)
      if (p->typ = node_.alt) then
        tab_getsingles(_tab,p->down, singles)
      end if
    end if
  end if
  if (0=p->up andalso tab_delnode(_tab,p)) then
    tab_getsingles(_tab,p->next_, singles)
  end if

end sub

function tab_nocircularproductions(byval _tab as tab_ ptr) as byte
  
  dim ok as byte
  dim changed as byte
  dim onleftside as byte
  dim onrightside as byte
  
  var list = arraylist_create()


  dim sym as symbol_ ptr
  dim i as integer
  for i = 0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    var singles = arraylist_create()
    tab_getsingles(_tab,sym->graph, singles) '' get nonterminals s such that sym-->s
    dim s as symbol_ ptr
    for j as integer = 0 to singles->count - 1    
      s = cast(symbol_ ptr,arraylist_itemat(singles,j))
      arraylist_add(list,tab_cnode_create(sym, s))
    next j
  next i

  dim n as cnode_ ptr
  do 
    changed = 0
    ''FIXME? loop variable (i) gets updated inside loop (translation ok)
    i = 0
    while (i < list->count)
      n = cast(cnode_ ptr,arraylist_itemat(list,i))
      onleftside = 0
      onrightside = 0
      dim m as cnode_ ptr
      for j as integer = 0 to list->count - 1
        m = cast(cnode_ ptr,arraylist_itemat(list,j))
        if (n->left = m->right) then
          onrightside = 1
        end if
        if (n->right = m->left) then
          onleftside = 1
        end if
      next j
      if (onleftside = 0 orelse onrightside = 0) then
        arraylist_remove(list,n)
        i -= 1
        changed = 1
      end if
      i += 1
    wend
  loop while(changed = 1)
  ok = 1

  for i = 0 to list->count - 1
    n = cast(cnode_ ptr,arraylist_itemat(list,i))
    ok = 0
    _tab->errors->count += 1
    wprintf(@wstr(!"  %ls --> %ls"), n->left->name, n->right->name)
  next i
  return ok

end function


''--------------- check for LL(1) errors ----------------------

sub tab_ll1error(byval _tab as tab_ ptr, byval cond as integer, byval sym as symbol_ ptr)
  
  wprintf(@wstr(!"  LL1 warning in %ls: "), _tab->cursy->name)
  if (sym <> NIL) then
    wprintf(@wstr(!"%ls is "), sym->name)
  end if
  select case as const (cond)
    case 1: wprintf(@wstr(!"start of several alternatives\n"))
    case 2: wprintf(@wstr(!"start & successor of deletable structure\n"))
    case 3: wprintf(@wstr(!"an ANY node that matches no symbol\n"))
    case 4: wprintf(@wstr(!"contents of [...] or {...} must not be deletable\n"))
  end select

end sub


sub tab_checkoverlap(byval _tab as tab_ ptr, byval s1 as bitarray_ ptr, byval s2 as bitarray_ ptr, byval cond as integer)
  
  dim sym as symbol_ ptr
  for i as integer = 0 to _tab->terminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->terminals,i))
    if (bitarray_itemat(s1,sym->n) andalso bitarray_itemat(s2,sym->n)) then
      tab_ll1error(_tab,cond, sym)
    end if
  next i

end sub

sub tab_checkalts(byval _tab as tab_ ptr, byval p as node_ ptr)
  
  dim s1 as bitarray_ ptr
  dim s2 as bitarray_ ptr
  while (p <> NIL)
    if (p->typ = node_.alt) then
      var q = p
      s1 = bitarray_create(_tab->terminals->count,0)
      while (q <> NIL) '' for all alternatives
        s2 = tab_expected0(_tab,q->sub_, _tab->cursy)
        tab_checkoverlap(_tab,s1, s2, 1)
        bitarray_or(s1,s2)
        tab_checkalts(_tab,q->sub_)
        q = q->down
      wend
    elseif (p->typ = node_.opt orelse p->typ = node_.iter) then
      if (tab_delsubgraph(_tab,p->sub_)) then
        tab_ll1error(_tab,4, NIL) '' e.g. [[...]]
      else
        s1 = tab_expected0(_tab,p->sub_, _tab->cursy)
        s2 = tab_expected(_tab,p->next_, _tab->cursy)
        tab_checkoverlap(_tab,s1, s2, 2)
      end if
      tab_checkalts(_tab,p->sub_)
    elseif (p->typ = node_.any_) then
      if (sets_elements(p->set) = 0) then
        tab_ll1error(_tab,3, NIL)
      end if
      '' e.g. {ANY} ANY or [ANY] ANY or ( ANY | ANY )
    end if
    if (p->up) then
      exit while
    end if
    p = p->next_
  wend

end sub

sub tab_checkll1(byval _tab as tab_ ptr)
  
  dim sym as symbol_ ptr
  
  for i as integer = 0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    _tab->cursy = sym
    tab_checkalts(_tab,_tab->cursy->graph)
  next i

end sub

''------------- check if resolvers are legal  --------------------

sub tab_reserr(byval _tab as tab_ ptr, byval p as node_ ptr, byval msg as wchar_t ptr)
  
  errors_warning_line(_tab->errors,p->line_, p->pos_->col_, msg)

end sub

sub tab_checkres(byval _tab as tab_ ptr, byval p as node_ ptr, byval rslvallowed as byte)
  
  while (p <> NIL)
    dim q as node_ ptr
    if (p->typ = node_.alt) then
      var expected = bitarray_create(_tab->terminals->count,0)
      q = p
      while (q <> NIL)
        bitarray_or(expected,tab_expected0(_tab,q->sub_, _tab->cursy))
        q = q->down
      wend
      var sofar = bitarray_create(_tab->terminals->count,0)
      q = p
      while (q <> NIL)
        if (q->sub_->typ = node_.rslv) then
          var fs = tab_expected(_tab,q->sub_->next_, _tab->cursy)
          if (sets_intersect(fs, sofar)) then
            tab_reserr(_tab,q->sub_, @wstr(!"Warning: Resolver will never be evaluated. Place it at previous conflicting alternative."))
          end if
          if (sets_intersect(fs, expected) = 0) then
            tab_reserr(_tab,q->sub_, @wstr(!"Warning: Misplaced resolver: no LL(1) conflict."))
          end if
        else 
          bitarray_or(sofar,tab_expected(_tab,q->sub_, _tab->cursy))
        end if
        tab_checkres(_tab,q->sub_, 1)
        q = q->down
      wend
    elseif (p->typ = node_.iter orelse p->typ = node_.opt) then
      if (p->sub_->typ = node_.rslv) then
        var fs = tab_first(_tab,p->sub_->next_)
        var fsnext = tab_expected(_tab,p->next_, _tab->cursy)
        if (0 = sets_intersect(fs, fsnext)) then
          tab_reserr(_tab,p->sub_, @wstr(!"Warning: Misplaced resolver: no LL(1) conflict."))
        end if
      end if
      tab_checkres(_tab,p->sub_, 1)      
    elseif (p->typ = node_.rslv) then
      if (0 = rslvallowed) then
        tab_reserr(_tab,p, @wstr(!"Warning: Misplaced resolver: no alternative."))
      end if
    end if
    if (p->up) then
      exit while
    end if
    p = p->next_
    rslvallowed = 0
  wend

end sub

sub tab_checkresolvers(byval _tab as tab_ ptr)
  
  for i as integer = 0 to _tab->nonterminals->count - 1
    _tab->cursy = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    tab_checkres(_tab,_tab->cursy->graph,0)
  next i

end sub


''------------- check if every nts has a production --------------------

function tab_ntscomplete(byval _tab as tab_ ptr) as byte
  
  dim complete as byte = 1
  dim sym as symbol_ ptr
  
  for i as integer = 0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    if (sym->graph = NIL) then
        complete = 0
        _tab->errors->count += 1
        wprintf(@wstr(!"  No production for %ls\n"), sym->name)
    end if
  next i
  return complete

end function

''-------------- check if every nts can be reached  -----------------

sub tab_markreachednts(byval _tab as tab_ ptr, byval p as node_ ptr)
  
  while (p <> NIL)
    if (p->typ = node_.nt andalso 0=(bitarray_itemat(_tab->visited,p->sym->n))) then '' new nt reached
      bitarray_set(_tab->visited,p->sym->n, 1)
      tab_markreachednts(_tab,p->sym->graph)
    elseif (p->typ = node_.alt orelse p->typ = node_.iter orelse p->typ = node_.opt) then
      tab_markreachednts(_tab,p->sub_)
      if (p->typ = node_.alt) then
        tab_markreachednts(_tab,p->down)
      end if
    end if
    if (p->up) then
      exit while
    end if
    p = p->next_
  wend

end sub

function tab_allntreached(byval _tab as tab_ ptr) as byte
  
  dim ok as byte = 1
  _tab->visited = bitarray_create(_tab->nonterminals->count,0)
  bitarray_set(_tab->visited,_tab->gramsy->n, 1)
  tab_markreachednts(_tab,_tab->gramsy->graph)
  dim sym as symbol_ ptr
  for i as integer = 0 to _tab->nonterminals->count - 1
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    if (0=(bitarray_itemat(_tab->visited,sym->n))) then
      ok = 0
      _tab->errors->count += 1
      wprintf(@wstr(!"  %ls cannot be reached\n"), sym->name)
    end if
  next i
  return ok

end function

''--------- check if every nts can be derived to terminals  ------------

function tab_isterm(byval _tab as tab_ ptr, byval p as node_ ptr, byval mark as bitarray_ ptr) as byte '' 1 if graph can be derived to terminals
  
  while (p <> NIL) 
    if (p->typ = node_.nt andalso 0=(bitarray_itemat(mark,p->sym->n))) then
      return 0
    end if
    if (p->typ = node_.alt andalso 0 = tab_isterm(_tab,p->sub_, mark) andalso _
       (p->down = NIL orelse 0=tab_isterm(_tab,p->down, mark))) then
      return 0
    end if
    if (p->up) then
      exit while
    end if
    p = p->next_
  wend
  return 1

end function


function tab_allnttoterm(byval _tab as tab_ ptr) as byte
  
  dim changed as byte
  dim ok as byte = 1
  
  var mark = bitarray_create(_tab->nonterminals->count,0)
  '' a nonterminal is marked if it can be derived to terminal symbols
  dim sym as symbol_ ptr
  dim i as integer
  do
    changed = 0

    for i as integer = 0 to _tab->nonterminals->count - 1
      sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
      if (0=(bitarray_itemat(mark,sym->n)) andalso tab_isterm(_tab,sym->graph, mark)) then
        bitarray_set(mark,sym->n, 1)
        changed = 1
      end if
    next i
  loop while (changed)
  for i as integer = 0 to _tab->nonterminals->count - 1  
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    if (0=(bitarray_itemat(mark,sym->n))) then
      ok = 0
      _tab->errors->count += 1
      wprintf(@wstr(!"  %ls cannot be derived to terminals\n"), sym->name)
    end if
  next i
  return ok

end function

''---------------------------------------------------------------------
''  Cross reference list
''---------------------------------------------------------------------

sub tab_xref(byval _tab as tab_ ptr)

  var xref = sortedlist_create()
  '' collect lines where symbols have been defined
  dim sym as symbol_ ptr
  dim i as integer
  dim j as integer
  for i as integer = 0 to _tab->nonterminals->count - 1  
    sym = cast(symbol_ ptr,arraylist_itemat(_tab->nonterminals,i))
    var list = cast(arraylist_ ptr,sortedlist_get(xref,sym))
    if (list = NIL) then
      list = arraylist_create()
      sortedlist_set(xref,sym, list)
    end if
    dim intg as integer ptr
    intg = callocate(1,sizeof(integer))
    *intg = sym->line
    arraylist_add(list,intg)
  next i
  '' collect lines where symbols have been referenced
  dim n as node_ ptr
  for i = 0 to _tab->nodes->count - 1  
    n = cast(node_ ptr,arraylist_itemat(_tab->nodes,i))
    if (n->typ = node_.t orelse n->typ = node_.wt orelse n->typ = node_.nt) then
      var list = cast(arraylist_ ptr,sortedlist_get(xref,n->sym))
      if (list = NIL) then
        list = arraylist_create()
        sortedlist_set(xref,n->sym, list)
      end if
      dim intg as integer ptr
      intg = callocate(1,sizeof(integer))
      *intg = n->line_
      arraylist_add(list,intg)
    end if
  next i
  '' print cross reference list
  fwprintf(_tab->trace, @wstr(!"\n"))
  fwprintf(_tab->trace, @wstr(!"Cross reference list:\n"))
  fwprintf(_tab->trace, @wstr(!"--------------------\n\n"))

  for i = 0 to xref->count - 1
    sym = cast(symbol_ ptr,sortedlist_getkey(xref,i))
    var paddedname = tab_name(_tab,sym->name)
    fwprintf(_tab->trace, @wstr(!"  %12s"), paddedname)
    coco_string_destroy(paddedname)
    var list = cast(arraylist_ ptr,sortedlist_get(xref,sym))
    var col = 14
    dim as integer line_ 
    for j = 0 to list->count - 1
      line_ = *cast(integer ptr,(arraylist_itemat(list,j)))
      if (col + 5 > 80) then
        fwprintf(_tab->trace, @wstr(!"\n"))
        for col = 1 to col <= 14
          fwprintf(_tab->trace, @wstr(!" "))
        next col
      end if
      fwprintf(_tab->trace, @wstr(!"%5d"), line_)
      col += 5
    next j
    fwprintf(_tab->trace, @wstr(!"\n"))
  next i
  fwprintf(_tab->trace, @wstr(!"\n\n"))

end sub

sub tab_setddt(byval _tab as tab_ ptr, byval s as wchar_t ptr)
  
  var st = coco_string_create_upper(s)
  dim ch as wchar_t
  var len_ = coco_string_length(st)
  for i as integer =  0 to len_ - 1
    ch = st[i]
    if (asc("0") <= ch andalso ch <= asc("9")) then
      _tab->ddt(ch - asc("0")) = 1
    else 
      select case as const (ch) 
      case asc("A") : _tab->ddt(0) = 1  '' trace automaton
      case asc("F") : _tab->ddt(1) = 1  '' list first/follow sets
      case asc("G") : _tab->ddt(2) = 1  '' print syntax graph
      case asc("I") : _tab->ddt(3) = 1  '' trace computation of first sets
      case asc("J") : _tab->ddt(4) = 1  '' print ANY and SYNC sets
      case asc("P") : _tab->ddt(8) = 1  '' print statistics
      case asc("S") : _tab->ddt(6) = 1  '' list symbol table
      case asc("X") : _tab->ddt(7) = 1  '' list cross reference table
      case else
        exit select
      end select
    end if
  next i
  coco_string_destroy(st)

end sub


sub tab_setoption(byval _tab as tab_ ptr, byval s as wchar_t ptr)
  '' example: $namespace=xxx
  ''   index of '=' is 10 => nameLenght = 10
  ''   start index of xxx = 11

  var namelenght = coco_string_indexof(s, asc("="))
  var valueindex = namelenght + 1

  var name_ = coco_string_create_il(s, 0, namelenght)
  var value = coco_string_create_i(s, valueindex)

  if (coco_string_equal(@wstr(!"$namespace"), name_)) then
    if (_tab->nsname = NIL) then
      _tab->nsname = coco_string_create(value)
    end if
  elseif (coco_string_equal(@wstr(!"$checkEOF"), name_)) then
    _tab->checkeof = coco_string_equal(@wstr(!"1"), value)
  end if

  coco_string_destroy(name_)
  coco_string_destroy(value)

end sub

'#include once "crt/stdlib.bi"
'#include once "crt/wchar.bi"
'#include once "DFA.bi"
'#include once "Tab.bi"
'#include once "Parser.bi"
'#include once "BitArray.bi"
'#include once "Scanner.bi"
'#include once "Generator.bi"

''---------- Output primitives
function dfa_ch(byval dfa as dfa_ ptr,byval ch as wchar_t) as wchar_t ptr
  
  dim format_ as wchar_t ptr = callocate(10,sizeof(wchar_t))
  if (ch < asc(" ") orelse ch >= 127 orelse ch = asc(!"\'") orelse ch = asc(!"\\")) then
    coco_swprintf(format_, 10, @wstr(!"%d\0"), cast(integer,ch))
  else
    coco_swprintf(format_, 10, @wstr(!"%ld\0"), cast(integer,ch))
  end if
  return format_

end function

function dfa_chcond(byval dfa as dfa_ ptr,byval ch as wchar_t) as wchar_t ptr
  
  dim format_ as wchar_t ptr = callocate(20,sizeof(wchar_t))
  dim res as wchar_t ptr = dfa_ch(dfa,ch)
  coco_swprintf(format_, 20, @wstr(!"scanner->ch = %ls\0"), res)
  deallocate(res)
  return format_

end function

sub dfa_putrange(byval dfa as dfa_ ptr,byval s as charset_ ptr)
  
  dim r as range_ ptr
  r = s->head
  while (r <> NIL)
    if (r->from = r->to) then
      var from = dfa_ch(dfa,cast(wchar_t, r->from))
      fwprintf(dfa->gen, @wstr(!"  (scanner->ch = %ls)"), from)
      deallocate(from)
    elseif (r->from = 0) then
      var to_ = dfa_ch(dfa,cast(wchar_t, r->to))
      fwprintf(dfa->gen, @wstr(!"  (scanner->ch <= %ls)"), to_)
      deallocate(to_)
    else
      var from_ = dfa_ch(dfa,cast(wchar_t, r->from))
      var to_ = dfa_ch(dfa,cast(wchar_t, r->to))
      fwprintf(dfa->gen, @wstr(!"  (scanner->ch >= %ls andalso scanner->ch <= %ls)"), from_, to_)
      deallocate(from_)
      deallocate(to_)
    end if
    if (r->next <> NIL) then
      fwprintf(dfa->gen, @wstr(!" orelse _\n      "))
    end if
    r = r->next
  wend

end sub


''---------- State handling
function dfa_newstate(byval dfa as dfa_ ptr) as state_ ptr
  
  var s = state_create()
  dfa->laststatenr += 1
  s->nr = dfa->laststatenr
  if (dfa->firststate = NIL) then 
    dfa->firststate = s
  else 
    dfa->laststate->next = s
  end if
  dfa->laststate = s
  return s

end function

sub dfa_newtransition(byval dfa as dfa_ ptr,byval from_ as state_ ptr, _
                      byval to_ as state_ ptr, byval typ as integer, _
                      byval sym as integer, byval tc as integer)
  
  var t = target_create(to_)
  var a = action_create(typ, sym, tc)
  a->target = t
  state_addaction(from_,a)
  if (typ = node_.clas) then
    dfa->cursy->tokenkind = symbol_.classtoken
  end if

end sub

sub dfa_combineshifts(byval dfa as dfa_ ptr)
  
  dim state as state_ ptr
  dim a as action_ ptr
  dim b as action_ ptr
  dim c as action_ ptr
  dim seta as charset_ ptr
  dim setb as charset_ ptr
  
  state = dfa->firststate
  while (state <> NIL)
    a = state->firstaction
    while (a <> NIL)
      b = a->next
      while (b <> NIL)
        if (a->target->state = b->target->state andalso a->tc = b->tc) then
          seta = action_symbols(a,dfa->tab)
          setb = action_symbols(b,dfa->tab)
          charset_or(seta,setb)
          action_shiftwith(a,seta, dfa->tab)
          c = b
          b = b->next
          state_detachaction(state,c)
        else
          b = b->next
        end if
      wend
      a = a->next
    wend
    state = state->next
  wend

end sub

sub dfa_findusedstates(byval dfa as dfa_ ptr,byval state as state_ ptr, byval used as bitarray_ ptr)
  
  if (bitarray_itemat(used,state->nr)) then
    return
  end if
  bitarray_set(used,state->nr, 1)
  var a = state->firstaction
  while (a <> NIL)
    dfa_findusedstates(dfa,a->target->state, used)
    a = a->next
  wend

end sub

sub dfa_deleteredundantstates(byval dfa as dfa_ ptr)
  ''State *newState = new State[State::lastNr + 1];
  dim newstate as state_ ptr ptr = cast(state_ ptr ptr,callocate(1,(sizeof(state_ ptr) * (dfa->laststatenr + 1))))
  var used = bitarray_create(dfa->laststatenr + 1,0)
  dfa_findusedstates(dfa,dfa->firststate, used)
  '' combine equal final states
  dim s1 as state_ ptr = dfa->firststate->next
  while (s1 <> NIL) '' firstState cannot be final
    if (bitarray_itemat(used,s1->nr) andalso s1->endof <> NIL andalso s1->firstaction <> NIL andalso 0=(s1->ctx)) then
      dim s2 as state_ ptr = s1->next
      while (s2 <> NIL)
        if (bitarray_itemat(used,s2->nr) andalso s1->endof = s2->endof andalso s2->firstaction <> NIL andalso 0=(s2->ctx)) then
          bitarray_set(used,s2->nr, 0)
          newstate[s2->nr] = s1
        end if
        s2 = s2->next
      wend
    end if
    s1 = s1->next
  wend
  dim state as state_ ptr = dfa->firststate
  while (state <> NIL)
    if (bitarray_itemat(used,state->nr)) then
      dim a as action_ ptr = state->firstaction
      while (a <> NIL)
        if (0=(bitarray_itemat(used,a->target->state->nr))) then
          a->target->state = newstate[a->target->state->nr]
        end if
        a = a->next
      wend
    end if
    state = state->next
  wend
  '' delete unused states
  dfa->laststate = dfa->firststate
  dfa->laststatenr = 0 '' firstState has number 0
  state = dfa->firststate->next
  while (state <> NIL)
    if (bitarray_itemat(used,state->nr)) then
      dfa->laststatenr += 1
      state->nr = dfa->laststatenr
      dfa->laststate = state
    else 
      dfa->laststate->next = state->next
    end if
    state = state->next
  wend
  deallocate(newstate)
  bitarray_destroy(used)

end sub

function dfa_thestate(byval dfa as dfa_ ptr,byval p as node_ ptr) as state_ ptr
  
  dim state as state_ ptr
  if (p = NIL) then
    state = dfa_newstate(dfa)
    state->endof = dfa->cursy
    return state
  else 
    return p->state
  end if

end function

sub dfa_step(byval dfa as dfa_ ptr,byval from_ as state_ ptr, byval p as node_ ptr, byval stepped as bitarray_ ptr)
  
  if (p = NIL) then
    return
  end if
  
  bitarray_set(stepped,p->n, 1)

  if (p->typ = node_.clas orelse p->typ = node_.chr) then
    ''AGS pulled dfa_thestate from function call and 
    ''turned it into a regular assignment
    var tmp = dfa_thestate(dfa,p->next_)
    dfa_newtransition(dfa,from_, tmp, p->typ, p->val_, p->code)
  elseif (p->typ = node_.alt) then
    dfa_step(dfa,from_, p->sub_, stepped)
    dfa_step(dfa,from_, p->down, stepped)
  elseif (p->typ = node_.iter) then
    if (tab_delsubgraph(dfa->tab,p->sub_)) then
      parser_semerr(dfa->parser,@wstr(!"contents of {...} must not be deletable"))
      return
    end if
    if (p->next_ <> NIL andalso 0=(bitarray_itemat(stepped,p->next_->n))) then
      dfa_step(dfa,from_, p->next_, stepped)
    end if
    dfa_step(dfa,from_, p->sub_, stepped)
    if (p->state <> from_) then
      dim newstepped as bitarray_ ptr = bitarray_create(dfa->tab->nodes->count,0)
      dfa_step(dfa,p->state, p, newstepped)
      bitarray_destroy(newstepped)
    end if
  elseif (p->typ = node_.opt) then
    if (p->next_ <> NIL andalso 0=(bitarray_itemat(stepped,p->next_->n))) then
      dfa_step(dfa,from_, p->next_, stepped)
    end if      
    dfa_step(dfa,from_, p->sub_, stepped)
  end if

end sub

'' Assigns a state n.state to every node n. There will be a transition from
'' n.state to n.next.state triggered by n.val. All nodes in an alternative
'' chain are represented by the same state.
'' Numbering scheme:
''  - any node after a chr, clas, opt, or alt, must get a new number
''  - if a nested structure starts with an iteration the iter node must get a new number
''  - if an iteration follows an iteration, it must get a new number
sub dfa_numbernodes(byval dfa as dfa_ ptr,byval p as node_ ptr, byref state as state_ ptr, byval renumiter as byte)
  
  if (p = NIL) then
    return
  end if
  if (p->state <> NIL) then
    return '' already visited;
  end if
  if ((state = NIL) orelse ((p->typ = node_.iter) andalso renumiter)) then
    state = dfa_newstate(dfa)
  end if
  p->state = state
  if (tab_delgraph(dfa->tab,p)) then
    state->endof = dfa->cursy
  end if
  if (p->typ = node_.clas orelse p->typ = node_.chr) then
    dfa_numbernodes(dfa,p->next_, NIL, 0)
  elseif (p->typ = node_.opt) then
    dfa_numbernodes(dfa,p->next_, NIL, 0)
    dfa_numbernodes(dfa,p->sub_, state, 1)
  elseif (p->typ = node_.iter) then
    dfa_numbernodes(dfa,p->next_, state, 1)
    dfa_numbernodes(dfa,p->sub_, state, 1)
  elseif (p->typ = node_.alt) then
    dfa_numbernodes(dfa,p->next_, NIL, 0)
    dfa_numbernodes(dfa,p->sub_, state, 1)
    dfa_numbernodes(dfa,p->down, state, renumiter)
  end if

end sub

sub dfa_findtrans(byval dfa as dfa_ ptr, byval p as node_ ptr, byval start_ as byte, byval marked as bitarray_ ptr)
  
  if (p = NIL orelse bitarray_itemat(marked,p->n)) then
    return
  end if
  bitarray_set(marked,p->n, 1)
  if (start_) then
    var stepped = bitarray_create(dfa->tab->nodes->count,0)
    dfa_step(dfa,p->state, p, stepped) '' start of group of equally numbered nodes
    bitarray_destroy(stepped)
  end if

  if (p->typ = node_.clas orelse p->typ = node_.chr) then
    dfa_findtrans(dfa,p->next_, 1, marked)
  elseif (p->typ = node_.opt) then
    dfa_findtrans(dfa,p->next_, 1, marked)
    dfa_findtrans(dfa,p->sub_, 0, marked)
  elseif (p->typ = node_.iter) then
    dfa_findtrans(dfa,p->next_, 0, marked)
    dfa_findtrans(dfa,p->sub_, 0, marked)
  elseif (p->typ = node_.alt) then
    dfa_findtrans(dfa,p->sub_, 0, marked)
    dfa_findtrans(dfa,p->down, 0, marked)
  end if

end sub

sub dfa_converttostates(byval dfa as dfa_ ptr,byval p as node_ ptr, byval sym as symbol_ ptr)
  
  dfa->curgraph = p
  dfa->cursy = sym
  if (tab_delgraph(dfa->tab,dfa->curgraph)) then
    parser_semerr(dfa->parser,@wstr("token might be empty"))
    return
  end if
  dfa_numbernodes(dfa,dfa->curgraph, dfa->firststate, 1)
  ''AGS pulled bitarray_create from call to dfa_findtrans
  var tmp_bitarray = bitarray_create(dfa->tab->nodes->count,0)
  dfa_findtrans(dfa,dfa->curgraph, 1,tmp_bitarray)
  bitarray_destroy(tmp_bitarray)
  if (p->typ = node_.iter) then
    var stepped = bitarray_create(dfa->tab->nodes->count,0)
    dfa_step(dfa,dfa->firststate, p, stepped)
    bitarray_destroy(stepped)
  end if

end sub

'' match string against current automaton; store it either as a fixedtoken or as a littoken
sub dfa_matchliteral(byval dfa as dfa_ ptr,byval s as wchar_t ptr, byval sym as symbol_ ptr)

  var subs = coco_string_create_il(s, 1, coco_string_length(s)-2)
  s = tab_unescape(dfa->tab,subs)
  coco_string_destroy(subs)
  dim i as integer
  dim len_ as integer = coco_string_length(s)
  var state = dfa->firststate
  dim a as action_ ptr = NIL
  for i = 0 to len_ - 1  '' try to match s against existing DFA
    a = dfa_findaction(dfa,state, s[i])
    if (a = NIL) then
      exit for
    end if
    state = a->target->state
  next i
  '' if s was not totally consumed or leads to a non-final state => make new DFA from it
  if (i <> len_ orelse state->endof = NIL) then
    state = dfa->firststate
    i = 0
    a = NIL
    dfa->dirtydfa = 1
  end if
  while (i < len_) '' make new DFA for s[i..len-1]
    var to_ = dfa_newstate(dfa)
    dfa_newtransition(dfa,state, to_, node_.chr, s[i], node_.normaltrans)
    state = to_
    i += 1
  wend
  coco_string_destroy(s)
  var matchedsym = state->endof
  if (state->endof = NIL) then
    state->endof = sym
  elseif (matchedsym->tokenkind = symbol_.fixedtoken orelse (a <> NIL andalso a->tc = node_.contexttrans)) then
    '' s matched a token with a fixed definition or a token with an appendix that will be cut off
    dim format_ as wchar_t ptr
    format_ = callocate(200,sizeof(wchar_t))
    coco_swprintf(format_, 200, @wstr(!"tokens %ls and %ls cannot be distinguished"), sym->name, matchedsym->name)
    parser_semerr(dfa->parser,format_)
  else '' matchedSym = classToken orelse classLitToken
    matchedsym->tokenkind = symbol_.classlittoken
    sym->tokenkind = symbol_.littoken
  end if

end sub

sub dfa_splitactions(byval dfa as dfa_ ptr,byval state as state_ ptr, byval a as action_ ptr, byval b as action_ ptr)
  
  ''CHECKED
  dim c as action_ ptr
  dim seta as charset_ ptr
  dim setb as charset_ ptr
  dim setc as charset_ ptr
  seta = action_symbols(a,dfa->tab)
  setb = action_symbols(b,dfa->tab)
  if (charset_equals(seta,setb)) then
    action_addtargets(a,b)
    state_detachaction(state,b)
  elseif (charset_includes(seta,setb)) then
    setc = charset_clone(seta)
    charset_subtract(setc,setb)
    action_addtargets(b,a)
    action_shiftwith(a,setc, dfa->tab)
  elseif (charset_includes(setb,seta)) then
    setc = charset_clone(setb)
    charset_subtract(setc,seta)
    action_addtargets(a,b)
    action_shiftwith(b,setc, dfa->tab)
  else
    setc = charset_clone(seta)
    charset_and(setc,setb)
    charset_subtract(seta,setc)
    charset_subtract(setb,setc)
    action_shiftwith(a,seta, dfa->tab)
    action_shiftwith(b,setb, dfa->tab)
    c = action_create(0, 0, node_.normaltrans)  '' typ and sym are set in ShiftWith
    action_addtargets(c,a)
    action_addtargets(c,b)
    action_shiftwith(c,setc, dfa->tab)
    state_addaction(state,c)
  end if

end sub

function dfa_overlap(byval dfa as dfa_ ptr,byval a as action_ ptr, byval b as action_ ptr) as byte
  
  ''CHECKED
  dim seta as charset_ ptr
  dim setb as charset_ ptr
  if (a->typ = node_.chr) then
    if (b->typ = node_.chr) then
      return (a->sym = b->sym)
    else
      setb = tab_charclassset(dfa->tab,b->sym)
      return charset_get(setb,a->sym)
    end if
  else 
    seta = tab_charclassset(dfa->tab,a->sym)
    if (b->typ = node_.chr) then
      return charset_get(seta,b->sym)
    else 
      setb = tab_charclassset(dfa->tab,b->sym)
      return charset_intersects(seta,setb)
    end if
  end if

end function

function dfa_makeunique(byval dfa as dfa_ ptr,byval state as state_ ptr) as byte '' return true if actions were split 
                                                                                 '' return 1 if actions were split
  dim changed as byte = 0
  dim a as action_ ptr = state->firstaction
  while (a <> NIL)
    dim b as action_ ptr = a->next
    while (b <> NIL)
      if (dfa_overlap(dfa,a, b)) then
        dfa_splitactions(dfa,state, a, b)
        changed = 1
      end if
      b = b->next
    wend
    a = a->next
  wend
  return changed

end function

sub dfa_meltstates(byval dfa as dfa_ ptr,byval state as state_ ptr)
  
  dim changed as byte
  dim ctx as byte
  dim targets as bitarray_ ptr
  dim endof as symbol_ ptr
  dim action as action_ ptr = state->firstaction
  while (action <> NIL)
    if (action->target->next <> NIL) then
      dfa_gettargetstates(dfa,action, targets, endof, ctx)
      dim melt as melted_ ptr = dfa_statewithset(dfa,targets)
      if (melt = NIL) then
        var s = dfa_newstate(dfa)
        s->endof = endof
        s->ctx = ctx
        dim targ as target_ ptr = action->target
        while (targ <> NIL) 
          state_meltwith(s,targ->state)
          targ = targ->next
        wend
        do 
          changed = dfa_makeunique(dfa,s)
        loop while (changed)
        melt = dfa_newmelted(dfa,targets, s)
      end if
      action->target->next = NIL
      action->target->state = melt->state
    end if
    action = action->next
  wend

end sub

sub dfa_findctxstates(byval dfa as dfa_ ptr)
  
  ''CHECKED
  dim state as state_ ptr = dfa->firststate
  while (state <> NIL)
    dim a as action_ ptr = state->firstaction
    while (a <> NIL)
      if (a->tc = node_.contexttrans) then
        a->target->state->ctx = 1
      end if      
      a = a->next
    wend
    state = state->next
  wend

end sub

sub dfa_makedeterministic(byval dfa as dfa_ ptr)
  
  ''CHECKED
  dim state as state_ ptr
  dim changed as byte
  dfa->lastsimstate = dfa->laststate->nr
  dfa->maxstates = 2 * dfa->lastsimstate '' heuristic for set size in Melted.set
  dfa_findctxstates(dfa)
  state = dfa->firststate
  while (state <> NIL)
    do 
      changed = dfa_makeunique(dfa,state) 
    loop while (changed)
    state = state->next
  wend
  state = dfa->firststate
  while (state <> NIL)
    dfa_meltstates(dfa,state)
    state = state->next
  wend
  dfa_deleteredundantstates(dfa)
  dfa_combineshifts(dfa)

end sub

sub dfa_printstates(byval dfa as dfa_ ptr)
  
  fwprintf(dfa->trace, @wstr(!"\n"))
  fwprintf(dfa->trace, @wstr(!"---------- states ----------\n"))
  var state = dfa->firststate
  while (state <> NIL) 
    dim first as ubyte = 1
    if (state->endof = NIL) then
      fwprintf(dfa->trace, @wstr(!"               "))
    else 
      var paddedname = tab_name(dfa->tab,state->endof->name)
      fwprintf(dfa->trace, @wstr(!"E(%12s)"), paddedname)
      coco_string_destroy(paddedname)
    end if
    fwprintf(dfa->trace, @wstr(!"%3d:"), state->nr)
    if (state->firstaction = NIL) then
      fwprintf(dfa->trace, @wstr(!"\n"))
    end if
    var action = state->firstaction
    while (action <> NIL)
      if (first) then
        fwprintf(dfa->trace, @wstr(!" "))
        first = 0
      else 
        fwprintf(dfa->trace, @wstr(!"                    "))
      end if
      if (action->typ = node_.clas) then
        fwprintf(dfa->trace, @wstr(!"%ls"), (cast(charclass_ ptr,arraylist_itemat(dfa->tab->classes,action->sym))->name))
      else 
        fwprintf(dfa->trace, @wstr(!"%3s"), dfa_ch(dfa,cast(wchar_t,action->sym)))
      end if
      var targ = action->target
      while (targ <> NIL)
        fwprintf(dfa->trace, @wstr(!"%3d"), targ->state->nr)
        targ = targ->next
      wend
      if (action->tc = node_.contexttrans) then
        fwprintf(dfa->trace, @wstr(!" context\n"))
      else 
        fwprintf(dfa->trace, @wstr(!"\n"))
      end if
      action = action->next
    wend
    state = state->next
  wend
  fwprintf(dfa->trace, @wstr(!"\n---------- character classes ----------\n"))
  tab_writecharclasses(dfa->tab)

end sub

''---------------------------- actions --------------------------------
function dfa_findaction(byval dfa as dfa_ ptr,byval state as state_ ptr, byval ch as wchar_t) as action_ ptr
  
  dim a as action_ ptr = state->firstaction
  while  (a <> NIL)
    if (a->typ = node_.chr andalso ch = a->sym) then
      return a
    elseif (a->typ = node_.clas) then
      var s = tab_charclassset(dfa->tab,a->sym)
      if (charset_get(s,ch)) then
        return a
      end if
    end if
    a = a->next
  wend
  return NIL

end function


sub dfa_gettargetstates(byval dfa as dfa_ ptr,byval a as action_ ptr, _
                        byref targets as bitarray_ ptr, byref endof as symbol_ ptr, byval ctx as byte)
                            
  '' compute the set of target states
  targets = bitarray_create(dfa->maxstates,0)
  endof = NIL
  ctx = 0
  var t = a->target
  while(t <> NIL)
    var statenr = t->state->nr
    if (statenr <= dfa->lastsimstate) then
      bitarray_set(targets,statenr, 1)
    else      
      bitarray_or(targets,dfa_meltedset(dfa,statenr))
    end if    
    if (t->state->endof <> NIL) then
      if (endof = NIL orelse endof = t->state->endOf) then
        endof = t->state->endof
      else
        wprintf(@wstr(!"Tokens %ls and %ls cannot be distinguished\n"), endof->name, t->state->endof->name)
        dfa->errors->count += 1
      end if
    end if
    if (t->state->ctx) then
      ctx = 1
      '' The following check seems to be unnecessary. It reported an error
      '' if a symbol + context was the prefix of another symbol, e.g.
      ''   s1 = "a" "b" "c".
      ''   s2 = "a" CONTEXT("b").
      '' But this is ok.
      '' if (t.state.endOf != null) {
      ''   Console.WriteLine("Ambiguous context clause");
      ''   Errors.count++;
      '' }
    end if
    t = t->next
  wend

end sub


''------------------------- melted states ------------------------------

function dfa_newmelted(byval dfa as dfa_ ptr,byval set as bitarray_ ptr, byval state as state_ ptr) as melted_ ptr
  
  var m = melted_create(set, state)
  m->next = dfa->firstmelted 
  dfa->firstmelted = m
  return m

end function

function dfa_meltedset(byval dfa as dfa_ ptr,byval nr as integer) as bitarray_ ptr
  
  var m = dfa->firstmelted
  while (m <> NIL) 
    if (m->state->nr = nr) then
      return m->set
    else 
      m = m->next
    end if
  wend
  ''Errors::Exception("-- compiler error in Melted::Set");
  ''throw new Exception("-- compiler error in Melted::Set");
  return NIL

end function

function dfa_statewithset(byval dfa as dfa_ ptr,byval s as bitarray_ ptr) as melted_ ptr
  
  var m = dfa->firstmelted
  while (m <> NIL)
    if (sets_equals(s, m->set)) then
      return m
    end if
    m = m->next
  wend
  
  return NIL

end function

''------------------------ comments --------------------------------
function dfa_commentstr(byval dfa as dfa_ ptr,byval p as node_ ptr) as wchar_t ptr
  
  var s = stringbuilder_create()
  while (p <> NIL) 
    if (p->typ = node_.chr) then
      stringbuilder_appendwc(s,cast(wchar_t,p->val_))
    elseif (p->typ = node_.clas) then
      var set = tab_charclassset(dfa->tab,p->val_)
      if (charset_elements(set) <> 1) then
        parser_semerr(dfa->parser,@wstr("character set contains more than 1 character"))
      end if
      stringbuilder_appendwc(s,cast(wchar_t,charset_first(set)))
    else 
      parser_semerr(dfa->parser,@wstr(!"comment delimiters may not be structured"))
    end if
    p = p->next_
  wend
  if (stringbuilder_getlength(s) = 0 orelse stringbuilder_getlength(s) > 2) then
    parser_semerr(dfa->parser,@wstr("comment delimiters must be 1 or 2 characters long"))
    s = stringbuilder_create_wchar(@wstr("?"))
  end if
  return stringbuilder_tostring(s)

end function


sub dfa_newcomment(byval dfa as dfa_ ptr,byval from_ as node_ ptr, byval to_ as node_ ptr, byval nested as byte)
  
  var c = comment_create(dfa_commentstr(dfa,from_), dfa_commentstr(dfa,to_), nested)
  c->next = dfa->firstcomment
  dfa->firstcomment = c

end sub


''------------------------ scanner generation ----------------------

sub dfa_gencombody(byval dfa as dfa_ ptr,byval com_ as comment_ ptr)
  
  fwprintf(dfa->gen, @wstr(!"    while(1)\n"))

  var res = dfa_chcond(dfa,com_->stop[0])
  fwprintf(dfa->gen, @wstr(!"      if (%ls) then"), res)
  fwprintf(dfa->gen, @wstr(!"\n"))
  coco_string_destroy(res)

  if (coco_string_length(com_->stop) = 1) then
    fwprintf(dfa->gen, @wstr(!"        level -=1\n"))
    fwprintf(dfa->gen, @wstr(!"        if (level = 0) then\n          scanner->oldeols = scanner->line - line0\n          scanner_nextch(scanner)\n          return 1\n        end if\n"))
    fwprintf(dfa->gen, @wstr(!"        scanner_nextch(scanner)\n"))
  else 
    fwprintf(dfa->gen, @wstr(!"        scanner_nextch(scanner)\n"))
    var res = dfa_chcond(dfa,com_->stop[1])
    fwprintf(dfa->gen, @wstr(!"        if (%ls) then\n"), res)
    deallocate(res)
    fwprintf(dfa->gen, @wstr(!"          level -= 1\n"))
    fwprintf(dfa->gen, @wstr(!"          if (level = 0) then\n            scanner->oldeols = scanner->line - line0\n            scanner_nextch(scanner)\n            return 1\n          end if\n"))
    fwprintf(dfa->gen, @wstr(!"          scanner_nextch(scanner)\n"))
    fwprintf(dfa->gen, @wstr(!"        end if\n"))
    ''AGS prevent output of end if when generating an elseif next
    if (com_-> nested = 0) then
      fwprintf(dfa->gen, @wstr(!"        end if\n"))
    end if
  end if
  if (com_->nested) then
      ''fwprintf(dfa->gen, @wstr(!"      end if"))
      var res = dfa_chcond(dfa,com_->start[0])
      fwprintf(dfa->gen, @wstr(!"      elseif(%ls) then"), res)
      coco_string_destroy(res)
      fwprintf(dfa->gen, @wstr(!"\n"))
    if (coco_string_length(com_->stop) = 1) then
      fwprintf(dfa->gen, @wstr(!"        level += 1:scanner_nextch(scanner)\n"))
    else 
      fwprintf(dfa->gen, @wstr(!"        scanner_nextch(scanner)\n"))
      var res = dfa_chcond(dfa,com_->start[1])
      fwprintf(dfa->gen, @wstr(!"        if (%ls) then"), res)
      coco_string_destroy(res)
      fwprintf(dfa->gen, @wstr(!"\n"))
      fwprintf(dfa->gen, @wstr(!"          level += 1: scanner_nextch(scanner)\n"))
      fwprintf(dfa->gen, @wstr(!"        end if\n"))
    end if
  end if
  fwprintf(dfa->gen, @wstr(!"      elseif (scanner->ch = buffer_._EoF) then\n        return 0\n"))
  fwprintf(dfa->gen, @wstr(!"      else\n        scanner_nextch(scanner)\n      end if\n"))
  fwprintf(dfa->gen, @wstr(!"    wend\n"))

end sub


sub dfa_gencommentheader(byval dfa as dfa_ ptr,byval com_ as comment_ ptr, byval i as integer)
  
  fwprintf(dfa->gen, @wstr(!"  declare function scanner_comment%d(byval scanner as scanner_ ptr) as byte\n"), i)

end sub

sub dfa_gencomment(byval dfa as dfa_ ptr,byval com_ as comment_ ptr, byval i as integer)

  fwprintf(dfa->gen, @wstr(!"\n"))
  fwprintf(dfa->gen, @wstr(!"function scanner_comment%d(byval scanner as scanner_ ptr) as byte"), i)
  fwprintf(dfa->gen, @wstr(!"\n\n"))
  fwprintf(dfa->gen, @wstr(!"  dim as integer level = 1,pos0 = scanner->pos, line0 = scanner->line, col0 = scanner->col, charpos0 = scanner->charpos\n"))
  if (coco_string_length(com_->start) = 1) then
    fwprintf(dfa->gen, @wstr(!"  scanner_nextch(scanner)\n"))
    dfa_gencombody(dfa,com_)
  else 
    fwprintf(dfa->gen, @wstr(!"  scanner_nextch(scanner)\n"))
    var res = dfa_chcond(dfa,com_->start[1])
    fwprintf(dfa->gen, @wstr(!"  if (%ls) then"), res)
    coco_string_destroy(res)
    fwprintf(dfa->gen, @wstr(!"\n"))

    fwprintf(dfa->gen, @wstr(!"    scanner_nextch(scanner)\n"))
    dfa_gencombody(dfa,com_)

    fwprintf(dfa->gen, @wstr(!"  else\n"))
    fwprintf(dfa->gen, @wstr(!"    scanner->buffer->setpos_(scanner->buffer,pos0)\n    scanner_nextch(scanner)\n    scanner->line = line0\n    scanner->col = col0\n    scanner->charpos = charpos0\n"))
    fwprintf(dfa->gen, @wstr(!"  end if\n"))
    fwprintf(dfa->gen, @wstr(!"  return 0\n\n"))
  end if
  fwprintf(dfa->gen, @wstr(!"end function\n"))

end sub

function dfa_symname(byval dfa as dfa_ ptr,byval sym as symbol_ ptr) as wchar_t ptr '' real name value is stored in tab.literals
  
  if ((asc("a")<=sym->name[0] andalso sym->name[0]<=asc("z")) orelse _
      (asc("A")<=sym->name[0] andalso sym->name[0]<=asc("Z"))) then ''Char::IsLetter(sym->name[0])

    var iter = hashtable_getiterator(dfa->tab->literals)
    while (iter_hasnext(iter)) 
      var e = iter_next(iter)
      if (e->value = sym) then
        return e->key
      end if
    wend
  end if
  return sym->name

end function

sub dfa_genliterals (byval dfa as dfa_ ptr)
  
  dim sym as symbol_ ptr

  dim ts(0 to 1) as arraylist_ ptr
  ts(0) = dfa->tab->terminals
  ts(1) = dfa->tab->pragmas
  
  fwprintf(dfa->gen,@wstr(!"  scanner->keywords = keywordmap_create()\n"))
  for i as integer = 0 to 1
    for j as integer = 0 to ts(i)->count - 1
      sym = cast(symbol_ ptr,arraylist_itemat(ts(i),j))
      if (sym->tokenkind = symbol_.littoken) then
        var name_ = coco_string_create(dfa_symname(dfa,sym))
        if (dfa->ignorecase) then
          var oldname = name_
          name_ = coco_string_create_lower(name_)
          coco_string_destroy(oldname)
        end if
        '' sym.name stores literals with quotes, e.g. "\"Literal\""
        fwprintf(dfa->gen, @wstr(!"  keywordmap_set(scanner->keywords,@wstr(!"))
        '' write keyword, escape non printable characters
        var k = 0
        while (name_[k] <> asc(!"\0"))
          var c = name_[k]
          ''FIXME format of "\\x%04x" is not correct
          fwprintf(dfa->gen, iif((c >= 32 andalso c <= 127),@wstr(!"%lc"),@wstr(!"\\x%04x")), c)
          k += 1
        wend
        fwprintf(dfa->gen, @wstr(!"), %d)\n"), sym->n)
        coco_string_destroy(name_)
      end if
    next j
  next i

end sub

function dfa_gennamespaceopen(byval dfa as dfa_ ptr,byval nsname as wchar_t ptr) as integer
  
  if (nsname = NIL orelse coco_string_length(nsname) = 0) then
    return 0
  end if
  var len_ = coco_string_length(nsname)
  var startpos = 0
  var nrofns = 0
  do 
    var curlen = coco_string_indexof(nsname + startpos, asc(":"))
    if (curlen = -1) then
      curlen = len_ - startpos
    end if
    var curns = coco_string_create_il(nsname, startpos, curlen)
    fwprintf(dfa->gen, @wstr(!"namespace %ls \n"), curns)
    coco_string_destroy(curns)
    startpos = startpos + curlen + 1
    nrofns += 1
  loop while (startpos < len_)
  return nrofns

end function

sub dfa_gennamespaceclose(byval dfa as dfa_ ptr,byval nrofns as integer)
  
  ''AGS no namespace
  'for i as integer = 0 to nrofns
  '  fwprintf(dfa->gen, @wstr(!"end namespace '' namespace\n"))
  'next i

end sub

sub dfa_checklabels(byval dfa as dfa_ ptr)
  
  dim i as integer
  dim state as state_ ptr
  dim action as action_ ptr

  for i = 0 to dfa->laststatenr
    dfa->existlabel[i] = 0
  next i

  state = dfa->firststate->next
  while (state <> NIL)  
    action = state->firstaction
    while (action <> NIL)    
      dfa->existlabel[action->target->state->nr] = 1
      action = action->next
    wend
    state = state->next
  wend

end sub

''TODO change printing 'magic' numbers to writing symbolic names (based
''on www.unicode.org/public/unidata/unicodedata.txt)
sub dfa_writestate(byval dfa as dfa_ ptr,byval state as state_ ptr)
  
  var endof = state->endof
  fwprintf(dfa->gen, @wstr(!"    case %d:\n"), state->nr)
  if (dfa->existlabel[state->nr]) then
    fwprintf(dfa->gen, @wstr(!"      case_%d:\n"), state->nr)
  end if

  if (endof <> NIL andalso state->firstaction <> NIL) then
    fwprintf(dfa->gen, @wstr(!"      recend = scanner->pos:reckind = %d\n"), endof->n)
  end if
  
  var ctxend = state->ctx

  var action = state->firstaction
  while (action <> NIL) 
    if (action = state->firstaction) then
      fwprintf(dfa->gen, @wstr(!"      if ("))    
    else 
      fwprintf(dfa->gen, @wstr(!"      elseif ("))
    end if
    if (action->typ = node_.chr) then
      var res = dfa_chcond(dfa,cast(wchar_t,action->sym))
      fwprintf(dfa->gen, @wstr(!"%ls"), res)
      coco_string_destroy(res)
    else 
      dfa_putrange(dfa,tab_charclassset(dfa->tab,action->sym))
    end if
    fwprintf(dfa->gen, @wstr(!") then\n"))

    if (action->tc = node_.contexttrans) then
      fwprintf(dfa->gen, @wstr(!"apx += 1 "))
      ctxend = 0
    elseif (state->ctx) then
      fwprintf(dfa->gen, @wstr(!"apx = 0 "))
    end if
    fwprintf(dfa->gen, @wstr(!"        scanner_addch(scanner):goto case_%d"), action->target->state->nr)
    fwprintf(dfa->gen, @wstr(!"\n"))
    action = action->next
  wend
  if (state->firstaction = NIL) then
    fwprintf(dfa->gen, @wstr(!"      "))
  else
    fwprintf(dfa->gen, @wstr(!"      else\n"))
  end if
  if (ctxend) then '' final context state: cut appendix
    fwprintf(dfa->gen, @wstr(!"\n"))
    fwprintf(dfa->gen, @wstr(!"        scanner->tlen -= apx\n"))
    fwprintf(dfa->gen, @wstr(!"        scanner_setscannerbehindt(scanner)"))

    fwprintf(dfa->gen, @wstr(!"        buffer_setpos(scanner->buffer,scanner->t->pos)\nscanner_nextch(scanner)\n  scanner->line = scanner->t->line\n  scanner->col = scanner->t->col\n"))
    fwprintf(dfa->gen, @wstr(!"        for i as integer = 0 to tlen - 1\n          scanner_nextch(scanner)\n        next i\n"))
    fwprintf(dfa->gen, @wstr(!"        "))
  end if
  if (endof = NIL) then
    fwprintf(dfa->gen, @wstr(!"        goto case_0\n      end if\n"))
  else
    if (state->firstaction = NIL) then
      fwprintf(dfa->gen, @wstr(!"scanner->t->kind = %d:exit select\n"), endof->n)
    else
      fwprintf(dfa->gen, @wstr(!"        scanner->t->kind = %d\n"), endof->n)
    end if
    if (endof->tokenkind = symbol_.classlittoken) then
      if (dfa->ignorecase) then
        fwprintf(dfa->gen, @wstr(!"        var literal = coco_string_create_lower(scanner->tval, 0, scanner->tlen)\n        scanner->t->kind = keywordmap_get(scanner->keywords,literal, scanner->t->kind)\n        coco_string_delete(literal)\n"))
      else
        fwprintf(dfa->gen, @wstr(!"        var literal = coco_string_create_il(scanner->tval, 0, scanner->tlen)\n        scanner->t->kind = keywordmap_get(scanner->keywords,literal, scanner->t->kind)\n        coco_string_destroy(literal)\n"))
      end if
      ''AGS when there is an else append end if
      if (state->firstaction <> NIL) then
        fwprintf(dfa->gen, @wstr(!"        exit select\n"))
        fwprintf(dfa->gen,@wstr(!"      end if\n"))
      else
        fwprintf(dfa->gen, @wstr(!"      exit select\n"))
      end if
    else 
      if (state->firstaction <> NIL) then
        fwprintf(dfa->gen, @wstr(!"        exit select\n"))
        fwprintf(dfa->gen,@wstr(!"      end if\n"))
      else
        'fwprintf(dfa->gen, @wstr(!"      exit select\n"))
      end if      
    end if
  end if

end sub

sub dfa_writestarttab(byval dfa as dfa_ ptr)

  dim firstrange as byte = 1
  var action = dfa->firststate->firstaction
  fwprintf(dfa->gen,@wstr(!"  scanner->start = startstates_create()\n"))
  while (action <> NIL)
    var targetstate = action->target->state->nr
    if (action->typ = node_.chr) then
      fwprintf(dfa->gen, @wstr(!"  startstates_set(scanner->start,%d, %d)\n"), action->sym, targetstate)
    else 
      var s = tab_charclassset(dfa->tab,action->sym)
      var r = s->head
      while (r <> NIL)
        if (firstrange) then
          firstrange = 0
          fwprintf(dfa->gen, @wstr(!"  dim i as integer\n"))
        end if
        fwprintf(dfa->gen, @wstr(!"  for i = %d to %d\n    startstates_set(scanner->start,i, %d)\n  next i\n"), r->from, r->to, targetstate)
        r = r->next
      wend
    end if
    action = action->next
  wend
  fwprintf(dfa->gen, @wstr(!"  startstates_set(scanner->start,buffer_._EoF, -1)\n"))

end sub

sub dfa_writescanner(byval dfa as dfa_ ptr)
  
  dim g as generator_ ptr = generator_create(dfa->tab, dfa->errors)
  dfa->fram = generator_openframe(g,@wstr("Scanner.frame"))
  dfa->gen = generator_opengen(g,@wstr("Scanner.bi"))

  if (dfa->dirtydfa) then
    dfa_makedeterministic(dfa)
  end if

  '' Header
  generator_copyright(g)
  generator_copyframepart(g,@wstr("-->begin"))

  generator_copyframepart(g,@wstr("-->namespace_open"))
  var nrofns = dfa_gennamespaceopen(dfa,dfa->tab->nsname)

  generator_copyframepart(g,@wstr("-->casing0"))
  if (dfa->ignorecase) then
    fwprintf(dfa->gen, @wstr(!"  dim valch as wchar_t       '' current input character (for token.val)\n"))
  end if
  generator_copyframepart(g,@wstr("-->commentsheader"))
  var com = dfa->firstcomment
  var cmdidx = 0
  while (com <> NIL) 
    dfa_gencommentheader(dfa,com, cmdIdx)
    com = com->next
    cmdidx += 1
  wend

  generator_copyframepart(g,@wstr("-->namespace_close"))
  dfa_gennamespaceclose(dfa,nrofns)

  generator_copyframepart(g,@wstr("-->implementation"))
  fclose(dfa->gen)

  '' Source
  dfa->gen = generator_opengen(g,@wstr("Scanner.bas"))
  generator_copyright(g)
  generator_skipframepart(g,@wstr("-->begin"))
  generator_copyframepart(g,@wstr("-->namespace_open"))
  nrofns = dfa_gennamespaceopen(dfa,dfa->tab->nsname)

  generator_copyframepart(g,@wstr("-->declarations"))
  fwprintf(dfa->gen, @wstr(!"  scanner->maxt = %d\n"), dfa->tab->terminals->count - 1)
  fwprintf(dfa->gen, @wstr(!"  scanner->nosym = %d\n"), dfa->tab->noSym->n)
  dfa_writestarttab(dfa)
  dfa_genliterals(dfa)

  generator_copyframepart(g,@wstr("-->initialization"))
  generator_copyframepart(g,@wstr("-->casing1"))
  ''TODO case sensitivity assumes ASCII. ignorecase will not work on unicode content
  ''(rules for unicode uppercase/lowercase can be found in unicodedata.txt, other unicode 
  ''tables and/or by means of a call to unicode functions dealing with case conversion)
  if (dfa->ignorecase) then
    fwprintf(dfa->gen, @wstr(!"    valch = scanner->ch\n"))
    fwprintf(dfa->gen, @wstr(!"    if (asc(\"A\") <= scanner->ch andalso scanner->ch <= asc(\"Z\")) then\n    scanner->ch = scanner->ch - asc(\"A\") + asc(\"a\") '' ch.ToLower()\n  end if"))
  end if
  generator_copyframepart(g,@wstr("-->casing2"))
  fwprintf(dfa->gen, @wstr(!"    scanner->tval[scanner->tlen] = "))
  if (dfa->ignorecase) then
    fwprintf(dfa->gen,@wstr(!"valch"))
  else 
    fwprintf(dfa->gen, @wstr(!"scanner->ch"))
  end if
  ''AGS
  fwprintf(dfa->gen,@wstr(!":scanner->tlen += 1"))
  generator_copyframepart(g,@wstr("-->comments"))
  com = dfa->firstcomment
  cmdidx = 0
  while (com <> NIL) 
    dfa_gencomment(dfa,com, cmdidx)
    com = com->next
    cmdidx += 1
  wend

  generator_copyframepart(g,@wstr("-->scan1"))
  fwprintf(dfa->gen, @wstr(!"      "))
  if (charset_elements(dfa->tab->ignored) > 0) then
    dfa_putrange(dfa,dfa->tab->ignored)
    fwprintf(dfa->gen,@wstr("_"))
  else 
    fwprintf(dfa->gen, @wstr(!"(0) _"))
  end if  
  generator_copyframepart(g,@wstr("-->scan2"))
  if (dfa->firstcomment <> NIL) then
    fwprintf(dfa->gen, @wstr(!"  if ("))
    com = dfa->firstcomment
    cmdidx = 0
    while (com <> NIL)
      var res = dfa_chcond(dfa,com->start[0])
      fwprintf(dfa->gen, @wstr(!"(%ls andalso scanner_comment%d(scanner))"), res, cmdidx)
      deallocate(res)
      if (com->next <> NIL) then
        fwprintf(dfa->gen, @wstr(!" orelse _\n      "))
      end if
      com = com->next
      cmdidx += 1
    wend
    fwprintf(dfa->gen, @wstr(!") then\n    return scanner_nexttoken(scanner)\n  end if"))
  end if
  if (dfa->hasctxmoves) then
    fwprintf(dfa->gen, @wstr(!"\n"))
    fwprintf(dfa->gen, @wstr(!"  dim apx as integer = 0")) /' pdt '/
  end if
  generator_copyframepart(g,@wstr("-->scan3"))

  /' CSB 02-10-05 check the Labels '/
  dfa->existlabel = callocate(dfa->laststatenr+1,sizeof(byte))
  dfa_checklabels(dfa)
  var state = dfa->firststate->next
  while (state <> NIL)  
    dfa_writestate(dfa,state)
    state = state->next
  wend
  deallocate(dfa->existlabel)

  generator_copyframepart(g,@wstr("-->namespace_close"))
  dfa_gennamespaceclose(dfa,nrofns)

  generator_copyframepart(g,NIL)
  fclose(dfa->gen)

end sub

function dfa_create(byval parser as parser_ ptr) as dfa_ ptr
  
  dim dfa as dfa_ ptr
  dfa = callocate(1,sizeof(dfa_))

  dfa->parser = parser
  dfa->tab = parser->tab
  dfa->errors = parser->errors
  dfa->trace = parser->trace
  dfa->firststate = NIL
  dfa->laststate = NIL
  dfa->laststatenr = -1
  dfa->firststate = dfa_newstate(dfa)
  dfa->firstmelted = NIL
  dfa->firstcomment = NIL
  dfa->ignorecase = 0
  dfa->dirtydfa = 0
  dfa->hasctxmoves = 0

  return dfa

end function

''STUB
sub dfa_destroy(byref dfa as dfa_ ptr)

  if (dfa = NIL) then
    return
  end if
  deallocate(dfa)
  
end sub


#include once "crt/wchar.bi"
'#include once "Parser.bi"
'#include once "Scanner.bi"

sub parser_initdeclarations(byval parser as parser_ ptr)

    parser->id  = 0
    parser->str = 1
    parser->tokenstring = NIL
    parser->nostring = coco_string_create(@wstr(!"-none-"))

end sub

sub parser_synerr(byval parser as parser_ ptr, byval n as integer)
  
  if (parser->errdist >= parser->minerrdist) then
    errors_synerr(parser->errors,parser->la->line, parser->la->col, n)
  end if
  parser->errdist = 0

end sub

sub parser_semerr(byval parser as parser_ ptr, byval msg as wchar_t ptr)
  
  if (parser->errdist >= parser->minerrdist) then
    errors_error(parser->errors,parser->t->line, parser->t->col, msg)
  end if
  parser->errdist = 0

end sub

sub parser_get(byval parser as parser_ ptr)
  
  while (1)
    parser->t = parser->la
    parser->la = scanner_scan(parser->scanner)
    if (parser->la->kind <= parser->maxt) then
       parser->errdist += 1
       exit while
    end if
    if (parser->la->kind = 42) then
        tab_setddt(parser->tab,parser->la->val)
    end if
    if (parser->la->kind = 43) then
        tab_setoption(parser->tab,parser->la->val)
    end if

    if (parser->dummytoken <> parser->t) then
      parser->dummytoken->kind = parser->t->kind
      parser->dummytoken->pos = parser->t->pos
      parser->dummytoken->col = parser->t->col
      parser->dummytoken->line = parser->t->line
      parser->dummytoken->next = NIL
      coco_string_destroy(parser->dummytoken->val)
      parser->dummytoken->val = coco_string_create(parser->t->val)
      parser->t = parser->dummytoken
    end if
    parser->la = parser->t
  wend

end sub

sub parser_expect(byval parser as parser_ ptr, byval n as integer) 
  
  if (parser->la->kind = n) then
    parser_get(parser)
  else 
    parser_synerr(parser,n)
  end if

end sub

sub parser_expectweak(byval parser as parser_ ptr, byval n as integer, byval follow as integer)
  
  if (parser->la->kind = n) then
    parser_get(parser)
  else 
    parser_synerr(parser,n)
    while (parser_startof(parser,follow) = 0)
      parser_get(parser)
    wend
  end if

end sub

function parser_weakseparator(byval parser as parser_ ptr, byval n as integer, _
                              byval syfol as integer, byval repfol as integer) as byte
  
  if (parser->la->kind = n) then
    parser_get(parser)
    return 1
  elseif (parser_startof(parser,repfol)) then
    return 0
  else
    parser_synerr(parser,n)
    while (parser_startof(parser,syfol) = 0 orelse parser_startof(parser,repfol) orelse parser_startof(parser,0))
      parser_get(parser)
    wend
    return parser_startof(parser,syfol)
  end if

end function

sub parser_coco(byval parser as parser_ ptr)
    
    dim sym as symbol_ ptr
    dim g as graph_ ptr
    dim g1 as graph_ ptr
    dim g2 as graph_ ptr
    dim gramname as wchar_t ptr = NIL
    dim s as charset_ ptr
    
    DWPRINTFUN

    parser_initdeclarations(parser)
    var beg = parser->la->pos
    var line_ = parser->la->line
    while (parser_startof(parser,1)) 
      parser_get(parser)
    wend
    
    if (parser->la->pos <> beg) then
      parser->pgen->usingpos = position_create(beg, parser->t->pos + coco_string_length(parser->t->val), 0, line_)
    end if
    
    parser_expect(parser,6)
    parser->genscanner = 1
    parser->tab->ignored = charset_create()
    parser_expect(parser,1)
    gramname = coco_string_create(parser->t->val)
    beg = parser->la->pos
    line_ = parser->la->line
    
    while (parser_startof(parser,2)) 
      parser_get(parser)
    wend
    parser->tab->semdeclpos = position_create(beg, parser->la->pos, 0, line_)
    if (parser->la->kind = 7) then
      parser_get(parser)
      parser->dfa->ignorecase = 1
    end if
    if (parser->la->kind = 8) then
      parser_get(parser)
      while (parser->la->kind = 1) 
        parser_setdecl(parser)
      wend
    end if
    if (parser->la->kind = 9) then
      parser_get(parser)
      while (parser->la->kind = 1 orelse parser->la->kind = 3 orelse parser->la->kind = 5)
        parser_tokendecl(parser,node_.t)
      wend
    end if
    if (parser->la->kind = 10) then
      parser_get(parser)
      while (parser->la->kind = 1 orelse parser->la->kind = 3 orelse parser->la->kind = 5)
        parser_tokendecl(parser,node_.pr)
      wend
    end if
    while (parser->la->kind = 11) 
      parser_get(parser)
      dim nested as byte = 0
      parser_expect(parser,12)
      parser_tokenexpr(parser,g1)
      parser_expect(parser,13)
      parser_tokenexpr(parser,g2)
      if (parser->la->kind = 14) then
        parser_get(parser)
        nested = 1
      end if
      dfa_newcomment(parser->dfa,g1->l, g2->l, nested)
    wend
    while (parser->la->kind = 15) 
      parser_get(parser)
      parser_set(parser,s)
      charset_or(parser->tab->ignored,s)
    wend
    while (0=(parser->la->kind = 0 orelse parser->la->kind = 16))
      parser_synerr(parser,42)
      parser_get(parser)
    wend
    parser_expect(parser,16)
    if (parser->genscanner) then
      dfa_makedeterministic(parser->dfa)
    end if
    tab_deletenodes(parser->tab)
    
    while (parser->la->kind = 1)
      parser_get(parser)
      sym = tab_findsym(parser->tab,parser->t->val)
      dim undef as byte
      if (sym = NIL) then
        undef = 1
      else
        undef = 0
      end if
      if (undef) then
        sym = tab_newsym(parser->tab,node_.nt, parser->t->val, parser->t->line)
      else
        if (sym->typ = node_.nt) then
          if (sym->graph <> NIL) then
            parser_semerr(parser,@wstr(!"name declared twice"))
          end if            
        else 
          parser_semerr(parser,@wstr(!"this symbol kind not allowed on left side of production"))
        end if
        sym->line = parser->t->line
      end if
      dim noattrs as byte 
      if (sym->attrpos = NIL) then
        noattrs = 1
      else
        noattrs = 0
      end if
      
      sym->attrpos = NIL
      
      if (parser->la->kind = 24 orelse parser->la->kind = 26) then
        parser_attrdecl(parser,sym)
      end if
      
      if (undef = 0) then
       'if (noattrs <> (sym->attrpos = NIL)) then
       if (noattrs <> iif(sym->attrpos=NIL,1,0)) then
         parser_semerr(parser,@wstr(!"attribute mismatch between declaration and use of this symbol"))
       end if
      end if
      
      if (parser->la->kind = 39) then
        parser_semtext(parser,sym->sempos)
      end if
      parser_expectweak(parser,17, 3)
      parser_expression(parser,g)
      sym->graph = g->l
      tab_finish(parser->tab,g)
      parser_expectweak(parser,18, 4)
    wend
    parser_expect(parser,19)
    parser_expect(parser,1)
    if (coco_string_equal(gramname, parser->t->val) = 0) then
      parser_semerr(parser,@wstr(!"name does not match grammar name"))
    end if
    parser->tab->gramsy = tab_findsym(parser->tab,gramname)
    if (parser->tab->gramsy = NIL) then
      parser_semerr(parser,@wstr(!"missing production for grammar name"))
    else
      sym = parser->tab->gramsy
      if (sym->attrpos <> NIL) then
        parser_semerr(parser,@wstr(!"grammar symbol must not have attributes"))
      end if
    end if
    parser->tab->nosym = tab_newsym(parser->tab,node_.t, @wstr("???"), 0) '' nosym gets highest number
    tab_setupanys(parser->tab)
    tab_renumberpragmas(parser->tab)
    if (parser->tab->ddt(2)) then
      tab_printnodes(parser->tab)
    end if
    if (parser->errors->count = 0) then
      wprintf(@wstr(!"checking\n"))
      tab_compsymbolsets(parser->tab)
      if (parser->tab->ddt(7)) then
        tab_xref(parser->tab)
      end if
      if (tab_grammarok(parser->tab)) then
        wprintf(@wstr("parser"))
        parsergen_writeparser(parser->pgen)
        if (parser->genscanner) then
          wprintf(@wstr(" + scanner"))
          dfa_writescanner(parser->dfa)
          if (parser->tab->ddt(0)) then
            dfa_printstates(parser->dfa)
          end if
        end if
        wprintf(@wstr(!" generated\n"))
        if (parser->tab->ddt(8)) then
          parsergen_writestatistics(parser->pgen)
        end if
      end if
    end if
    if (parser->tab->ddt(6)) then
      tab_printsymboltable(parser->tab)
    end if
    
    parser_expect(parser,18)

DWPRINTFUNE:end sub

sub parser_setdecl(byval parser as parser_ ptr)
    
    DWPRINTFUN
    dim s as charset_ ptr
    ''(1,ident)
    parser_expect(parser,1)
    dim name_ as wchar_t ptr = coco_string_create(parser->t->val)
    dim c as charclass_ ptr = tab_findcharclass_wchar(parser->tab,name_)
    if (c <> NIL) then
      parser_semerr(parser,@wstr(!"name declared twice"))
    end if
    
    '(17,'=')
    parser_expect(parser,17)
    parser_set(parser,s)
    if (charset_elements(s) = 0) then
      parser_semerr(parser,@wstr(!"character set must not be empty"))
    end if
    tab_newcharclass(parser->tab,name_, s)
    
    parser_expect(parser,18)

DWPRINTFUNE:end sub

sub parser_tokendecl(byval parser as parser_ ptr,byval typ as integer)
    
    dim name_ as wchar_t ptr = NIL
    dim kind as integer
    dim sym as symbol_ ptr 
    dim g as graph_ ptr
    
    DWPRINTFUN
    parser_sym(parser,name_, @kind)
    sym = tab_findsym(parser->tab,name_)
    if (sym <> NIL) then
      parser_semerr(parser,@wstr(!"name declared twice"))
    else 
      sym = tab_newsym(parser->tab,typ, name_, parser->t->line)
      sym->tokenkind = symbol_.fixedtoken
    end if
    
    parser->tokenstring = NIL
    
    while (0=(parser_startof(parser,5))) 
      parser_synerr(parser,43)
      parser_get(parser)
    wend
    if (parser->la->kind = 17) then
      parser_get(parser)
      parser_tokenexpr(parser,g)
      parser_expect(parser,18)
      if (kind = parser->str) then
        parser_semerr(parser,@wstr(!"a literal must not be declared with a structure"))
      end if
      tab_finish(parser->tab,g)
      if (parser->tokenstring = NIL orelse coco_string_equal(parser->tokenstring, parser->nostring)) then
        dfa_converttostates(parser->dfa,g->l, sym)
      else  '' TokenExpr is a single string
        if (hashtable_itemat(parser->tab->literals,parser->tokenstring) <> NIL) then
          parser_semerr(parser,@wstr(!"token string declared twice"))
        end if
        hashtable_set(parser->tab->literals,parser->tokenstring, sym)
        dfa_matchliteral(parser->dfa,parser->tokenstring, sym)
      end if
    elseif (parser_startof(parser,6)) then
      if (kind = parser->id) then
        parser->genscanner = 0
      else 
        dfa_matchliteral(parser->dfa,sym->name, sym)
      end if
    else 
      parser_synerr(parser,44)
    end if
    if (parser->la->kind = 39) then
      parser_semtext(parser,sym->sempos)
      if (typ <> node_.pr) then
        parser_semerr(parser,@wstr("semantic action not allowed here"))
      end if
    end if

DWPRINTFUNE:end sub

sub parser_tokenexpr(byval parser as parser_ ptr, byref g as graph_ ptr)
    
    dim g2 as graph_ ptr
    
    DWPRINTFUN
    parser_tokenterm(parser,g)
    dim first as byte = 1
    while (parser_weakseparator(parser,28,8,7) ) 
      parser_tokenterm(parser,g2)
      if (first) then
        tab_makefirstalt(parser->tab,g)
        first = 0
      end if
      tab_makealternative(parser->tab,g, g2)
    wend

DWPRINTFUNE:end sub

sub parser_set(byval parser as parser_ ptr, byref s as charset_ ptr) 
    
    DWPRINTFUN
    dim s2 as charset_ ptr
    parser_simset(parser,s)
    while (parser->la->kind = 20 orelse parser->la->kind = 21)
      if (parser->la->kind = 20) then
        parser_get(parser)
        parser_simset(parser,s2)
        charset_or(s,s2)
      else 
        parser_get(parser)
        parser_simset(parser,s2)
        charset_subtract(s,s2) 
      end if
    wend

DWPRINTFUNE:end sub

sub parser_attrdecl(byval parser as parser_ ptr,byref  sym as symbol_ ptr)
    
    DWPRINTFUN
    if (parser->la->kind = 24) then
      parser_get(parser)
      var beg = parser->la->pos
      var col = parser->la->col
      var line_ = parser->la->line
      while (parser_startof(parser,9))
        if (parser_startof(parser,10)) then
          parser_get(parser)
        else
          parser_get(parser)
          parser_semerr(parser,@wstr("bad string in attributes"))
        end if
      wend
      parser_expect(parser,25)
      if (parser->t->pos > beg) then
       sym->attrpos = position_create(beg, parser->t->pos, col, line_)
      end if
    elseif (parser->la->kind = 26) then
      parser_get(parser)
      var beg = parser->la->pos
      var col = parser->la->col
      var line_ = parser->la->line
      while (parser_startof(parser,11)) 
        if (parser_startof(parser,12)) then
          parser_get(parser)
        else 
          parser_get(parser)
          parser_semerr(parser,@wstr("bad string in attributes"))
        end if
      wend
      parser_expect(parser,27)
      if (parser->t->pos > beg) then
        sym->attrpos = position_create(beg, parser->t->pos,col, line_)
      end if
    else 
      parser_synerr(parser,45)
    end if

DWPRINTFUNE:end sub

sub parser_semtext(byval parser as parser_ ptr, byref pos_ as position_ ptr)
    
    parser_expect(parser,39)
    var beg = parser->la->pos
    var col = parser->la->col
    var line_ = parser->t->line
    while (parser_startof(parser,13)) 
      if (parser_startof(parser,14)) then
        parser_get(parser)
      elseif (parser->la->kind = 4) then
        parser_get(parser)
        parser_semerr(parser,@wstr("bad string in semantic action"))
      else
        parser_get(parser)
        parser_semerr(parser,@wstr("missing end of previous semantic action"))
      end if
    wend
    parser_expect(parser,40)
    pos_ = position_create(beg, parser->t->pos, col, line_)

DWPRINTFUNE:end sub

sub parser_expression(byval parser as parser_ ptr,byref g as graph_ ptr)
    
    dim g2 as graph_ ptr
    
    DWPRINTFUN
    parser_term(parser,g)
    dim first as ubyte = 1
    while (parser_weakseparator(parser,28,16,15) ) 
      parser_term(parser,g2)
      if (first) then
#ifdef DEBUG
        wprintf(@wstr(!"parser->t->val %ls\n"),parser->t->val)
        wprintf(@wstr(!"parser->la->val %ls\n"),parser->la->val)        
#endif
        tab_makefirstalt(parser->tab,g)
        first = 0
      end if
      tab_makealternative(parser->tab,g, g2)
    wend

DWPRINTFUNE:end sub

sub parser_simset(byval parser as parser_ ptr,byref  s as charset_ ptr)
    
    dim n1 as integer
    dim n2 as integer
    
    DWPRINTFUN
    s = charset_create()
    if (parser->la->kind = 1) then
      parser_get(parser)
      dim c as charclass_ ptr = tab_findcharclass_wchar(parser->tab,parser->t->val)
      if (c = NIL) then
        parser_semerr(parser,@wstr("undefined name"))
      else 
        charset_or(s,c->set)
      end if
    elseif (parser->la->kind = 3) then
      parser_get(parser)
      dim subname2 as wchar_t ptr = coco_string_create_il(parser->t->val, 1, coco_string_length(parser->t->val)-2)
      dim name_ as wchar_t ptr = tab_unescape(parser->tab,subname2)
      coco_string_destroy(subname2)
      dim ch as wchar_t
      var len_ = coco_string_length(name_)
      for i as integer = 0 to len_ - 1
        ch = name_[i]
        if (parser->dfa->ignorecase) then
          if ((asc("A") <= ch) andalso (ch <= asc("Z"))) then
            ch = ch - (asc("A") - asc("a")) '' ch.ToLower()
          end if
        end if
        charset_set(s,ch)
      next i
      coco_string_destroy(name_)
    elseif (parser->la->kind = 5) then
      parser_char(parser,@n1)
      charset_set(s,n1) 
      if (parser->la->kind = 22) then
        parser_get(parser)
        parser_char(parser,@n2)
        for i as integer = n1 to n2
          charset_set(s,i)
        next i
      end if
    elseif (parser->la->kind = 23) then
      parser_get(parser)
      s = charset_create()
      charset_fill(s)
    else 
      parser_synerr(parser,46)
    end if

DWPRINTFUNE:end sub

sub parser_char(byval parser as parser_ ptr, byval n as integer ptr)
    
    DWPRINTFUN
    parser_expect(parser,5)
    *n = 0
    dim subname as wchar_t ptr = coco_string_create_il(parser->t->val, 1, coco_string_length(parser->t->val)-2)
    dim name_ as wchar_t ptr = tab_unescape(parser->tab,subname)
    coco_string_destroy(subname)
    
    '' "<= 1" instead of "== 1" to allow the escape sequence '\0' in c++
    if (coco_string_length(name_) <= 1) then
      *n = name_[0]
    else 
      parser_semerr(parser,@wstr("unacceptable character value"))
    end if
    coco_string_destroy(name_)
    if (parser->dfa->ignorecase andalso ((cast(wchar_t, *n)) >= asc("A")) andalso ((cast(wchar_t,*n)) <= asc("Z"))) then
      *n += 32
    end if
                          
DWPRINTFUNE:end sub

sub parser_sym(byval parser as parser_ ptr,byref name_ as wchar_t ptr, byval kind as integer ptr)
    
    DWPRINTFUN
    name_ = coco_string_create(@wstr("???"))
    *kind = parser->id
    if (parser->la->kind = 1) then
      parser_get(parser)
      *kind = parser->id
      coco_string_destroy(name_)
      name_ = coco_string_create(parser->t->val)
    elseif (parser->la->kind = 3 orelse parser->la->kind = 5) then
      if (parser->la->kind = 3) then
        parser_get(parser)
        coco_string_destroy(name_)
        name_ = coco_string_create(parser->t->val) 
      else
        parser_get(parser)
#ifdef DEBUG
        wprintf(@wstr(!"parser->t->val %ls"),parser->t->val)
#endif
        dim subname as wchar_t ptr = coco_string_create_il(parser->t->val, 1, coco_string_length(parser->t->val)-2)
#ifdef DEBUG
        wprintf(@wstr(!"subname %ls"),subname)
#endif
        coco_string_destroy(name_)
        name_ = coco_string_create_appendws(@wstr(!"\""), subname)
        coco_string_destroy(subname)
        coco_string_merge(name_, @wstr(!"\""))
      end if
      *kind = parser->str
      if (parser->dfa->ignorecase) then
        dim oldname as wchar_t ptr = name_
        name_ = coco_string_create_lower(name_)
        coco_string_destroy(oldname)
      end if
      if (coco_string_indexof(name_, asc(" ")) >= 0) then
        parser_semerr(parser,@wstr("literal tokens must not contain blanks"))
      end if
    else 
      parser_synerr(parser,47)
    end if

DWPRINTFUNE:end sub

sub parser_term(byval parser as parser_ ptr,byref  g as graph_ ptr)
    
    DWPRINTFUN
    dim g2 as graph_ ptr
    dim rslv as node_ ptr = NIL
    g = NIL
    if (parser_startof(parser,17)) then
      if (parser->la->kind = 37) then
        rslv = tab_newnode(parser->tab,node_.rslv, cast(symbol_ ptr,NIL), parser->la->line)
        parser_resolver(parser,rslv->pos_)
        g = graph_create_node(rslv)
      end if
      parser_factor(parser,g2)
      if (rslv <> NIL) then
        tab_makesequence(parser->tab,g, g2)
      else 
        g = g2 
      end if
      while (parser_startof(parser,18)) 
        parser_factor(parser,g2)
        tab_makesequence(parser->tab,g, g2)
      wend
    elseif (parser_startof(parser,19)) then
      g = graph_create_node(tab_newnode(parser->tab,node_.eps, cast(symbol_ ptr,NIL), 0)) 
    else 
      parser_synerr(parser,48)
    end if
    if (g = NIL) then '' invalid start of Term
      g = graph_create_node(tab_newnode(parser->tab,node_.eps, cast(symbol_ ptr,NIL), 0))
    end if

DWPRINTFUNE:end sub

sub parser_resolver(byval parser as parser_ ptr, byref pos_ as position_ ptr)
    
    parser_expect(parser,37)
    parser_expect(parser,30)
    var beg = parser->la->pos
    var col = parser->la->col
    var line_ = parser->la->line
    parser_condition(parser)
    pos_ = position_create(beg, parser->t->pos, col, line_)

end sub

sub parser_factor(byval parser as parser_ ptr, byref g as graph_ ptr)
    
    dim name_ as wchar_t ptr  = NIL
    dim kind as integer 
    dim pos_ as position_ ptr 
    dim weak as byte = 0
    
    g = NIL
    
    DWPRINTFUN
    select case as const (parser->la->kind)
    case 1,3,5,29
     if (parser->la->kind = 29) then
        parser_get(parser)
        weak = 1
     end if
     parser_sym(parser,name_, @kind)
     dim sym as symbol_ ptr = tab_findsym(parser->tab,name_)
     if (sym = NIL andalso kind = parser->str) then
       sym = cast(symbol_ ptr,hashtable_itemat(parser->tab->literals,name_))
     end if
     dim undef as byte
     if (sym = NIL) then
       undef = 1
     else
       undef = 0
     end if
     if (undef) then
       if (kind = parser->id) then
         sym = tab_newsym(parser->tab,node_.nt, name_, 0)  '' forward nt
       elseif (parser->genscanner) then
         sym = tab_newsym(parser->tab,node_.t, name_, parser->t->line)
         dfa_matchliteral(parser->dfa,sym->name, sym)
       else   '' undefined string in production
         parser_semerr(parser,@wstr("undefined string in production"))
         sym = parser->tab->eofsy  '' dummy
       end if
     end if
     var typ = sym->typ
     if (typ <> node_.t andalso typ <> node_.nt) then
       parser_semerr(parser,@wstr("this symbol kind is not allowed in a production"))
     end if
     if (weak) then
       if (typ = node_.t) then
        typ = node_.wt
       else 
        parser_semerr(parser,@wstr("only terminals may be weak"))
       end if
     end if
     dim p as node_ ptr = tab_newnode(parser->tab,typ, sym, parser->t->line)
     g = graph_create_node(p)
     if (parser->la->kind = 24 orelse parser->la->kind = 26) then
       parser_attribs(parser,p)
       if (kind <> parser->id) then
         parser_semerr(parser,@wstr("a literal must not have attributes"))
       end if
     end if
     if (undef) then
      sym->attrpos = p->pos_  '' dummy
     elseif ((p->pos_ = NIL) <> (sym->attrpos = NIL)) then
      parser_semerr(parser,@wstr("attribute mismatch between declaration and use of this symbol"))
     end if
    case 30
      parser_get(parser)
      parser_expression(parser,g)
      parser_expect(parser,31)
    case 32
      parser_get(parser)
      parser_expression(parser,g)
      parser_expect(parser,33)
      tab_makeoption(parser->tab,g)
    case 34
      parser_get(parser)
      parser_expression(parser,g)
      parser_expect(parser,35)
      tab_makeiteration(parser->tab,g)
    case 39
      parser_semtext(parser,pos_)
      dim p as node_ ptr = tab_newnode(parser->tab,node_.sem, cast(symbol_ ptr,NIL), 0)
      p->pos_ = pos_
      g = graph_create_node(p)
    case 23
      parser_get(parser)
      dim p as node_ ptr = tab_newnode(parser->tab,node_.any_, cast(symbol_ ptr,NIL), 0)  '' p.set is set in tab->SetupAnys
      g = graph_create_node(p)
    case 36
      parser_get(parser)
      dim p as node_ ptr = tab_newnode(parser->tab,node_.sync, cast(symbol_ ptr,NIL), 0)
      g = graph_create_node(p)
    case else
      parser_synerr(parser,49)      
    end select
    
    if (g = NIL) then'' invalid start of Factor
      g = graph_create_node(tab_newnode(parser->tab,node_.eps, cast(symbol_ ptr,NIL), 0))
    end if
    
DWPRINTFUNE:end sub

'
sub parser_attribs(byval parser as parser_ ptr,byref  p as node_ ptr)
    
    DWPRINTFUN
    if (parser->la->kind = 24) then
      parser_get(parser)
      var beg = parser->la->pos
      var col = parser->la->col
      var line_ = parser->la->line
      while (parser_startof(parser,9)) 
        if (parser_startof(parser,10)) then
          parser_get(parser)
        else 
          parser_get(parser)
          parser_semerr(parser,@wstr("bad string in attributes"))
        end if
      wend
      parser_expect(parser,25)
      if (parser->t->pos > beg) then
        p->pos_ = position_create(beg, parser->t->pos, col, line_)
      end if
    elseif (parser->la->kind = 26) then
      parser_get(parser)
      var beg = parser->la->pos
      var col = parser->la->col
      var line_ = parser->la->line
      while (parser_startof(parser,11)) 
        if (parser_startof(parser,12)) then
          parser_get(parser)
        else
          parser_get(parser)
          parser_semerr(parser,@wstr("bad string in attributes"))
        end if
      wend
      parser_expect(parser,27)
      if (parser->t->pos > beg) then
        p->pos_ = position_create(beg, parser->t->pos, col, line_)
      end if
    else 
      parser_synerr(parser,50)
    end if

DWPRINTFUNE:end sub

sub parser_condition(byval parser as parser_ ptr)
    
    DWPRINTFUN
    while (parser_startof(parser,20))
      if (parser->la->kind = 30) then
        parser_get(parser)
        parser_condition(parser)
      else
        parser_get(parser)
      end if
    wend
    parser_expect(parser,31)

DWPRINTFUNE:end sub

sub parser_tokenterm(byval parser as parser_ ptr,byref g as graph_ ptr)

    dim g2 as graph_ ptr
    
    DWPRINTFUN
    parser_tokenfactor(parser,g)
    while (parser_startof(parser,8))
      parser_tokenfactor(parser,g2)
      tab_makesequence(parser->tab,g, g2)
    wend
    if (parser->la->kind = 38) then
      parser_get(parser)
      parser_expect(parser,30)
      parser_tokenexpr(parser,g2)
      tab_setcontexttrans(parser->tab,g2->l)
      parser->dfa->hasctxmoves = 1
      tab_makesequence(parser->tab,g, g2)
      parser_expect(parser,31)
    end if

DWPRINTFUNE:end sub

sub parser_tokenfactor(byval parser as parser_ ptr,byref g as graph_ ptr)
    
    DWPRINTFUN
    dim name_ as wchar_t ptr = NIL
    dim kind as integer
    g = NIL 
    if (parser->la->kind = 1 orelse parser->la->kind = 3 orelse parser->la->kind = 5) then
      parser_sym(parser,name_, @kind)
      if (kind = parser->id) then
         dim c as charclass_ ptr = tab_findcharclass_wchar(parser->tab,name_)
         if (c = NIL) then
           parser_semerr(parser,@wstr("undefined name"))
           c = tab_newcharclass(parser->tab,name_, charset_create())
         end if
         dim p as node_ ptr = tab_newnode(parser->tab,node_.clas, cast(symbol_ ptr,NIL), 0)
         p->val_ = c->n
         g = graph_create_node(p)
         parser->tokenstring = coco_string_create(parser->nostring)
      else '' str
         g = tab_strtograph(parser->tab,name_)
         if (parser->tokenstring = NIL) then
          parser->tokenstring = coco_string_create(name_)
         else 
          parser->tokenstring = coco_string_create(parser->nostring)
         end if
      end if
    elseif (parser->la->kind = 30) then
      parser_get(parser)
      parser_tokenexpr(parser,g)
      parser_expect(parser,31)
    elseif (parser->la->kind = 32) then
      parser_get(parser)
      parser_tokenexpr(parser,g)
      parser_expect(parser,33)
      tab_makeoption(parser->tab,g)
      parser->tokenstring = coco_string_create(parser->nostring) 
    elseif (parser->la->kind = 34) then
      parser_get(parser)
      parser_tokenexpr(parser,g)
      parser_expect(parser,35)
      tab_makeiteration(parser->tab,g)
      parser->tokenstring = coco_string_create(parser->nostring)
    else
      parser_synerr(parser,51)
    end if
    if (g = NIL) then'' invalid start of TokenFactor
      g = graph_create_node(tab_newnode(parser->tab,node_.eps, cast(symbol_ ptr,NIL), 0))
    end if

DWPRINTFUNE:end sub

sub parser_parse(byval parser as parser_ ptr)
  
  DWPRINTFUN
  parser->t = NIL
  parser->dummytoken = token_create()
  parser->la = parser->dummytoken
  parser->la->val = coco_string_create(@wstr("Dummy Token"))
  parser_get(parser)
  parser_coco(parser)
  parser_expect(parser,0)

DWPRINTFUNE:end sub

function parser_create(byval scanner as scanner_ ptr) as parser_ ptr
  
  dim parser as parser_ ptr

  parser = callocate(1,sizeof(parser_))
  parser->maxt = 41
  parser->dummytoken = NIL
  parser->la = NIL
  parser->t = NIL
  parser->minerrdist = 2
  parser->errdist = parser->minerrdist
  parser->scanner = scanner
  parser->errors = errors_create()
  return parser
  
end function

function parser_startof(byval parser as parser_ ptr, byval s as integer) as byte
  
  const T as ubyte = 1
  const x as ubyte = 0

  static set(0 to ...,0 to ...) as ubyte => {_
    {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},_
    {x,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},_
    {x,T,T,T, T,T,T,x, x,x,x,x, T,T,T,x, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},_
    {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,T,x, x,x,x,T, x,x,x,x, T,T,T,x, T,x,T,x, T,T,x,T, x,x,x},_
    {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},_
    {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},_
    {x,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},_
    {x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,T, x,x,x,x, x,x,x},_
    {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,T,x, x,x,x,x, x,x,x},_
    {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},_
    {x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},_
    {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},_
    {x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},_
    {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,T,x},_
    {x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, x,T,x},_
    {x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,T, x,x,x,x, x,x,x},_
    {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,x, T,T,T,T, T,T,T,T, T,T,x,T, x,x,x},_
    {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,T,x, T,x,T,x, T,T,x,T, x,x,x},_
    {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,T,x, T,x,T,x, T,x,x,T, x,x,x},_
    {x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,T, x,x,x,x, x,x,x},_
    {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,x} _
  }



  return set(s,parser->la->kind)

end function

sub parser_destroy(byref parser as parser_ ptr)
  
  if (parser = NIL) then
    return
  end if
  
  errors_destroy(parser->errors)

  if (parser->errors <> NIL) then
    deallocate(parser->errors)
    parser->errors = NIL
  end if
  
  deallocate(parser)
  parser = NIL

end sub

/'-------------------------------------------------------------------------
  Trace output options
  0 | A: prints the states of the scanner automaton
  1 | F: prints the First and Follow sets of all nonterminals
  2 | G: prints the syntax graph of the productions
  3 | I: traces the computation of the First sets
  4 | J: prints the sets associated with ANYs and synchronisation sets
  6 | S: prints the symbol table (terminals, nonterminals, pragmas)
  7 | X: prints a cross reference list of all syntax symbols
  8 | P: prints statistics about the Coco run

  Trace output can be switched on by the pragma
    $ { digit | letter }
  in the attributed grammar or as a command-line option
  -------------------------------------------------------------------------'/
#include once "crt/stdio.bi"
'#include once "Scanner.bi"
'#include once "Parser.bi"
'#include once "Tab.bi"

function my_main(byval argc as integer, byval argv_ as zstring ptr ptr) as integer
  
  dim argv as wchar_t ptr ptr = callocate(argc,sizeof(wchar_t ptr))
  for i as integer = 0 to argc - 1
    argv[i] = coco_string_create_zstr(argv_[i])
  next i

  wprintf(@wstr(!"Coco/R FreeBASIC version (June 10, 2011)\n"))
  dim srcname as wchar_t ptr = NIL
  dim nsname as wchar_t ptr = NIL 
  dim framedir as wchar_t ptr = NIL
  dim ddtstring as wchar_t ptr = NIL
  dim tracefilename as wchar_t ptr = NIL
  dim outdir as wchar_t ptr = NIL
  dim chtrfilename as ubyte ptr = NIL
  dim emitlines as byte = 0

  for i as integer = 1 to argc - 1
    if (coco_string_equal(argv[i], @wstr("-namespace")) andalso i < argc - 1) then
      i += 1
      nsname = coco_string_create(argv[i])    
    elseif (coco_string_equal(argv[i], @wstr("-frames")) andalso i < argc - 1) then
      i += 1
      framedir = coco_string_create(argv[i])
    elseif (coco_string_equal(argv[i], @wstr("-trace")) andalso i < argc - 1) then
      i += 1
      ddtstring = coco_string_create(argv[i])
    elseif (coco_string_equal(argv[i], @wstr("-o")) andalso i < argc - 1) then
      i += 1
      outdir = coco_string_create_appendwc(argv[i], asc("/"))
    elseif (coco_string_equal(argv[i], @wstr("-lines"))) then
      emitlines = 1
    else 
      srcname = coco_string_create(argv[i])
    end if
  next i

  for i as integer = 0 to argc - 1
    coco_string_destroy(argv[i])
  next i
  deallocate(argv)
  argv = NIL

  if (argc > 0 andalso srcname <> NIL) then
    dim pos_ as integer = coco_string_lastindexof(srcname, asc("/"))
    if (pos_ < 0) then
      pos_ = coco_string_lastindexof(srcname, asc(!"\\"))
    end if
    dim file_ as wchar_t ptr = coco_string_create(srcname)
    dim srcdir as wchar_t ptr
    ''if no srcdir given then srcdir is 0
    if (pos_ > 0) then
      srcdir = coco_string_create_il(srcname, 0, pos_+1)
    end if

    
    dim scanner as scanner_ ptr = scanner_create_wfile(file_)
    dim parser as parser_ ptr = parser_create(scanner)
    tracefilename = coco_string_create_appendws(srcdir, @wstr("trace.txt"))
    chtrfilename = coco_string_create_char(tracefilename)
    parser->trace = fopen(chtrfilename, "w+b")
    if (parser->trace = NIL) then
      wprintf(@wstr(!"-- could not open %ls\n"), chtrfilename)
      exit_(1)
    end if
    
    parser->tab  = tab_create(parser)
    parser->dfa  = dfa_create(parser)
    parser->pgen = parsergen_create(parser)
    parser->tab->srcname  = coco_string_create(srcname)
    parser->tab->srcdir   = coco_string_create(srcdir)
    parser->tab->nsname   = coco_string_create(nsname)
    parser->tab->framedir = coco_string_create(framedir)
    parser->tab->outdir   = coco_string_create(iif(outdir <> NIL,outdir,srcdir))
    parser->tab->emitLines = emitLines

    if (ddtstring <> NIL) then
      tab_setddt(parser->tab,ddtstring)
    end if

    parser_parse(parser)
    '' obtain the filesize
    parser->trace = fopen(chtrfilename, "r")
    fseek(parser->trace, 0, SEEK_END)
    var filesize = ftell(parser->trace)
    fclose(parser->trace)
    if (filesize = 0) then
      remove(chtrfilename)
    else
      wprintf(@wstr(!"trace output is in %ls\n"), chtrfilename)
    end if

    wprintf(@wstr(!"%d errors detected\n"), parser->errors->count)
    if (parser->errors->count <> 0) then
      exit_(1)
    end if

    'parser_destroy will destroy scanner and all other datastructures
    parser_destroy(parser)
    coco_string_destroy(file_)
    coco_string_destroy(srcdir)
  else
    wprintf(@wstr(!"Usage: Coco Grammar.ATG {Option}\n"))
    wprintf(@wstr(!"Options:\n"))
    wprintf(@wstr(!"  -namespace <namespaceName>\n"))
    wprintf(@wstr(!"  -frames    <frameFilesDirectory>\n"))
    wprintf(@wstr(!"  -trace     <traceString>\n"))
    wprintf(@wstr(!"  -o         <outputDirectory>\n"))
    wprintf(@wstr(!"  -lines\n"))
    wprintf(@wstr(!"Valid characters in the trace string:\n"))
    wprintf(@wstr(!"  A  trace automaton\n"))
    wprintf(@wstr(!"  F  list first/follow sets\n"))
    wprintf(@wstr(!"  G  print syntax graph\n"))
    wprintf(@wstr(!"  I  trace computation of first sets\n"))
    wprintf(@wstr(!"  J  list ANY and SYNC sets\n"))
    wprintf(@wstr(!"  P  print statistics\n"))
    wprintf(@wstr(!"  S  list symbol table\n"))
    wprintf(@wstr(!"  X  list cross reference table\n"))
    wprintf(@wstr(!"Scanner.frame and Parser.frame files needed in ATG directory\n"))
    wprintf(@wstr(!"or in a directory specified in the -frames option.\n"))
  end if

  coco_string_destroy(srcname)
  coco_string_destroy(nsname)
  coco_string_destroy(framedir)
  coco_string_destroy(ddtstring)
  coco_string_destroy_zstr(cast(zstring ptr,chtrfilename))
  coco_string_destroy(tracefilename)

  return 0

end function

my_main(__FB_ARGC__,__FB_ARGV__)
