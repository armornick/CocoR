/'----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------'/

/'----------------------------------------------------------------------
Scanner.bi Specification
-----------------------------------------------------------------------'/

-->begin

#ifndef COCO_SCANNER_H__
#define COCO_SCANNER_H__

#ifndef NIL
#define NIL 0
#endif

#include once "crt/limits.bi"
#include once "crt/stdio.bi"
#include once "crt/stdlib.bi"
#include once "crt/string.bi"
#include once "crt/wchar.bi"

'' io.h and fcntl are used to ensure binary read from streams on windows
#include once "crt/io.bi"
#include once "crt/fcntl.bi"


''snwprint is called snwprintf on linux and _snwprintf on windows
#ifdef __FB_WIN32__
  #define coco_swprintf _snwprintf
#else
  #ifdef __FB_LINUX__
    #define coco_swprintf snwprintf
  #else
    #define coco_swprintf snwprintf
  #endif
#endif

#define COCO_WCHAR_MAX 65535
#define MIN_BUFFER_LENGTH 1024
#define MAX_BUFFER_LENGTH (64*MIN_BUFFER_LENGTH)
#define HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR ":"

'' string handling, wide character
declare function coco_string_create(byval value as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_i(byval value as wchar_t ptr, byval startindex as integer) as wchar_t ptr
declare function coco_string_create_il(byval value as wchar_t ptr, byval startindex as integer, byval length as integer) as wchar_t ptr
declare function coco_string_create_upper(byval data_ as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_lower(byval data_ as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_lower_il(byval data_ as wchar_t ptr, byval startindex as integer, byval datalen as integer) as wchar_t ptr
declare function coco_string_create_appendws(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as wchar_t ptr
declare function coco_string_create_appendwc(byval target as wchar_t ptr, byval appendix as wchar_t) as wchar_t ptr
declare sub coco_string_destroy(byref data_ as wchar_t ptr)
declare function coco_string_length(byval data_ as wchar_t ptr) as integer
declare function coco_string_endswith(byval data_ as wchar_t ptr, byval end_ as wchar_t ptr) as byte
declare function coco_string_indexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
declare function coco_string_lastindexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
declare sub coco_string_merge(byref target as wchar_t ptr, byval appendix as wchar_t ptr)
declare function coco_string_equal(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as byte
declare function coco_string_compareto(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as integer
declare function coco_string_hash(byval data_ as wchar_t ptr) as integer

'' string handling, ascii character
declare function coco_string_create_zstr(byval value as zstring ptr) as wchar_t ptr
declare function coco_string_create_char(byval value as wchar_t ptr) as zstring ptr
declare sub coco_string_destroy_zstr(byref data_ as zstring ptr)


-->namespace_open

type token_

public:
	dim kind as integer     '' token kind
	dim pos as integer      '' token position in bytes in the source text (starting at 0)
	dim charpos as integer  '' token position in characters in the source text (starting at 0)
	dim col as integer      '' token column (starting at 1)
	dim line as integer     '' token line (starting at 1)
	dim val as wchar_t ptr 	'' token value
	dim next as token_ ptr  '' ML 2005-03-11 Peek tokens are kept in linked list

end type

declare function token_create() as token_ ptr
declare sub token_destroy(byref token as token_ ptr)

type buffer_
'' This Buffer supports the following cases:
'' 1) seekable stream (file)
''    a) whole stream in buffer
''    b) part of stream in buffer
'' 2) non seekable stream (network, console)
public:
	dim buf as ubyte ptr '' input buffer
	dim bufcapacity as integer   '' capacity of buf
	dim bufstart as integer       '' position of first byte in buffer relative to input stream
	dim buflen as integer         '' length of buffer
	dim filelen as integer        '' length of input stream (may change if the stream is no file)
	dim bufpos as integer         '' current position in buffer
	dim stream as FILE ptr       '' input stream (seekable)
	dim isuserstream as byte  '' was the stream opened by the user?
	
  'function pointers
  dim close_ as sub(byval buffer as buffer_ ptr)
  dim read_ as function(byval buffer as buffer_ ptr) as integer
  dim peek_ as function(byval buffer as buffer_ ptr) as integer
  dim getstring_ as function(byval buffer as buffer_ ptr, byval beg as integer, byval end_ as integer) as wchar_t ptr
  dim getpos_ as function(byval buffer as buffer_ ptr) as integer
  dim setpos_ as sub (byval buffer as buffer_ ptr, byval value as integer)
	
  enum
    _EoF = COCO_WCHAR_MAX + 1
  end enum

end type

declare function buffer_create_file(byval s as FILE ptr, byval isUserStream as byte) as buffer_ ptr
declare function buffer_create_array(byval buf as ubyte ptr, byval len_ as integer) as buffer_ ptr
declare function buffer_create_buffer(byval b as buffer_ ptr) as buffer_ ptr
declare sub buffer_destroy(byref buffer as buffer_ ptr)
declare function buffer_readnextstreamchunk(byval buffer as buffer_ ptr) as integer
declare function buffer_canseek(byval buffer as buffer_ ptr) as byte     '' true if stream can be seeked otherwise false

type utf8buffer_

public:
	dim buffer as buffer_ ptr
  'function pointers
  dim close_ as sub(byval buffer as buffer_ ptr)
  dim read_ as function(byval utf8buffer as utf8buffer_ ptr) as integer
  dim peek_ as function(byval buffer as buffer_ ptr) as integer
  dim getstring_ as function(byval buffer as buffer_ ptr, byval beg as integer, byval end_ as integer) as wchar_t ptr
  dim getpos_ as function(byval buffer as buffer_ ptr) as integer
  dim setpos_ as sub (byval buffer as buffer_ ptr, byval value as integer)  

end type

''-----------------------------------------------------------------------------------
'' StartStates  -- maps characters to start states of tokens
''-----------------------------------------------------------------------------------
type elem_

	public:
		dim val as integer
    dim key as integer
		dim next as elem_ ptr

end type

declare function elem_create(byval key as integer, byval val_ as integer) as elem_ ptr
declare sub elem_destroy(byref elem as elem_ ptr)

type startstates_

public:
	dim tab as elem_ ptr ptr

end type

declare function startstates_create() as startstates_ ptr
declare sub startstates_destroy(byref startstates as startstates_ ptr)
declare sub startstates_set(byval startstates as startstates_ ptr,byval key as integer, byval val_ as integer)
declare function startstates_state(byval startstates as startstates_ ptr, byval key as integer) as integer

''-------------------------------------------------------------------------------------------
'' KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
''-------------------------------------------------------------------------------------------
type keywordmap_elem_

	public:
		dim key as wchar_t ptr
		dim val as integer
		dim next as keywordmap_elem_ ptr

end type

declare function keywordmap_elem_create(byval key as wchar_t ptr, byval val_ as integer) as keywordmap_elem_ ptr
declare sub keywordmap_elem_destroy(byref keywordmap_elem as keywordmap_elem_ ptr)
  

type keywordmap_

public:
	dim tab as keywordmap_elem_ ptr ptr

end type

declare function keywordmap_create() as keywordmap_ ptr
declare sub keywordmap_destroy(byref keywordmap as keywordmap_ ptr)
declare sub keywordmap_set(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval val_ as integer)
declare function keywordmap_get(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval defaultval as integer) as integer	


type scanner_

public:

	dim firstheap as any ptr
	dim heap as any ptr
	dim heaptop as any ptr
	dim heapend as any ptr ptr

	dim eol as ubyte
	dim eofsym as integer
	dim nosym as integer
	dim maxt as integer
	dim charsetsize as integer
	dim start as startstates_ ptr
	dim keywords as keywordmap_ ptr

	dim t as token_ ptr         '' current token
	dim tval as wchar_t ptr     '' text of current token
	dim tvallength as integer   '' length of text of current token
	dim tlen as integer         '' length of current token

	dim tokens as token_ ptr    '' list of tokens already peeked (first token is a dummy)
	dim pt as token_ ptr        '' current peek token

  dim ch as integer           '' current input character
-->casing0
  dim pos as integer          '' byte position of current character
  dim charpos as integer      '' position by unicode characters starting with 0
  dim line as integer         '' line number of current character
  dim col as integer          '' column number of current character
  dim oldeols as integer      '' eols that appeared in a comment;

	dim buffer_typ as integer   '' 0 (ansi) or 1 (utf8)
  
  buffer as buffer_ ptr           '' scanner buffer, ansi 
  utf8buffer as utf8buffer_ ptr   '' scanner buffer, utf8

end type

declare sub scanner_createheapblock(byval scanner as scanner_ ptr)
declare function scanner_createtoken(byval scanner as scanner_ ptr) as token_ ptr
declare sub scanner_destroytoken(byref token as token_ ptr)
declare sub scanner_appendval(byval scanner as scanner_ ptr,byval t as token_ ptr)
declare sub scanner_setscannerbehindt(byval scanner as scanner_ ptr)
declare sub scanner_init(byval scanner as scanner_ ptr)
declare sub scanner_nextch(byval scanner as scanner_ ptr)
declare sub scanner_addch(byval scanner as scanner_ ptr)
-->commentsheader
declare function scanner_nexttoken(byval scanner as scanner_ ptr) as token_ ptr
declare function scanner_create_buffer(byval buf as ubyte ptr, byval len_ as integer) as scanner_ ptr
declare function scanner_create_wfile(byval filename as wchar_t ptr) as scanner_ ptr
declare function scanner_create_file(byval s as FILE ptr) as scanner_ ptr
declare sub scanner_destroy(byref scanner as scanner_ ptr)
declare function scanner_scan(byval scanner as scanner_ ptr) as token_ ptr
declare function scanner_peek(byval scanner as scanner_ ptr) as token_ ptr
declare sub scanner_resetpeek(byval scanner as scanner_ ptr)

-->namespace_close

#endif '' ifndef COCO_SCANNER_H__

-->implementation

/'----------------------------------------------------------------------
Scanner.bas Specification
-----------------------------------------------------------------------'/

-->begin

#include once "crt/string.bi"
#include once "Scanner.bi"


'' string handling, wide character
function coco_string_create(byval value as wchar_t ptr) as wchar_t ptr
	
  return coco_string_create_i(value, 0)

end function

function coco_string_create_i(byval value as wchar_t ptr, byval startindex as integer) as wchar_t ptr
	
  var valuelen = 0
	var len_ = 0

	if (value) then
		valuelen = wcslen(value)
		len_ = valueLen - startindex
	end if

	return coco_string_create_il(value, startindex, len_)

end function

function coco_string_create_il(byval value as wchar_t ptr, byval startindex as integer, byval length as integer) as wchar_t ptr
	
  var len_ = 0
	dim data_ as wchar_t ptr

	if (value) then
    len_ = length
  end if
	data_ = callocate(length + 1,sizeof(wchar_t))
	wcsncpy(data_, @(value[startindex]), len_)
	data_[len_] = 0

	return data_

end function

function coco_string_create_upper(byval data_ as wchar_t ptr) as wchar_t ptr
	
  if (data_ = 0) then
    return NIL
  end if

	dim datalen as integer
	if (data_) then
    dataLen = wcslen(data_)
  end if

	dim newdata as wchar_t ptr
  newdata = callocate(datalen + 1,sizeof(wchar_t))

	for i as integer = 0 to datalen
    if ((asc("a") <= data_[i]) andalso (data_[i] <= asc("z"))) then
			newdata[i] = data_[i] + (asc("A") - asc("a"))
		else 
      newdata[i] = data_[i]
    end if
	next i

	newdata[datalen] = 0
	return newdata

end function

function coco_string_create_lower(byval data_ as wchar_t ptr) as wchar_t ptr
	
  if (data_ = NIL) then
    return NIL
  end if
	var dataLen = wcslen(data_)
	return coco_string_create_lower_il(data_, 0, datalen)

end function

function coco_string_create_lower_il(byval data_ as wchar_t ptr, byval startindex as integer, byval datalen as integer) as wchar_t ptr
	
  if (data_ = 0) then
    return NIL
  end if

	dim newdata as wchar_t ptr = callocate(datalen + 1,sizeof(wchar_t))

	for i as integer = 0 to datalen
		dim ch as wchar_t = data_[startindex + i]
		if ((asc("A") <= ch) andalso (ch <= asc("Z"))) then
			newdata[i] = ch - (asc("A") - asc("a"))
		else 
      newdata[i] = ch
    end if
	next i
	newdata[datalen] = asc(!"\0")
	return newdata

end function

function coco_string_create_appendws(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as wchar_t ptr
	
  dim data_ as wchar_t ptr
	var data1len = 0
	var data2len = 0

	if (data1) then
    data1len = wcslen(data1)
  end if
	
  if (data2) then
    data2len = wcslen(data2)
  end if

	data_ = callocate(data1len + data2len + 1,sizeof(wchar_t))

	if (data1) then
    wcscpy(data_, data1)
  end if
	
  if (data2) then
    wcscpy(data_ + data1len, data2)
  end if

	data_[data1len + data2len] = 0

	return data_

end function

function coco_string_create_appendwc(byval target as wchar_t ptr, byval appendix as wchar_t) as wchar_t ptr
	
  var targetlen = coco_string_length(target)
	dim data_ as wchar_t ptr = callocate(targetlen + 2,sizeof(wchar_t))
	wcsncpy(data_, target, targetlen)
	data_[targetlen] = appendix
	data_[targetlen + 1] = 0
	return data_

end function

sub coco_string_destroy(byref data_ as wchar_t ptr)
	
  if (data_ <> NIL) then
    deallocate(data_)
  end if
	data_ = NIL
  
end sub

function coco_string_length(byval data_ as wchar_t ptr) as integer
	
  if (data_) then
    return wcslen(data_)
	end if
  return 0

end function

function coco_string_endswith(byval data_ as wchar_t ptr, byval end_ as wchar_t ptr) as byte

	var datalen = wcslen(data_)
	var endlen = wcslen(end_)
	return (endlen <= datalen) andalso (wcscmp(data_ + datalen - endlen, end_) = 0)

end function

function coco_string_indexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
	
  dim chr_ as wchar_t ptr = wcschr(data_, value)

	if (chr_) then
    return (chr_- data_)
  end if
	return -1

end function

function coco_string_lastindexof(byval data_ as wchar_t ptr, byval value as wchar_t) as integer
	
  dim chr_ as wchar_t ptr = wcsrchr(data_, value)

	if (chr_) then
    return (chr_-data_)
  end if
	return -1

end function

sub coco_string_merge(byref target as wchar_t ptr, byval appendix as wchar_t ptr)

	if (appendix = NIL) then
    return
  end if
  
	dim data_ as wchar_t ptr = coco_string_create_appendws(target, appendix)
	deallocate(target)
	target = data_

end sub

function coco_string_equal(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as byte

	return wcscmp( data1, data2 ) = 0

end function

function coco_string_compareto(byval data1 as wchar_t ptr, byval data2 as wchar_t ptr) as integer

	return wcscmp(data1, data2)

end function

function coco_string_hash(byval data_ as wchar_t ptr) as integer
	
  var h = 0
	if (data_ = NIL) then
    return 0
  end if
	
  while (*data_ <> 0) 
		h = (h * 7) xor *data_
		data_ += 1
	wend
	if (h < 0) then
    h = -h
  end if
	return h

end function

'' string handling, ascii character

function coco_string_create_zstr(byval value as zstring ptr) as wchar_t ptr
	
  var len_ = 0
	if (value) then
    len_ = strlen(value)
  end if
	dim data_ as wchar_t ptr = callocate(len_ + 1,sizeof(wchar_t))
	for i as integer = 0 to len_ - 1
    data_[i] = cast(wchar_t,value[0][i])
  next i
	data_[len_] = 0
	return data_
  
end function

function coco_string_create_char(byval value as wchar_t ptr) as zstring ptr
	
  var len_ = coco_string_length(value)
	dim res as zstring ptr
  res = callocate(len_ + 1,sizeof(ubyte))
	for i as integer = 0 to len_ - 1
    res[0][i] = cast(ubyte,value[i])
  next i  
	res[0][len_] = 0
	return res
  
end function

sub coco_string_destroy_zstr(byref data_ as zstring ptr)
	
  if (data_ <> NIL) then
    deallocate(data_)
    data_ = NIL
  end if

end sub

-->namespace_open

function startstates_create() as startstates_ ptr

  dim startstates as startstates_ ptr
  startstates = callocate(1,sizeof(startstates_))
  startstates->tab = callocate(128,sizeof(elem_ ptr))
  memset(startstates->tab,0,128 * sizeof(elem_ ptr))
  return startstates
  
end function

sub startstates_destroy(byref startstates as startstates_ ptr)
  
  for i as integer = 0 to 127
    dim e as elem_ ptr = startstates->tab[i]
    while (e <> NIL) 
      var next_ = e->next
      deallocate(e)
      e = NIL
      e = next_
    wend
  next i
  deallocate(startstates->tab)
  deallocate(startstates)

end sub

function elem_create(byval key as integer, byval val_ as integer) as elem_ ptr

  dim elem as elem_ ptr
  elem = callocate(1,sizeof(elem_))
  elem->key = key
  elem->val = val_
  elem->next = NIL
  return elem
  
end function

''STUB
sub elem_destroy(byref elem as elem_ ptr)

  if (elem = NIL) then
    return
  end if
  
  deallocate(elem)

end sub

sub startstates_set(byval startstates as startstates_ ptr,byval key as integer, byval val_ as integer)

  dim e as elem_ ptr = elem_create(key, val_)
  dim k as integer = (cast(uinteger,key) mod 128)
  e->next = startstates->tab[k]
  startstates->tab[k] = e
end sub

function startstates_state(byval startstates as startstates_ ptr, byval key as integer) as integer

  dim e as elem_ ptr = startstates->tab[(cast(uinteger,key)) mod 128]
  while (e <> NIL andalso e->key <> key) 
    e = e->next
  wend
  if (e = NIL) then
    return 0
  else
    return e->val
  end if

end function
  
function keywordmap_create() as keywordmap_ ptr

  dim keywordmap as keywordmap_ ptr
  keywordmap = callocate(1,sizeof(keywordmap_))
  keywordmap->tab = callocate(128,sizeof(keywordmap_elem_ ptr))
  memset(keywordmap->tab, 0, 128 * sizeof(keywordmap_elem_ ptr))
  return keywordmap
  
end function
  
sub keywordmap_destroy(byref keywordmap as keywordmap_ ptr)

  for i as integer = 0 to 128 - 1
    dim e as keywordmap_elem_ ptr = keywordmap->tab[i]
    while (e <> NIL)
      dim nxt as keywordmap_elem_ ptr = e->next
      keywordmap_elem_destroy(e)
      deallocate(e)
      e = nxt
    wend
  next i
  
  deallocate(keywordmap->tab)
  deallocate(keywordmap)

end sub

function keywordmap_elem_create(byval key as wchar_t ptr, byval val_ as integer) as keywordmap_elem_ ptr
  
  dim map as keywordmap_elem_ ptr
  map = callocate(1,sizeof(keywordmap_elem_))
  map->key = coco_string_create(key)
  map->val = val_
  map->next = NIL
  return map

end function

sub keywordmap_elem_destroy(byref keywordmap_elem as keywordmap_elem_ ptr)
    
  coco_string_destroy(keywordmap_elem->key)
  deallocate(keywordmap_elem)
  keywordmap_elem = NIL
  
end sub

sub keywordmap_set(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval val_ as integer)

  dim e as keywordmap_elem_ ptr = keywordmap_elem_create(key,val_)
  'change 128 to a larger value if the language you are implementing has lots of keywords
  '128 assumes there are 64 or less keywords (size of table = 2 * number of keywords). 
  'forumula: var k = coco_string_hash(key) mod number_of_keywords * 2
  var k = coco_string_hash(key) mod 128
  e->next = keywordmap->tab[k]
  keywordmap->tab[k] = e

end sub

function keywordmap_get(byval keywordmap as keywordmap_ ptr,byval key as wchar_t ptr, byval defaultval as integer) as integer

  dim e as keywordmap_elem_ ptr = keywordmap->tab[coco_string_hash(key) mod 128]
  while (e <> NIL andalso 0 = coco_string_equal(e->key, key)) 
    e = e->next
  wend
  if (e = NIL) then
    return defaultval
  else
    return e->val
  end if

end function

function token_create() as token_ ptr
	
  dim token as token_ ptr
  token = callocate(1,sizeof(token_))
  token->kind = 0
  token->pos  = 0
  token->col  = 0
  token->line = 0
  token->val  = NIL
  token->next = NIL
  return token
  
end function

sub token_destroy(byref token as token_ ptr)
	
  if (token = NIL) then
    return
  end if
 
  if (token->val <> NIL) then
    coco_string_destroy(token->val)
  end if
  
  deallocate(token)
  token = NIL
  
end sub

sub buffer_close_imp(byval buffer as buffer_ ptr)
	
  if (buffer->isuserstream = 0 andalso buffer->stream <> NIL) then
		fclose(buffer->stream)
		buffer->stream = NIL
	end if
  
end sub

function buffer_read_imp(byval buffer as buffer_ ptr) as integer
	
  if (buffer->bufpos < buffer->buflen) then
		buffer->bufpos += 1
    return buffer->buf[buffer->bufpos-1]
	elseif (buffer->getpos_(buffer) < buffer->filelen) then
		buffer->setpos_(buffer,buffer->getpos_(buffer)) '' shift buffer start to Pos
		buffer->bufpos += 1
    return buffer->buf[buffer->bufpos-1]
	elseif ((buffer->stream <> NIL) andalso buffer_canseek(buffer) = 0 andalso (buffer_readnextstreamchunk(buffer) > 0)) then
		buffer->bufpos += 1
    return buffer->buf[buffer->bufpos-1]
	else
		return buffer_._EoF
	end if

end function

function buffer_peek_imp(byval buffer as buffer_ ptr) as integer
	
  var curpos = buffer->getpos_(buffer)
	var ch = buffer->read_(buffer)
	buffer->setpos_(buffer,curpos)
	return ch

end function

'' beg .. begin, zero-based, inclusive, in byte
'' end .. end, zero-based, exclusive, in byte
function buffer_getstring_imp(byval buffer as buffer_ ptr,byval beg as integer,byval end_ as integer) as wchar_t ptr

	var len_ = 0
	dim buf as wchar_t ptr = callocate(end_ - beg,sizeof(wchar_t))
	var oldpos = buffer->getpos_(buffer)
	buffer->setpos_(buffer,beg)
	while (buffer->getpos_(buffer) < end_) 
    buf[len_] = cast(wchar_t, buffer->read_(buffer)):len_ += 1
  wend
	buffer->setpos_(buffer,oldpos)
  var res = coco_string_create_il(buf, 0, len_)
	coco_string_destroy(buf)
	return res

end function


function buffer_getpos_imp(byval buffer as buffer_ ptr) as integer
	
  return buffer->bufpos + buffer->bufstart

end function

sub buffer_setpos_imp(byval buffer as buffer_ ptr, byval value as integer)

	if ((value >= buffer->filelen) andalso (buffer->stream <> NIL) andalso buffer_canseek(buffer) = 0) then
		'' Wanted position is after buffer and the stream
		'' is not seek-able e.g. network or console,
		'' thus we have to read the stream manually till
		'' the wanted position is in sight.
		while ((value >= buffer->filelen) andalso (buffer_readnextstreamchunk(buffer) > 0))
    wend
  end if

	if ((value < 0) orelse (value > buffer->filelen)) then
		wprintf(@wstr(!"--- buffer out of bounds access, position: %d\n"), value)
		exit_(1)
	end if

	if ((value >= buffer->bufstart) andalso (value < (buffer->bufstart + buffer->buflen))) then '' already in buffer
		buffer->bufpos = value - buffer->bufstart
	elseif (buffer->stream <> NIL) then '' must be swapped in
		fseek(buffer->stream, value, SEEK_SET)
		buffer->buflen = fread(buffer->buf, sizeof(ubyte), buffer->bufcapacity, buffer->stream)
		buffer->bufstart = value:buffer->bufpos = 0
	else
		buffer->bufpos = buffer->fileLen - buffer->bufstart '' make Pos return fileLen
	end if

end sub

function buffer_create_file(byval s as FILE ptr, byval isuserstream as byte) as buffer_ ptr

  dim buffer as buffer_ ptr
  buffer = callocate(1,sizeof(buffer_))
'' ensure binary read on windows
	_setmode(_fileno(s), _O_BINARY)
	buffer->stream = s
  buffer->isuserstream = isuserstream
	if (buffer_canseek(buffer)) then
		fseek(s, 0, SEEK_END)
		buffer->fileLen = ftell(s)
		fseek(s, 0, SEEK_SET)
    buffer->buflen = iif(buffer->fileLen < MAX_BUFFER_LENGTH,buffer->fileLen, MAX_BUFFER_LENGTH)
		buffer->bufstart = INT_MAX '' nothing in the buffer so far
	else 
		buffer->bufstart = 0 
    buffer->buflen = 0
    buffer->filelen =  0
	end if
  buffer->read_ = @buffer_read_imp
  buffer->close_ = @buffer_close_imp
  buffer->peek_ = @buffer_peek_imp
  buffer->getstring_ = @buffer_getstring_imp
  buffer->getpos_ = @buffer_getpos_imp
  buffer->setpos_ = @buffer_setpos_imp  
	buffer->bufcapacity = iif(buffer->buflen > 0, buffer->buflen,MIN_BUFFER_LENGTH)
	buffer->buf = callocate(buffer->bufcapacity,sizeof(ubyte))
	if (buffer->filelen > 0) then
    buffer->setpos_(buffer,0)          '' setup  buffer to position 0 (start)
	else 
    buffer->bufpos = 0 '' index 0 is already after the file, thus Pos = 0 is invalid
  end if
	if (buffer->buflen = buffer->filelen andalso buffer_canseek(buffer)) then
    buffer->close_(buffer)
  end if
  return buffer
  
end function

function buffer_create_buffer(byval b as buffer_ ptr) as buffer_ ptr

  dim buffer as buffer_ ptr
  buffer = callocate(1,sizeof(buffer_))

	buffer->buf = b->buf
	buffer->bufcapacity = b->bufcapacity
	b->buf = NIL
	buffer->bufstart = b->bufstart
	buffer->bufLen = b->buflen
	buffer->fileLen = b->filelen
	buffer->bufpos = b->bufpos
	buffer->stream = b->stream
	b->stream = NIL
	buffer->isuserstream = b->isuserstream
  'set function pointers
  buffer->read_ = b->read_
  buffer->close_ = b->close_
  buffer->peek_ = b->peek_
  buffer->getpos_ = b->getpos_
  buffer->setpos_ = b->setpos_
  return buffer
  
end function

function buffer_create_array(byval buf as ubyte ptr, byval len_ as integer) as buffer_ ptr

  dim buffer as buffer_ ptr
  buffer = callocate(1,sizeof(buffer_))	
  
  buffer->buf = callocate(len_,sizeof(ubyte))
	memcpy(buffer->buf, buf, len_*sizeof(ubyte))
	buffer->bufstart = 0
  buffer->buflen = len_	
  buffer->bufcapacity = len_
	buffer->fileLen = len_
	buffer->bufpos = 0
	buffer->stream = NIL
  'set function pointers
  buffer->close_ = @buffer_close_imp
  buffer->read_ = @buffer_read_imp
  buffer->peek_ = @buffer_peek_imp
  buffer->getstring_ = @buffer_getstring_imp
  buffer->getpos_ = @buffer_getpos_imp
  buffer->setpos_ = @buffer_setpos_imp  
  return buffer
  
end function

sub buffer_destroy(byref buffer as buffer_ ptr)
	
  if (buffer = NIL) then
    return
  end if
  
  buffer->close_(buffer)
	if (buffer->buf <> NIL) then
		deallocate(buffer->buf)
		buffer->buf = NIL
	end if
  buffer = NIL
  
end sub

'' Read the next chunk of bytes from the stream, increases the buffer
'' if needed and updates the fields fileLen and bufLen.
'' Returns the number of bytes read.
function buffer_readnextstreamchunk(byval buffer as buffer_ ptr) as integer
	
  dim free_ as integer = buffer->bufcapacity - buffer->buflen
	if (free_ = 0) then
		'' in the case of a growing input stream
		'' we can neither seek in the stream, nor can we
		'' foresee the maximum length, thus we must adapt
		'' the buffer size on demand.
		buffer->bufcapacity = buffer->buflen * 2
		var newbuf = cast(ubyte ptr,callocate(buffer->bufcapacity,sizeof(ubyte)))
		memcpy(newbuf, buffer->buf, buffer->buflen*sizeof(ubyte))
		deallocate(buffer->buf)
		buffer->buf = newbuf
		free_ = buffer->buflen
	end if
	var read_ = fread(buffer->buf + buffer->buflen, sizeof(ubyte), free_, buffer->stream)
	if (read_ > 0) then
		buffer->buflen = buffer->buflen + read_
    buffer->filelen = buffer->buflen
		return read_
	end if
	'' end of stream reached
	return 0

end function

function buffer_canseek(byval buffer as buffer_ ptr) as byte
	
  return (buffer->stream <> NIL) andalso (ftell(buffer->stream) <> -1)

end function


function utf8buffer_read_imp(byval utf8buffer as utf8buffer_ ptr) as integer
	
  dim ch as integer
	do 
		ch = utf8buffer->buffer->read_(utf8buffer->buffer)
		'' until we find a utf8 start (0xxxxxxx or 11xxxxxx)
	loop while ((ch >= 128) andalso ((ch and &hC0) <> &hC0) andalso (ch <> buffer_._EoF))
	if (ch < 128 orelse ch = buffer_._EoF) then 
		'' nothing to do, first 127 chars are the same in ascii and utf8
		'' &hxxxxxx or end of file character
	elseif ((ch and &hF0) = &hF0) then
		'' 1111&hxx 1&hxxxxx 1&hxxxxx 1&hxxxxx
		var c1 = ch and &h07: ch = utf8buffer->buffer->read_(utf8buffer->buffer)
		var c2 = ch and &h3F: ch = utf8buffer->buffer->read_(utf8buffer->buffer)
		var c3 = ch and &h3F: ch = utf8buffer->buffer->read_(utf8buffer->buffer)
		var c4 = ch and &h3F
		ch = (((((c1 shl 6) or c2) shl 6) or c3) shl 6) or c4
	elseif ((ch and &hE0) = &hE0) then
		'' 111&hxxx 1&hxxxxx 1&hxxxxx
		var c1 = ch and &h0F:ch = utf8buffer->buffer->read_(utf8buffer->buffer)
		var c2 = ch and &h3F:ch = utf8buffer->buffer->read_(utf8buffer->buffer)
		var c3 = ch and &h3F
		ch = (((c1 shl 6) or c2) shl 6) or c3
	elseif ((ch and &hC0) = &hC0) then
		'' 11&hxxxx 1&hxxxxx
		var c1 = ch and &h1F:ch = utf8buffer->buffer->read_(utf8buffer->buffer)
		var c2 = ch and &h3F
		ch = (c1 shl 6) or c2
	end if
	return ch

end function

function utf8buffer_create(byval b as buffer_ ptr) as utf8buffer_ ptr

  dim utf8buffer as utf8buffer_ ptr
  utf8buffer = callocate(1,sizeof(utf8buffer_))
  utf8buffer->read_ = @utf8buffer_read_imp
  'set function pointers
  utf8buffer->close_ = b->close_
  utf8buffer->peek_ = b->peek_
  utf8buffer->getstring_ = b->getstring_
  utf8buffer->getpos_ = b->getpos_
  utf8buffer->setpos_ = b->setpos_
  utf8buffer->buffer = b
  
  return utf8buffer

end function

sub utf8buffer_destroy(byref utf8buffer as utf8buffer_ ptr)

  if (utf8buffer = NIL) then
    return
  end if
  
  if (utf8buffer->buffer <> NIL) then
    buffer_destroy(utf8buffer->buffer)
  end if
  deallocate(utf8buffer)
  utf8buffer = NIL

end sub

function scanner_create_buffer(byval buf as ubyte ptr, byval len_ as integer) as scanner_ ptr
	
  dim scanner as scanner_ ptr
  scanner = callocate(1,sizeof(scanner_))
  scanner->buffer = buffer_create_array(buf, len_)
	scanner_init(scanner)
  return scanner
  
end function

function scanner_create_wfile(byval filename as wchar_t ptr) as scanner_ ptr
	
  dim stream as FILE ptr
  dim scanner as scanner_ ptr
  scanner = callocate(1,sizeof(scanner_))
	dim chfilename as zstring ptr = coco_string_create_char(filename)
	stream = fopen(chfilename, "rb")
  if (stream= NIL) then
		wprintf(@wstr(!"--- Cannot open file %ls\n"), filename)
		exit_(1)
	end if
	coco_string_destroy_zstr(cast(zstring ptr,chfilename))
	scanner->buffer = buffer_create_file(stream, 0)
	scanner_init(scanner)
  return scanner
  
end function

function scanner_create_file(byval s as FILE ptr) as scanner_ ptr
	
  dim scanner as scanner_ ptr
  scanner = callocate(1,sizeof(scanner_))
  scanner->buffer = buffer_create_file(s, 1)
	scanner_init(scanner)
  return scanner
  
end function

sub scanner_destroy(byref scanner as scanner_ ptr)
	
  dim cur as ubyte ptr = cast(ubyte ptr,scanner->firstheap)

	while(cur <> NIL) 
		cur = *(cast(ubyte ptr ptr,cur + HEAP_BLOCK_SIZE))
		deallocate(scanner->firstheap)
		scanner->firstheap = cur
	wend
	deallocate(scanner->tval)
  scanner->tval = NIL
	buffer_destroy(scanner->buffer)
  utf8buffer_destroy(scanner->utf8buffer)

end sub

sub scanner_init(byval scanner as scanner_ ptr)
  scanner->eol    = asc(!"\n")
	scanner->eofsym = 0

-->declarations

	scanner->tvallength = 128
	scanner->tval = callocate(scanner->tvallength,sizeof(wchar_t)) '' text of current token

	'' HEAP_BLOCK_SIZE byte heap + pointer to next heap block
	scanner->heap = callocate(1,HEAP_BLOCK_SIZE + sizeof(any ptr))
	scanner->firstheap = scanner->heap
	scanner->heapend = cast(any ptr ptr,((cast(ubyte ptr,scanner->heap) + HEAP_BLOCK_SIZE)))
	*(scanner->heapend) = 0
	scanner->heaptop = scanner->heap
	if (sizeof(token_) > HEAP_BLOCK_SIZE) then
		wprintf(@wstr(!"--- Too small HEAP_BLOCK_SIZE\n"))
		exit_(1)
	end if

	scanner->pos = -1:scanner->line = 1:scanner->col = 0:scanner->charpos = -1
	scanner->oldeols = 0
	scanner_nextch(scanner)
	if (scanner->ch = &hEF) then'' check optional byte order mark for UTF-8
		scanner_nextch(scanner): var ch1 = scanner->ch
		scanner_nextch(scanner): var ch2 = scanner->ch
		if (ch1 <> &hBB orelse ch2 <> &hBF) then
			wprintf(@wstr(!"Illegal byte order mark at start of file"))
			exit_(1)
		end if
		scanner->buffer_typ = 1 ''utf8
    scanner->utf8buffer = utf8buffer_create(scanner->buffer)
    scanner->col = 0
    scanner->charpos = -1
		scanner_nextch(scanner)
	end if

-->initialization
	scanner->tokens = token_create()
  scanner->pt = scanner->tokens '' first token is a dummy

end sub

sub scanner_nextch(byval scanner as scanner_ ptr)

  if (scanner->oldeols > 0) then
    scanner->ch = scanner->eol
    scanner->oldeols -= 1
	else 
		scanner->pos = scanner->buffer->getpos_(scanner->buffer)
		'' buffer reads unicode chars, if UTF8 has been detected
		if (scanner->buffer_typ = 0) then
      scanner->ch = scanner->buffer->read_(scanner->buffer)
    else
      scanner->ch = scanner->utf8buffer->read_(scanner->utf8buffer)
    end if      
    scanner->col += 1:scanner->charpos += 1
		'' replace isolated '\r' by '\n' in order to make
		'' eol handling uniform across Windows, Unix and Mac
		if (scanner->ch = asc(!"\r") andalso scanner->buffer->peek_(scanner->buffer) <> asc(!"\n")) then
      scanner->ch = scanner->eol
    end if
		if (scanner->ch = scanner->eol) then
      scanner->line += 1
      scanner->col = 0
    end if
	end if
-->casing1

end sub

sub scanner_addch(byval scanner as scanner_ ptr)
	
  if (scanner->tlen >= scanner->tvallength) then
		scanner->tvallength *= 2
		var newbuf = callocate(scanner->tvallength,sizeof(wchar_t))
		memcpy(newbuf, scanner->tval, scanner->tlen*sizeof(wchar_t))
		deallocate(scanner->tval)
		scanner->tval = newbuf
	end if
	if (scanner->ch <> buffer_._EoF) then
-->casing2
		scanner_nextch(scanner)
	end if

end sub

-->comments

sub scanner_createheapblock(byval scanner as scanner_ ptr)
  
  dim newheap as any ptr
  dim cur as ubyte ptr = cast(ubyte ptr,scanner->firstheap)

  while((cast(ubyte ptr,scanner->tokens) < cur) orelse (cast(ubyte ptr,scanner->tokens) > (cur + HEAP_BLOCK_SIZE)))
    cur = *(cast(ubyte ptr ptr, (cur + HEAP_BLOCK_SIZE)))
    deallocate(scanner->firstheap)
    scanner->firstheap = cur
  wend

  '' HEAP_BLOCK_SIZE byte heap + pointer to next heap block
  newheap = callocate(1,HEAP_BLOCK_SIZE + sizeof(any ptr))
  *(scanner->heapend) = newheap
  scanner->heapend = cast(any ptr ptr,((cast(ubyte ptr,newheap)) + HEAP_BLOCK_SIZE))
  *(scanner->heapend) = 0
  scanner->heap = newheap
  scanner->heaptop = scanner->heap

end sub


function scanner_createtoken(byval scanner as scanner_ ptr) as token_ ptr
  
  dim t as token_ ptr
  if ((cast(ubyte ptr,scanner->heaptop) + cast(integer,sizeof(token_))) >= cast(ubyte ptr,scanner->heapend)) then
     scanner_createheapblock(scanner)
  end if
  t = cast(token_ ptr,scanner->heaptop)
  scanner->heaptop = cast(any ptr, (cast(ubyte ptr,scanner->heaptop) + sizeof(token_)))
  t->val = NIL
  t->next = NIL
  return t

end function


sub scanner_appendval(byval scanner as scanner_ ptr, byval t as token_ ptr)
  
  var reqmem = (scanner->tlen + 1) * sizeof(wchar_t)
  if ((cast(ubyte ptr,scanner->heaptop) + reqmem) >= cast(ubyte ptr,scanner->heapend)) then
    if (reqmem > HEAP_BLOCK_SIZE) then
      wprintf(@wstr(!"--- Too long token value\n"))
      exit_(1)
    end if
    scanner_createheapblock(scanner)
  end if
  t->val = cast(wchar_t ptr,scanner->heaptop)
  scanner->heaptop = cast(any ptr,(cast(ubyte ptr,scanner->heaptop) + reqmem))

  wcsncpy(t->val, scanner->tval, scanner->tlen)
  t->val[scanner->tlen] = 0

end sub

function scanner_nexttoken(byval scanner as scanner_ ptr) as token_ ptr
	
  while (scanner->ch = asc(" ") orelse _
-->scan1
  )
    scanner_nextch(scanner)
  wend
-->scan2
  var reckind = scanner->nosym
	var recend = scanner->pos
	scanner->t = scanner_createtoken(scanner)
	scanner->t->pos = scanner->pos
  scanner->t->col = scanner->col
  scanner->t->line = scanner->line
  scanner->t->charpos = scanner->charpos
  var state = startstates_state(scanner->start,scanner->ch)
	scanner->tlen = 0
  scanner_addch(scanner)

	select case as const state
		case 0 
			case_0:
			if (reckind <> scanner->nosym) then
				scanner->tlen = recend - scanner->t->pos
				scanner_setscannerbehindt(scanner)
			end if
			scanner->t->kind = reckind
      '' Nextscanner->ch already done
-->scan3
    case else
      if (state = -1) then
        scanner->t->kind = scanner->eofsym  '' Nextscanner->ch already done
      end if
      exit select
	end select
	scanner_appendval(scanner,scanner->t)
	return scanner->t

end function


sub scanner_setscannerbehindt(byval scanner as scanner_ ptr)
	
  scanner->buffer->setpos_(scanner->buffer,scanner->t->pos)
	scanner_nextch(scanner)
	scanner->line = scanner->t->line
  scanner->col = scanner->t->col
  scanner->charpos = scanner->t->charpos
	for i as integer = 0 to scanner->tlen - 1 
    scanner_nextch(scanner)
  next i
  
end sub

'' get the next token (possibly a token already seen during peeking)
function scanner_scan(byval scanner as scanner_ ptr) as token_ ptr

  if (scanner->tokens->next = NIL) then
    scanner->tokens = scanner_nexttoken(scanner)
    scanner->pt = scanner->tokens
    return scanner->pt
	else 
		scanner->tokens = scanner->tokens->next
    scanner->pt = scanner->tokens
		return scanner->tokens
	end if

end function

'' peek for the next token, ignore pragmas
function scanner_peek(byval scanner as scanner_ ptr) as token_ ptr

	do
		if (scanner->pt->next = NIL) then
			scanner->pt->next = scanner_nexttoken(scanner)
		end if
		scanner->pt = scanner->pt->next
	loop while (scanner->pt->kind > scanner->maxt) '' skip pragmas

	return scanner->pt

end function

'' make sure that peeking starts at the current scan position
sub scanner_resetpeek(byval scanner as scanner_ ptr)

  if (scanner = NIL) then
    return
  end if
  scanner->pt = scanner->tokens

end sub

-->namespace_close
